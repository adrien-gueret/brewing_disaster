(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var web3 = {};

	let availableSections = [];
	let nextSectionVars = {};

	function isValidSection(sectionName) {
	  return availableSections.includes(sectionName);
	}

	let onSectionChange = () => {};

	function renderSection(sectionName) {
	  const newSection = isValidSection(sectionName) ? sectionName : "title";

	  if (newSection === document.body.dataset.currentSection) {
	    return;
	  }

	  if (document.body.dataset.currentSection) {
	    document.body.dataset.prevSection = document.body.dataset.currentSection;
	  }

	  const resultSectionChange = onSectionChange({
	    nextSection: newSection,
	    currentSection: document.body.dataset.prevSection,
	    vars: nextSectionVars,
	  });

	  if (resultSectionChange !== false) {
	    document.body.dataset.currentSection = newSection;
	  } else {
	    window.history.forward();
	  }
	}

	function goToSection(sectionName, vars = {}) {
	  nextSectionVars = vars;
	  window.location.hash = sectionName;
	}

	function init$3(onSectionChangeCallback) {
	  onSectionChange = onSectionChangeCallback;

	  let sectionSelectors = [];

	  for (let section of document.querySelectorAll("section[id]")) {
	    availableSections.push(section.id);

	    sectionSelectors.push(
	      `body[data-current-section="${section.id}"] section#${section.id}`
	    );
	  }

	  document.head.insertAdjacentHTML(
	    "beforeend",
	    `<style>${sectionSelectors.join(",") + "{display:flex;}"}</style>`
	  );

	  function onHashChange() {
	    renderSection(window.location.hash.substring(1));
	  }

	  window.addEventListener("hashchange", onHashChange);

	  document.body.addEventListener("click", (e) => {
	    if (e.target.tagName.toUpperCase() !== "A") {
	      return;
	    }

	    nextSectionVars = JSON.parse(JSON.stringify(e.target.dataset));
	  });

	  goToSection(window.location.hash === "#rules" ? "rules" : "title");

	  onHashChange();
	}

	var sections = /*#__PURE__*/Object.freeze({
		__proto__: null,
		goToSection: goToSection,
		'default': init$3
	});

	var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(sections);

	function getRandom(x) {
	  return Math.floor(Math.random() * (x + 1));
	}

	function isLucky(percentOfChance) {
	  return getRandom(99) + 1 <= percentOfChance;
	}

	function shuffleArray(array) {
	  const newArray = [...array];

	  for (let i = newArray.length - 1; i > 0; i -= 1) {
	    const j = getRandom(i);
	    const temp = newArray[i];

	    newArray[i] = newArray[j];
	    newArray[j] = temp;
	  }

	  return newArray;
	}

	function capitalize(word) {
	  return word[0].toUpperCase() + word.slice(1);
	}

	const poisonedWrapper = (content, poison) =>
	  poison === 0 ? content : `<span class="poisonnedValue">${content}</span>`;

	class CardDataBase {
	  constructor(id, name, value) {
	    this.id = id;
	    this.name = name;
	    this.value = value;
	  }

	  getDesc(poison = 0) {
	    const value = this.value + poison;
	    return poisonedWrapper(`{P} ${value >= 0 ? "+" : ""}` + value, poison);
	  }

	  applyEffect(putridity, poison) {
	    return putridity + this.value + poison;
	  }
	}

	class CardDataMultipler extends CardDataBase {
	  getDesc(poison = 0) {
	    return poisonedWrapper(`{P} x${this.value + poison}`, poison);
	  }

	  applyEffect(putridity, poison) {
	    return putridity * (this.value + poison);
	  }
	}

	class CardDataDiviser extends CardDataBase {
	  getDesc(poison = 0) {
	    return poisonedWrapper(`{P} /${this.value + poison}`, poison);
	  }

	  applyEffect(putridity, currentPoison) {
	    return Math.floor(putridity / (this.value + currentPoison));
	  }
	}

	const allCardDataBase = [
	  new CardDataBase("worm", "Worm", 1),
	  new CardDataBase("fly", "Fly", 2),
	  new CardDataBase("bat", "Bat", 3),
	  new CardDataBase("spider", "Spider", 4),
	  new CardDataBase("apple", "Apple", -1),
	  new CardDataBase("berry", "Berry", -2),
	  new CardDataDiviser("meat", "Meat", 2),
	  new CardDataMultipler("brain", "Brain", 2),
	];

	function getCardDataById(idToFind) {
	  return allCardDataBase.find(({ id }) => id === idToFind);
	}

	function getRandomCards(winsCount = 1, passives = []) {
	  const [cardId1, cardId2, cardId3] = shuffleArray([
	    winsCount > 4 ? "spider" : "worm",
	    winsCount > 2 ? "fly" : "worm",
	    winsCount > 2 ? "fly" : "worm",
	    winsCount > 4 ? "meat" : "worm",
	    winsCount > 4 ? "brain" : "worm",
	    "fly",
	    "fly",
	    winsCount > 2 ? "apple" : "fly",
	    winsCount > 2 ? "apple" : "fly",
	    "bat",
	    winsCount > 2 ? "spider" : "bat",
	    winsCount > 4 ? "spider" : "bat",
	    winsCount > 2 ? "spider" : "fly",
	    winsCount > 2 ? "spider" : "bat",
	    "apple",
	    "apple",
	    "apple",
	    winsCount > 4 ? "berry" : "apple",
	    winsCount > 4 ? "berry" : "apple",
	    "berry",
	    "berry",
	    "berry",
	    winsCount > 4 ? "meat" : "berry",
	    winsCount > 4 ? "brain" : "bat",
	  ]);

	  return [cardId1, cardId2, cardId3].map((id) => new UniqCard(id, passives));
	}

	let lastUnidCardId = 1;

	class UniqCard {
	  constructor(cardId, passives = []) {
	    this.uniqId = lastUnidCardId++;

	    const cardData = getCardDataById(cardId);

	    this.id = cardId;
	    this.name = cardData.name;
	    this.initialValue = cardData.value;
	    this.value = cardData.value;

	    this.baseCardGetDesc = cardData.getDesc.bind(this);
	    this.baseCardEffect = cardData.applyEffect.bind(this);

	    this.hasActivePassive = false;
	    this.size = "normal";
	    this.status = "none";

	    this.applyPassives(passives);
	  }

	  applyEffect(currentPutridity, currentPoison, applyPoison) {
	    const newPutridity = this.baseCardEffect(currentPutridity, currentPoison);

	    if (this.status === "poisoned") {
	      applyPoison(this.initialValue > 0 ? 1 : -1);
	    } else {
	      applyPoison(0);
	    }

	    return this.status === "safe"
	      ? Math.max(1, Math.min(12, newPutridity))
	      : newPutridity;
	  }

	  getName() {
	    const { size, status, name } = this;
	    const sizeModifier = size !== "normal" ? `${capitalize(size)} ` : "";
	    const statusModifier = status !== "none" ? `${capitalize(status)} ` : "";
	    return sizeModifier + statusModifier + name;
	  }

	  getDesc(poison = 0) {
	    const statusToModifier = {
	      poisoned: ` ► ${this.initialValue > 0 ? "+1" : "-1"}`,
	      safe: ' <span class="subEffect sprite ok"></span>',
	    };

	    return this.baseCardGetDesc(poison) + (statusToModifier[this.status] || "");
	  }

	  applyPassives(passives) {
	    passives
	      .filter(({ ingredientId }) => ingredientId === this.id)
	      .forEach((passive) => {
	        this.hasActivePassive = true;

	        switch (passive.value) {
	          case "poisoned": {
	            this.status = "poisoned";

	            break;
	          }

	          case "expert": {
	            this.status = "safe";

	            break;
	          }

	          default: {
	            const isMini = passive.id.startsWith("i");

	            if (
	              (isMini && this.size === "maxi") ||
	              (!isMini && this.size === "mini")
	            ) {
	              this.size = "normal";
	            } else {
	              this.size = isMini ? "mini" : "maxi";
	            }

	            this.value += passive.value;
	            break;
	          }
	        }
	      });
	  }
	}

	var cards = /*#__PURE__*/Object.freeze({
		__proto__: null,
		allCardDataBase: allCardDataBase,
		getRandomCards: getRandomCards,
		UniqCard: UniqCard
	});

	var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(cards);

	var thirdWebClient = {};

	var thirdweb = {};

	var addresses = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ADDRESS_ZERO = exports.ZERO_ADDRESS = exports.NATIVE_TOKEN_ADDRESS = void 0;
		exports.isNativeTokenAddress = isNativeTokenAddress;
		/**
		 * The address of the native token.
		 */
		exports.NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
		/**
		 * @internal
		 */
		function isNativeTokenAddress(address) {
		    return address.toLowerCase() === exports.NATIVE_TOKEN_ADDRESS;
		}
		/**
		 * The zero address in Ethereum, represented as a hexadecimal string.
		 */
		exports.ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
		/**
		 * @deprecated Use {@link ZERO_ADDRESS}.
		 */
		exports.ADDRESS_ZERO = exports.ZERO_ADDRESS;
		
	} (addresses));

	var client = {};

	var clientId = {};

	var lru$1 = {};

	Object.defineProperty(lru$1, "__esModule", { value: true });
	lru$1.LruMap = void 0;
	/**
	 * Represents a Least Recently Used (LRU) Map.
	 * Extends the built-in Map class.
	 */
	class LruMap$1 extends Map {
	    /**
	     *
	     * @param size
	     * @internal
	     */
	    constructor(size) {
	        super();
	        Object.defineProperty(this, "maxSize", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.maxSize = size;
	    }
	    /**
	     *
	     * @param key
	     * @param value
	     * @internal
	     */
	    set(key, value) {
	        super.set(key, value);
	        if (this.maxSize && this.size > this.maxSize) {
	            this.delete(this.keys().next().value);
	        }
	        return this;
	    }
	}
	lru$1.LruMap = LruMap$1;

	var toBytes$2 = {};

	var textEncoder$1 = {};

	Object.defineProperty(textEncoder$1, "__esModule", { value: true });
	textEncoder$1.cachedTextEncoder = cachedTextEncoder;
	let textEncoder;
	/**
	 * Re-using the same textencoder is faster.
	 *
	 * @returns
	 * @internal
	 */
	function cachedTextEncoder() {
	    if (!textEncoder) {
	        textEncoder = new TextEncoder();
	    }
	    return textEncoder;
	}

	var assertSize$1 = {};

	var byteSize$1 = {};

	var isHex$3 = {};

	Object.defineProperty(isHex$3, "__esModule", { value: true });
	isHex$3.isHex = isHex$2;
	/**
	 * Checks if a value is a valid hexadecimal string.
	 * @param value - The value to be checked.
	 * @param options - Optional configuration for the validation.
	 * @returns True if the value is a valid hexadecimal string, false otherwise.
	 * @example
	 * ```ts
	 * import { isHex } from "thirdweb/utils";
	 * const result = isHex("0x1a4");
	 * console.log(result); // true
	 * ```
	 * @utils
	 */
	function isHex$2(value, options = {}) {
	    if (!value) {
	        return false;
	    }
	    if (typeof value !== "string") {
	        return false;
	    }
	    return options.strict
	        ? /^0x[0-9a-fA-F]*$/.test(value)
	        : value.startsWith("0x");
	}

	Object.defineProperty(byteSize$1, "__esModule", { value: true });
	byteSize$1.byteSize = byteSize;
	const is_hex_js_1$1 = isHex$3;
	/**
	 * Calculates the byte size of a Hex string or Uint8Array.
	 * If the value is a Hex string, it accounts for the leading "0x" prefix.
	 * @param value The Hex string or Uint8Array.
	 * @returns The byte size of the value.
	 * @example
	 * ```ts
	 * import { byteSize } from "thirdweb/utils";
	 * const size = byteSize("0x1a4");
	 * console.log(size); // 2
	 * ```
	 */
	function byteSize(value) {
	    if ((0, is_hex_js_1$1.isHex)(value, { strict: false })) {
	        return Math.ceil((value.length - 2) / 2);
	    }
	    return value.length;
	}

	Object.defineProperty(assertSize$1, "__esModule", { value: true });
	assertSize$1.assertSize = assertSize;
	const byte_size_js_1$1 = byteSize$1;
	/**
	 * Asserts that the size of the given hex or bytes is not greater than the specified size.
	 * @param hexOrBytes - The hex or bytes to check the size of.
	 * @param size - The maximum allowed size.
	 * @throws Error if the size of the hex or bytes is greater than the specified size.
	 * @example
	 * ```ts
	 * import { assertSize } from "thirdweb/utils";
	 * assertSize("0x1a4", { size: 2 });
	 * ```
	 * @internal
	 */
	function assertSize(hexOrBytes, { size }) {
	    const givenSize = (0, byte_size_js_1$1.byteSize)(hexOrBytes);
	    if (givenSize > size) {
	        throw new Error(`Size overflow: ${givenSize} > ${size}`);
	    }
	}

	var charcodeToBase16 = {};

	Object.defineProperty(charcodeToBase16, "__esModule", { value: true });
	charcodeToBase16.charCodeToBase16 = charCodeToBase16;
	const charCodeMap = {
	    zero: 48,
	    nine: 57,
	    A: 65,
	    F: 70,
	    a: 97,
	    f: 102,
	};
	/**
	 * @internal
	 */
	function charCodeToBase16(char) {
	    if (char >= charCodeMap.zero && char <= charCodeMap.nine) {
	        return char - charCodeMap.zero;
	    }
	    if (char >= charCodeMap.A && char <= charCodeMap.F) {
	        return char - (charCodeMap.A - 10);
	    }
	    if (char >= charCodeMap.a && char <= charCodeMap.f) {
	        return char - (charCodeMap.a - 10);
	    }
	    return undefined;
	}

	var hex = {};

	var textDecoder$1 = {};

	Object.defineProperty(textDecoder$1, "__esModule", { value: true });
	textDecoder$1.cachedTextDecoder = cachedTextDecoder;
	let textDecoder;
	/**
	 * Re-using the same textdecoder is faster.
	 *
	 * @returns
	 * @internal
	 */
	function cachedTextDecoder() {
	    if (!textDecoder) {
	        textDecoder = new TextDecoder();
	    }
	    return textDecoder;
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isHex = void 0;
		exports.padHex = padHex;
		exports.hexToString = hexToString;
		exports.hexToBigInt = hexToBigInt;
		exports.hexToNumber = hexToNumber;
		exports.hexToBool = hexToBool;
		exports.hexToUint8Array = hexToUint8Array;
		exports.fromHex = fromHex;
		exports.boolToHex = boolToHex;
		exports.uint8ArrayToHex = uint8ArrayToHex;
		exports.numberToHex = numberToHex;
		exports.stringToHex = stringToHex;
		exports.toHex = toHex;
		const text_decoder_js_1 = textDecoder$1;
		const text_encoder_js_1 = textEncoder$1;
		// slightly tweaked re-exports from viem for the moment
		const assert_size_js_1 = assertSize$1;
		const charcode_to_base_16_js_1 = charcodeToBase16;
		var is_hex_js_1 = isHex$3;
		Object.defineProperty(exports, "isHex", { enumerable: true, get: function () { return is_hex_js_1.isHex; } });
		function trim(hexOrBytes, options = {}) {
		    const dir = options.dir || "left";
		    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
		    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
		    let sliceLength = 0;
		    for (let i = 0; i < data.length - 1; i++) {
		        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") {
		            sliceLength++;
		        }
		        else {
		            break;
		        }
		    }
		    data =
		        dir === "left"
		            ? data.slice(sliceLength)
		            : data.slice(0, data.length - sliceLength);
		    if (typeof hexOrBytes === "string") {
		        if (data.length === 1 && dir === "right") {
		            data = `${data}0`;
		        }
		        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
		    }
		    return data;
		}
		/**
		 * Pads a hexadecimal string with zeros to a specified size.
		 * @param hex_ The hexadecimal string to pad.
		 * @param options The padding options.
		 * @returns The padded hexadecimal string.
		 * @throws Error if the resulting padded string exceeds the specified size.
		 * @example
		 * ```ts
		 * import { padHex } from "thirdweb/utils";
		 * const paddedHex = padHex("0x1a4", { size: 32 });
		 * console.log(paddedHex); // "0x000000000000000000000000000001a4"
		 * ```
		 * @utils
		 */
		function padHex(hex_, options = {}) {
		    const { dir, size = 32 } = options;
		    if (size === null) {
		        return hex_;
		    }
		    const hex = hex_.replace("0x", "");
		    if (hex.length > size * 2) {
		        throw new Error(`Size overflow: ${Math.ceil(hex.length / 2)} > ${size}`);
		    }
		    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
		}
		/**
		 * Converts a hexadecimal string to a UTF-8 string.
		 * @param hex The hexadecimal string to convert.
		 * @param opts The options for the conversion.
		 * @returns The UTF-8 string representation of the hexadecimal string.
		 * @example
		 * ```ts
		 * import { hexToString } from "thirdweb/utils";
		 * const string = hexToString("0x48656c6c6f2c20776f726c6421");
		 * console.log(string); // "Hello, world!"
		 * ```
		 * @utils
		 */
		function hexToString(hex, opts = {}) {
		    let bytes = hexToUint8Array(hex);
		    if (opts.size) {
		        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
		        bytes = trim(bytes, { dir: "right" });
		    }
		    return (0, text_decoder_js_1.cachedTextDecoder)().decode(bytes);
		}
		/**
		 * Converts a hexadecimal string to a BigInt.
		 * @param hex - The hexadecimal string to convert.
		 * @param opts - Optional parameters for the conversion.
		 * @returns The BigInt representation of the hexadecimal string.
		 * @example
		 * ```ts
		 * import { hexToBigInt } from "thirdweb/utils";
		 * const bigInt = hexToBigInt("0x1a4");
		 * console.log(bigInt); // 420n
		 * ```
		 * @utils
		 */
		function hexToBigInt(hex, opts = {}) {
		    const { signed } = opts;
		    if (opts.size) {
		        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
		    }
		    const value = BigInt(hex);
		    if (!signed) {
		        return value;
		    }
		    const size = (hex.length - 2) / 2;
		    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
		    if (value <= max) {
		        return value;
		    }
		    return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
		}
		/**
		 * Converts a hexadecimal string to a number.
		 * @param hex The hexadecimal string to convert.
		 * @param opts Optional options for the conversion.
		 * @returns The converted number.
		 * @example
		 * ```ts
		 * import { hexToNumber } from "thirdweb/utils";
		 * const number = hexToNumber("0x1a4");
		 * console.log(number); // 420
		 * ```
		 * @utils
		 */
		function hexToNumber(hex, opts = {}) {
		    return Number(hexToBigInt(hex, opts));
		}
		/**
		 * Converts a hexadecimal string to a boolean value.
		 * @param hex The hexadecimal string to convert.
		 * @param opts Optional options for the conversion.
		 * @returns The boolean value corresponding to the hexadecimal string.
		 * @throws Error if the hexadecimal string is invalid.
		 * @example
		 * ```ts
		 * import { hexToBool } from "thirdweb/utils";
		 * const bool = hexToBool("0x01");
		 * console.log(bool); // true
		 * ```
		 * @utils
		 */
		function hexToBool(hex, opts = {}) {
		    if (opts.size) {
		        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
		        // biome-ignore lint/style/noParameterAssign: for perf
		        hex = trim(hex);
		    }
		    if (trim(hex) === "0x00") {
		        return false;
		    }
		    if (trim(hex) === "0x01") {
		        return true;
		    }
		    throw new Error(`Invalid hex boolean: ${hex}`);
		}
		/**
		 * Converts a hexadecimal string to a Uint8Array.
		 * @param hex The hexadecimal string to convert.
		 * @param opts Options for the conversion.
		 * @returns The Uint8Array representation of the hexadecimal string.
		 * @example
		 * ```ts
		 * import { hexToUint8Array } from "thirdweb/utils";
		 * const bytes = hexToUint8Array("0x48656c6c6f2c20776f726c6421");
		 * console.log(bytes); // Uint8Array([72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33])
		 * ```
		 * @utils
		 */
		function hexToUint8Array(hex, opts = {}) {
		    if (opts.size) {
		        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
		        // biome-ignore lint/style/noParameterAssign: for perf
		        hex = padHex(hex, { dir: "right", size: opts.size });
		    }
		    let hexString = hex.slice(2);
		    if (hexString.length % 2) {
		        hexString = `0${hexString}`;
		    }
		    const length = hexString.length / 2;
		    const bytes = new Uint8Array(length);
		    for (let index = 0, j = 0; index < length; index++) {
		        const nibbleLeft = (0, charcode_to_base_16_js_1.charCodeToBase16)(hexString.charCodeAt(j++));
		        const nibbleRight = (0, charcode_to_base_16_js_1.charCodeToBase16)(hexString.charCodeAt(j++));
		        if (nibbleLeft === undefined || nibbleRight === undefined) {
		            throw new Error(`Invalid hex character: ${hexString}`);
		        }
		        bytes[index] = nibbleLeft * 16 + nibbleRight;
		    }
		    return bytes;
		}
		/**
		 * Converts a hexadecimal string to the specified type.
		 * @param hex - The hexadecimal string to convert.
		 * @param toOrOpts - The target type or conversion options.
		 * @returns The converted value of the specified type.
		 * @example
		 * ```ts
		 * import { fromHex } from "thirdweb/utils";
		 * const string = fromHex("0x48656c6c6f2c20776f726c6421", "string");
		 * console.log(string); // "Hello, world!"
		 * ```
		 * @utils
		 */
		function fromHex(hex, toOrOpts) {
		    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
		    switch (opts.to) {
		        case "number":
		            return hexToNumber(hex, opts);
		        case "bigint":
		            return hexToBigInt(hex, opts);
		        case "string":
		            return hexToString(hex, opts);
		        case "boolean":
		            return hexToBool(hex, opts);
		        default:
		            return hexToUint8Array(hex, opts);
		    }
		}
		//--------------------------------------------------------------------------
		// TO HEX
		//--------------------------------------------------------------------------
		const hexes = /* @__PURE__ */ (() => Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0")))();
		/**
		 * Converts a boolean value to a hexadecimal string representation.
		 * @param value - The boolean value to convert.
		 * @param opts - Optional options for the conversion.
		 * @returns The hexadecimal string representation of the boolean value.
		 * @example
		 * ```ts
		 * import { boolToHex } from "thirdweb/utils";
		 * const hex = boolToHex(true);
		 * console.log(hex); // "0x01"
		 * ```
		 * @utils
		 */
		function boolToHex(value, opts = {}) {
		    const hex = `0x${Number(value)}`;
		    if (typeof opts.size === "number") {
		        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
		        return padHex(hex, { size: opts.size });
		    }
		    return hex;
		}
		/**
		 * Converts an array of bytes to a hexadecimal string.
		 * @param value - The array of bytes to convert.
		 * @param opts - Optional parameters for the conversion.
		 * @returns The hexadecimal string representation of the bytes.
		 * @example
		 * ```ts
		 * import { uint8arrayToHex } from "thirdweb/utils";
		 * const hex = uint8arrayToHex(new Uint8Array([72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100]));
		 * console.log(hex); // "0x48656c6c6f2c20776f726c64"
		 * ```
		 * @utils
		 */
		function uint8ArrayToHex(value, opts = {}) {
		    let string = "";
		    for (let i = 0; i < value.length; i++) {
		        // biome-ignore lint/style/noNonNullAssertion: we know this is defined
		        string += hexes[value[i]];
		    }
		    const hex = `0x${string}`;
		    if (typeof opts.size === "number") {
		        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
		        return padHex(hex, { dir: "right", size: opts.size });
		    }
		    return hex;
		}
		/**
		 * Converts a number or bigint to a hexadecimal string.
		 * @param value_ - The number or bigint value to convert.
		 * @param opts - Optional configuration options.
		 * @returns The hexadecimal representation of the input value.
		 * @throws An error if the input value is not within the safe integer range.
		 * @example
		 * ```ts
		 * import { numberToHex } from "thirdweb/utils";
		 * const hex = numberToHex(420);
		 * console.log(hex); // "0x1a4"
		 * ```
		 * @utils
		 */
		function numberToHex(value_, opts = {}) {
		    const { signed, size } = opts;
		    const value = BigInt(value_);
		    let maxValue;
		    if (size) {
		        if (signed) {
		            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
		        }
		        else {
		            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
		        }
		    }
		    else if (typeof value_ === "number") {
		        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
		    }
		    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
		    if ((maxValue && value > maxValue) || value < minValue) {
		        const suffix = typeof value_ === "bigint" ? "n" : "";
		        throw new Error(`Number "${value_}${suffix}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${maxValue ? `(${minValue} to ${maxValue})` : `(above ${minValue})`}`);
		    }
		    const hex = `0x${(signed && value < 0
	        ? (1n << BigInt(size * 8)) + BigInt(value)
	        : value).toString(16)}`;
		    if (size) {
		        return padHex(hex, { size });
		    }
		    return hex;
		}
		/**
		 * Converts a string to its hexadecimal representation.
		 * @param value_ The string to convert to hexadecimal.
		 * @param opts Options for the conversion.
		 * @returns The hexadecimal representation of the input string.
		 * @example
		 * ```ts
		 * import { stringToHex } from "thirdweb/utils";
		 * const hex = stringToHex("Hello, world!");
		 * console.log(hex); // "0x48656c6c6f2c20776f726c6421"
		 * ```
		 * @utils
		 */
		function stringToHex(value_, opts = {}) {
		    const value = (0, text_encoder_js_1.cachedTextEncoder)().encode(value_);
		    return uint8ArrayToHex(value, opts);
		}
		/**
		 * Converts a value to its hexadecimal representation.
		 * @param value - The value to convert to hexadecimal.
		 * @param opts - Optional parameters for the conversion.
		 * @returns The hexadecimal representation of the value.
		 * @example
		 * ```ts
		 * import { toHex } from "thirdweb/utils";
		 * const hex = toHex(420);
		 * console.log(hex); // "0x1a4"
		 * ```
		 * @utils
		 */
		function toHex(value, opts = {}) {
		    switch (typeof value) {
		        case "number":
		        case "bigint":
		            return numberToHex(value, opts);
		        case "string":
		            return stringToHex(value, opts);
		        case "boolean":
		            return boolToHex(value, opts);
		        default:
		            return uint8ArrayToHex(value, opts);
		    }
		}
		
	} (hex));

	Object.defineProperty(toBytes$2, "__esModule", { value: true });
	toBytes$2.toBytes = toBytes$1;
	toBytes$2.boolToBytes = boolToBytes;
	toBytes$2.hexToBytes = hexToBytes$1;
	toBytes$2.numberToBytes = numberToBytes;
	toBytes$2.stringToBytes = stringToBytes;
	const text_encoder_js_1 = textEncoder$1;
	const assert_size_js_1$1 = assertSize$1;
	const charcode_to_base_16_js_1 = charcodeToBase16;
	const is_hex_js_1 = isHex$3;
	const hex_js_1$g = hex;
	function padBytes$1(bytes, { dir, size = 32 } = {}) {
	    if (size === null) {
	        return bytes;
	    }
	    if (bytes.length > size) {
	        throw new Error(`Size overflow: ${bytes.length} > ${size}`);
	    }
	    const paddedBytes = new Uint8Array(size);
	    for (let i = 0; i < size; i++) {
	        const padEnd = dir === "right";
	        paddedBytes[padEnd ? i : size - i - 1] =
	            // biome-ignore lint/style/noNonNullAssertion: we know its there
	            bytes[padEnd ? i : bytes.length - i - 1];
	    }
	    return paddedBytes;
	}
	/**
	 * Converts a value to an array of bytes.
	 * @param value - The value to convert.
	 * @param opts - Optional parameters for the conversion.
	 * @returns The array of bytes representing the value.
	 * @example
	 * ```ts
	 * import { toBytes } from "thirdweb/utils";
	 * const bytes = toBytes("0x1a4");
	 * console.log(bytes); // Uint8Array(2) [ 1, 164 ]
	 * ```
	 * @utils
	 */
	function toBytes$1(value, opts = {}) {
	    switch (typeof value) {
	        case "number":
	        case "bigint":
	            return numberToBytes(value, opts);
	        case "boolean":
	            return boolToBytes(value, opts);
	        default:
	            if ((0, is_hex_js_1.isHex)(value)) {
	                return hexToBytes$1(value, opts);
	            }
	            return stringToBytes(value, opts);
	    }
	}
	/**
	 * Converts a boolean value to a Uint8Array of bytes.
	 * @param value - The boolean value to convert.
	 * @param opts - Optional parameters for the conversion.
	 * @returns The Uint8Array of bytes representing the boolean value.
	 * @example
	 * ```ts
	 * import { boolToBytes } from "thirdweb/utils";
	 * const bytes = boolToBytes(true);
	 * console.log(bytes); // Uint8Array(1) [ 1 ]
	 * ```
	 * @utils
	 */
	function boolToBytes(value, opts = {}) {
	    const bytes = new Uint8Array(1);
	    bytes[0] = Number(value);
	    if (typeof opts.size === "number") {
	        (0, assert_size_js_1$1.assertSize)(bytes, { size: opts.size });
	        return padBytes$1(bytes, { size: opts.size });
	    }
	    return bytes;
	}
	/**
	 * Converts a hexadecimal string to a Uint8Array of bytes.
	 * @param hex_ The hexadecimal string to convert.
	 * @param opts Options for converting the hexadecimal string.
	 * @returns The Uint8Array of bytes.
	 * @throws Error if the byte sequence is invalid.
	 * @example
	 * ```ts
	 * import { hexToBytes } from "thirdweb/utils";
	 * const bytes = hexToBytes("0x1a4");
	 * console.log(bytes); // Uint8Array(2) [ 1, 164 ]
	 * ```
	 * @utils
	 */
	function hexToBytes$1(hex_, opts = {}) {
	    let hex = hex_;
	    if (opts.size) {
	        (0, assert_size_js_1$1.assertSize)(hex, { size: opts.size });
	        hex = (0, hex_js_1$g.padHex)(hex, { dir: "right", size: opts.size });
	    }
	    let hexString = hex.slice(2);
	    if (hexString.length % 2) {
	        hexString = `0${hexString}`;
	    }
	    const length = hexString.length / 2;
	    const bytes = new Uint8Array(length);
	    for (let index = 0, j = 0; index < length; index++) {
	        const nibbleLeft = (0, charcode_to_base_16_js_1.charCodeToBase16)(hexString.charCodeAt(j++));
	        const nibbleRight = (0, charcode_to_base_16_js_1.charCodeToBase16)(hexString.charCodeAt(j++));
	        if (nibbleLeft === undefined || nibbleRight === undefined) {
	            throw new Error(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
	        }
	        bytes[index] = nibbleLeft * 16 + nibbleRight;
	    }
	    return bytes;
	}
	/**
	 * Converts a number to bytes.
	 * @param value - The number to convert.
	 * @param opts - Options for converting the number to hex.
	 * @returns The bytes representation of the number.
	 * @example
	 * ```ts
	 * import { numberToBytes } from "thirdweb/utils";
	 * const bytes = numberToBytes(420);
	 * console.log(bytes); // Uint8Array(2) [ 1, 164 ]
	 * ```
	 * @utils
	 */
	function numberToBytes(value, opts) {
	    const hex = (0, hex_js_1$g.numberToHex)(value, opts);
	    return hexToBytes$1(hex);
	}
	/**
	 * Converts a string to an array of bytes.
	 * @param value - The string to convert.
	 * @param opts - Optional parameters for the conversion.
	 * @returns The array of bytes representing the string.
	 * @example
	 * ```ts
	 * import { stringToBytes } from "thirdweb/utils";
	 * const bytes = stringToBytes("Hello, world!");
	 * console.log(bytes); // Uint8Array(13) [ 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33 ]
	 * ```
	 * @utils
	 */
	function stringToBytes(value, opts = {}) {
	    const bytes = (0, text_encoder_js_1.cachedTextEncoder)().encode(value);
	    if (typeof opts.size === "number") {
	        (0, assert_size_js_1$1.assertSize)(bytes, { size: opts.size });
	        return padBytes$1(bytes, { dir: "right", size: opts.size });
	    }
	    return bytes;
	}

	var sha256$4 = {};

	var sha256$3 = {};

	var _md = {};

	var _assert = {};

	Object.defineProperty(_assert, "__esModule", { value: true });
	_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = _assert.isBytes = void 0;
	function number$1(n) {
	    if (!Number.isSafeInteger(n) || n < 0)
	        throw new Error(`positive integer expected, not ${n}`);
	}
	_assert.number = number$1;
	function bool(b) {
	    if (typeof b !== 'boolean')
	        throw new Error(`boolean expected, not ${b}`);
	}
	_assert.bool = bool;
	// copied from utils
	function isBytes$3(a) {
	    return (a instanceof Uint8Array ||
	        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
	}
	_assert.isBytes = isBytes$3;
	function bytes$1(b, ...lengths) {
	    if (!isBytes$3(b))
	        throw new Error('Uint8Array expected');
	    if (lengths.length > 0 && !lengths.includes(b.length))
	        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
	}
	_assert.bytes = bytes$1;
	function hash$1(h) {
	    if (typeof h !== 'function' || typeof h.create !== 'function')
	        throw new Error('Hash should be wrapped by utils.wrapConstructor');
	    number$1(h.outputLen);
	    number$1(h.blockLen);
	}
	_assert.hash = hash$1;
	function exists(instance, checkFinished = true) {
	    if (instance.destroyed)
	        throw new Error('Hash instance has been destroyed');
	    if (checkFinished && instance.finished)
	        throw new Error('Hash#digest() has already been called');
	}
	_assert.exists = exists;
	function output(out, instance) {
	    bytes$1(out);
	    const min = instance.outputLen;
	    if (out.length < min) {
	        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
	    }
	}
	_assert.output = output;
	const assert = { number: number$1, bool, bytes: bytes$1, hash: hash$1, exists, output };
	_assert.default = assert;

	var utils$8 = {};

	var crypto$1 = {};

	Object.defineProperty(crypto$1, "__esModule", { value: true });
	crypto$1.crypto = void 0;
	crypto$1.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

	(function (exports) {
		/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
		// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
		// node.js versions earlier than v19 don't declare it in global scope.
		// For node.js, package.json#exports field mapping rewrites import
		// from `crypto` to `cryptoNode`, which imports native module.
		// Makes the utils un-importable in browsers without a bundler.
		// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
		const crypto_1 = crypto$1;
		const _assert_js_1 = _assert;
		// export { isBytes } from './_assert.js';
		// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
		function isBytes(a) {
		    return (a instanceof Uint8Array ||
		        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
		}
		exports.isBytes = isBytes;
		// Cast array to different type
		const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
		exports.u8 = u8;
		const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
		exports.u32 = u32;
		// Cast array to view
		const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
		exports.createView = createView;
		// The rotate right (circular right shift) operation for uint32
		const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
		exports.rotr = rotr;
		// The rotate left (circular left shift) operation for uint32
		const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
		exports.rotl = rotl;
		exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
		// The byte swap operation for uint32
		const byteSwap = (word) => ((word << 24) & 0xff000000) |
		    ((word << 8) & 0xff0000) |
		    ((word >>> 8) & 0xff00) |
		    ((word >>> 24) & 0xff);
		exports.byteSwap = byteSwap;
		// Conditionally byte swap if on a big-endian platform
		exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
		// In place byte swap for Uint32Array
		function byteSwap32(arr) {
		    for (let i = 0; i < arr.length; i++) {
		        arr[i] = (0, exports.byteSwap)(arr[i]);
		    }
		}
		exports.byteSwap32 = byteSwap32;
		// Array where index 0xf0 (240) is mapped to string 'f0'
		const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
		/**
		 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
		 */
		function bytesToHex(bytes) {
		    (0, _assert_js_1.bytes)(bytes);
		    // pre-caching improves the speed 6x
		    let hex = '';
		    for (let i = 0; i < bytes.length; i++) {
		        hex += hexes[bytes[i]];
		    }
		    return hex;
		}
		exports.bytesToHex = bytesToHex;
		// We use optimized technique to convert hex string to byte array
		const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
		function asciiToBase16(char) {
		    if (char >= asciis._0 && char <= asciis._9)
		        return char - asciis._0;
		    if (char >= asciis._A && char <= asciis._F)
		        return char - (asciis._A - 10);
		    if (char >= asciis._a && char <= asciis._f)
		        return char - (asciis._a - 10);
		    return;
		}
		/**
		 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
		 */
		function hexToBytes(hex) {
		    if (typeof hex !== 'string')
		        throw new Error('hex string expected, got ' + typeof hex);
		    const hl = hex.length;
		    const al = hl / 2;
		    if (hl % 2)
		        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
		    const array = new Uint8Array(al);
		    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
		        const n1 = asciiToBase16(hex.charCodeAt(hi));
		        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
		        if (n1 === undefined || n2 === undefined) {
		            const char = hex[hi] + hex[hi + 1];
		            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
		        }
		        array[ai] = n1 * 16 + n2;
		    }
		    return array;
		}
		exports.hexToBytes = hexToBytes;
		// There is no setImmediate in browser and setTimeout is slow.
		// call of async fn will return Promise, which will be fullfiled only on
		// next scheduler queue processing step and this is exactly what we need.
		const nextTick = async () => { };
		exports.nextTick = nextTick;
		// Returns control to thread each 'tick' ms to avoid blocking
		async function asyncLoop(iters, tick, cb) {
		    let ts = Date.now();
		    for (let i = 0; i < iters; i++) {
		        cb(i);
		        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
		        const diff = Date.now() - ts;
		        if (diff >= 0 && diff < tick)
		            continue;
		        await (0, exports.nextTick)();
		        ts += diff;
		    }
		}
		exports.asyncLoop = asyncLoop;
		/**
		 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
		 */
		function utf8ToBytes(str) {
		    if (typeof str !== 'string')
		        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
		    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
		}
		exports.utf8ToBytes = utf8ToBytes;
		/**
		 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
		 * Warning: when Uint8Array is passed, it would NOT get copied.
		 * Keep in mind for future mutable operations.
		 */
		function toBytes(data) {
		    if (typeof data === 'string')
		        data = utf8ToBytes(data);
		    (0, _assert_js_1.bytes)(data);
		    return data;
		}
		exports.toBytes = toBytes;
		/**
		 * Copies several Uint8Arrays into one.
		 */
		function concatBytes(...arrays) {
		    let sum = 0;
		    for (let i = 0; i < arrays.length; i++) {
		        const a = arrays[i];
		        (0, _assert_js_1.bytes)(a);
		        sum += a.length;
		    }
		    const res = new Uint8Array(sum);
		    for (let i = 0, pad = 0; i < arrays.length; i++) {
		        const a = arrays[i];
		        res.set(a, pad);
		        pad += a.length;
		    }
		    return res;
		}
		exports.concatBytes = concatBytes;
		// For runtime check if class implements interface
		class Hash {
		    // Safe version that clones internal state
		    clone() {
		        return this._cloneInto();
		    }
		}
		exports.Hash = Hash;
		const toStr = {}.toString;
		function checkOpts(defaults, opts) {
		    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
		        throw new Error('Options should be object or undefined');
		    const merged = Object.assign(defaults, opts);
		    return merged;
		}
		exports.checkOpts = checkOpts;
		function wrapConstructor(hashCons) {
		    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
		    const tmp = hashCons();
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = () => hashCons();
		    return hashC;
		}
		exports.wrapConstructor = wrapConstructor;
		function wrapConstructorWithOpts(hashCons) {
		    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
		    const tmp = hashCons({});
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = (opts) => hashCons(opts);
		    return hashC;
		}
		exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
		function wrapXOFConstructorWithOpts(hashCons) {
		    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
		    const tmp = hashCons({});
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = (opts) => hashCons(opts);
		    return hashC;
		}
		exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
		/**
		 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
		 */
		function randomBytes(bytesLength = 32) {
		    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
		        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
		    }
		    throw new Error('crypto.getRandomValues must be defined');
		}
		exports.randomBytes = randomBytes;
		
	} (utils$8));

	Object.defineProperty(_md, "__esModule", { value: true });
	_md.HashMD = _md.Maj = _md.Chi = void 0;
	const _assert_js_1$1 = _assert;
	const utils_js_1$s = utils$8;
	// Polyfill for Safari 14
	function setBigUint64(view, byteOffset, value, isLE) {
	    if (typeof view.setBigUint64 === 'function')
	        return view.setBigUint64(byteOffset, value, isLE);
	    const _32n = BigInt(32);
	    const _u32_max = BigInt(0xffffffff);
	    const wh = Number((value >> _32n) & _u32_max);
	    const wl = Number(value & _u32_max);
	    const h = isLE ? 4 : 0;
	    const l = isLE ? 0 : 4;
	    view.setUint32(byteOffset + h, wh, isLE);
	    view.setUint32(byteOffset + l, wl, isLE);
	}
	// Choice: a ? b : c
	const Chi = (a, b, c) => (a & b) ^ (~a & c);
	_md.Chi = Chi;
	// Majority function, true if any two inpust is true
	const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
	_md.Maj = Maj;
	/**
	 * Merkle-Damgard hash construction base class.
	 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
	 */
	class HashMD extends utils_js_1$s.Hash {
	    constructor(blockLen, outputLen, padOffset, isLE) {
	        super();
	        this.blockLen = blockLen;
	        this.outputLen = outputLen;
	        this.padOffset = padOffset;
	        this.isLE = isLE;
	        this.finished = false;
	        this.length = 0;
	        this.pos = 0;
	        this.destroyed = false;
	        this.buffer = new Uint8Array(blockLen);
	        this.view = (0, utils_js_1$s.createView)(this.buffer);
	    }
	    update(data) {
	        (0, _assert_js_1$1.exists)(this);
	        const { view, buffer, blockLen } = this;
	        data = (0, utils_js_1$s.toBytes)(data);
	        const len = data.length;
	        for (let pos = 0; pos < len;) {
	            const take = Math.min(blockLen - this.pos, len - pos);
	            // Fast path: we have at least one block in input, cast it to view and process
	            if (take === blockLen) {
	                const dataView = (0, utils_js_1$s.createView)(data);
	                for (; blockLen <= len - pos; pos += blockLen)
	                    this.process(dataView, pos);
	                continue;
	            }
	            buffer.set(data.subarray(pos, pos + take), this.pos);
	            this.pos += take;
	            pos += take;
	            if (this.pos === blockLen) {
	                this.process(view, 0);
	                this.pos = 0;
	            }
	        }
	        this.length += data.length;
	        this.roundClean();
	        return this;
	    }
	    digestInto(out) {
	        (0, _assert_js_1$1.exists)(this);
	        (0, _assert_js_1$1.output)(out, this);
	        this.finished = true;
	        // Padding
	        // We can avoid allocation of buffer for padding completely if it
	        // was previously not allocated here. But it won't change performance.
	        const { buffer, view, blockLen, isLE } = this;
	        let { pos } = this;
	        // append the bit '1' to the message
	        buffer[pos++] = 0b10000000;
	        this.buffer.subarray(pos).fill(0);
	        // we have less than padOffset left in buffer, so we cannot put length in
	        // current block, need process it and pad again
	        if (this.padOffset > blockLen - pos) {
	            this.process(view, 0);
	            pos = 0;
	        }
	        // Pad until full block byte with zeros
	        for (let i = pos; i < blockLen; i++)
	            buffer[i] = 0;
	        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
	        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
	        // So we just write lowest 64 bits of that value.
	        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
	        this.process(view, 0);
	        const oview = (0, utils_js_1$s.createView)(out);
	        const len = this.outputLen;
	        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
	        if (len % 4)
	            throw new Error('_sha2: outputLen should be aligned to 32bit');
	        const outLen = len / 4;
	        const state = this.get();
	        if (outLen > state.length)
	            throw new Error('_sha2: outputLen bigger than state');
	        for (let i = 0; i < outLen; i++)
	            oview.setUint32(4 * i, state[i], isLE);
	    }
	    digest() {
	        const { buffer, outputLen } = this;
	        this.digestInto(buffer);
	        const res = buffer.slice(0, outputLen);
	        this.destroy();
	        return res;
	    }
	    _cloneInto(to) {
	        to || (to = new this.constructor());
	        to.set(...this.get());
	        const { blockLen, buffer, length, finished, destroyed, pos } = this;
	        to.length = length;
	        to.pos = pos;
	        to.finished = finished;
	        to.destroyed = destroyed;
	        if (length % blockLen)
	            to.buffer.set(buffer);
	        return to;
	    }
	}
	_md.HashMD = HashMD;

	Object.defineProperty(sha256$3, "__esModule", { value: true });
	sha256$3.sha224 = sha256$3.sha256 = void 0;
	const _md_js_1$1 = _md;
	const utils_js_1$r = utils$8;
	// SHA2-256 need to try 2^128 hashes to execute birthday attack.
	// BTC network is doing 2^67 hashes/sec as per early 2023.
	// Round constants:
	// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
	// prettier-ignore
	const SHA256_K = /* @__PURE__ */ new Uint32Array([
	    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	]);
	// Initial state:
	// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
	// prettier-ignore
	const SHA256_IV = /* @__PURE__ */ new Uint32Array([
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	]);
	// Temporary buffer, not used to store anything between runs
	// Named this way because it matches specification.
	const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
	class SHA256 extends _md_js_1$1.HashMD {
	    constructor() {
	        super(64, 32, 8, false);
	        // We cannot use array here since array allows indexing by variable
	        // which means optimizer/compiler cannot use registers.
	        this.A = SHA256_IV[0] | 0;
	        this.B = SHA256_IV[1] | 0;
	        this.C = SHA256_IV[2] | 0;
	        this.D = SHA256_IV[3] | 0;
	        this.E = SHA256_IV[4] | 0;
	        this.F = SHA256_IV[5] | 0;
	        this.G = SHA256_IV[6] | 0;
	        this.H = SHA256_IV[7] | 0;
	    }
	    get() {
	        const { A, B, C, D, E, F, G, H } = this;
	        return [A, B, C, D, E, F, G, H];
	    }
	    // prettier-ignore
	    set(A, B, C, D, E, F, G, H) {
	        this.A = A | 0;
	        this.B = B | 0;
	        this.C = C | 0;
	        this.D = D | 0;
	        this.E = E | 0;
	        this.F = F | 0;
	        this.G = G | 0;
	        this.H = H | 0;
	    }
	    process(view, offset) {
	        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
	        for (let i = 0; i < 16; i++, offset += 4)
	            SHA256_W[i] = view.getUint32(offset, false);
	        for (let i = 16; i < 64; i++) {
	            const W15 = SHA256_W[i - 15];
	            const W2 = SHA256_W[i - 2];
	            const s0 = (0, utils_js_1$r.rotr)(W15, 7) ^ (0, utils_js_1$r.rotr)(W15, 18) ^ (W15 >>> 3);
	            const s1 = (0, utils_js_1$r.rotr)(W2, 17) ^ (0, utils_js_1$r.rotr)(W2, 19) ^ (W2 >>> 10);
	            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
	        }
	        // Compression function main loop, 64 rounds
	        let { A, B, C, D, E, F, G, H } = this;
	        for (let i = 0; i < 64; i++) {
	            const sigma1 = (0, utils_js_1$r.rotr)(E, 6) ^ (0, utils_js_1$r.rotr)(E, 11) ^ (0, utils_js_1$r.rotr)(E, 25);
	            const T1 = (H + sigma1 + (0, _md_js_1$1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
	            const sigma0 = (0, utils_js_1$r.rotr)(A, 2) ^ (0, utils_js_1$r.rotr)(A, 13) ^ (0, utils_js_1$r.rotr)(A, 22);
	            const T2 = (sigma0 + (0, _md_js_1$1.Maj)(A, B, C)) | 0;
	            H = G;
	            G = F;
	            F = E;
	            E = (D + T1) | 0;
	            D = C;
	            C = B;
	            B = A;
	            A = (T1 + T2) | 0;
	        }
	        // Add the compressed chunk to the current hash value
	        A = (A + this.A) | 0;
	        B = (B + this.B) | 0;
	        C = (C + this.C) | 0;
	        D = (D + this.D) | 0;
	        E = (E + this.E) | 0;
	        F = (F + this.F) | 0;
	        G = (G + this.G) | 0;
	        H = (H + this.H) | 0;
	        this.set(A, B, C, D, E, F, G, H);
	    }
	    roundClean() {
	        SHA256_W.fill(0);
	    }
	    destroy() {
	        this.set(0, 0, 0, 0, 0, 0, 0, 0);
	        this.buffer.fill(0);
	    }
	}
	// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
	class SHA224 extends SHA256 {
	    constructor() {
	        super();
	        this.A = 0xc1059ed8 | 0;
	        this.B = 0x367cd507 | 0;
	        this.C = 0x3070dd17 | 0;
	        this.D = 0xf70e5939 | 0;
	        this.E = 0xffc00b31 | 0;
	        this.F = 0x68581511 | 0;
	        this.G = 0x64f98fa7 | 0;
	        this.H = 0xbefa4fa4 | 0;
	        this.outputLen = 28;
	    }
	}
	/**
	 * SHA2-256 hash function
	 * @param message - data that would be hashed
	 */
	sha256$3.sha256 = (0, utils_js_1$r.wrapConstructor)(() => new SHA256());
	sha256$3.sha224 = (0, utils_js_1$r.wrapConstructor)(() => new SHA224());

	Object.defineProperty(sha256$4, "__esModule", { value: true });
	sha256$4.sha256 = sha256$2;
	const sha256_1$1 = sha256$3;
	const hex_js_1$f = hex;
	/**
	 * Calculates the SHA256 hash of the given value.
	 * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.
	 * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.
	 * @returns The SHA256 hash of the value in the specified format.
	 * @example
	 * ```ts
	 * import { sha256 } from "thirdweb/utils";
	 * const hash = sha256("0x1234");
	 * ```
	 * @utils
	 */
	function sha256$2(value, to) {
	    const bytes = (0, sha256_1$1.sha256)((0, hex_js_1$f.isHex)(value, { strict: false }) ? (0, hex_js_1$f.hexToUint8Array)(value) : value);
	    if (to === "bytes") {
	        return bytes;
	    }
	    return (0, hex_js_1$f.uint8ArrayToHex)(bytes);
	}

	Object.defineProperty(clientId, "__esModule", { value: true });
	clientId.computeClientIdFromSecretKey = computeClientIdFromSecretKey;
	const lru_js_1$4 = lru$1;
	const to_bytes_js_1$3 = toBytes$2;
	const sha256_js_1$1 = sha256$4;
	const cache$2 = new lru_js_1$4.LruMap(4096);
	/**
	 * @param secretKey - the secret key to compute the client id from
	 * @returns the 32 char hex client id
	 * @internal
	 */
	function computeClientIdFromSecretKey(secretKey) {
	    if (cache$2.has(secretKey)) {
	        return cache$2.get(secretKey);
	    }
	    // we slice off the leading `0x` and then take the first 32 chars
	    const cId = (0, sha256_js_1$1.sha256)((0, to_bytes_js_1$3.stringToBytes)(secretKey)).slice(2, 34);
	    cache$2.set(secretKey, cId);
	    return cId;
	}

	Object.defineProperty(client, "__esModule", { value: true });
	client.createThirdwebClient = createThirdwebClient;
	const client_id_js_1 = clientId;
	/**
	 * Creates a Thirdweb client using the provided client ID (client-side) or secret key (server-side).
	 *
	 * Get your client ID and secret key from the Thirdweb dashboard [here](https://thirdweb.com/dashboard/settings/api-keys).
	 * **Never share your secret key with anyone.
	 *
	 * A client is necessary for most functions in the thirdweb SDK. It provides access to thirdweb APIs including built-in RPC, storage, and more.
	 *
	 * @param options - The options for creating the client.
	 * @param [options.clientId] - The client ID to use for thirdweb services.
	 * @param [options.secretKey] - The secret key to use for thirdweb services.
	 * @returns The created Thirdweb client.
	 * @throws An error if neither `clientId` nor `secretKey` is provided.
	 *
	 * @example
	 * Create a client on the client side (client ID):
	 * ```ts
	 * import { createThirdwebClient } from "thirdweb";
	 *
	 * const client = createThirdwebClient({ clientId: "..." });
	 * ```
	 *
	 * Create a client on the server (secret key):
	 * ```ts
	 * import { createThirdwebClient } from "thirdweb";
	 *
	 * const client = createThirdwebClient({ secretKey: "..." });
	 * ```
	 */
	function createThirdwebClient(options) {
	    const { clientId, secretKey, ...rest } = options;
	    // if secretKey is provided, compute the clientId from it (and ignore any clientId passed in)
	    if (secretKey) {
	        return {
	            ...rest,
	            clientId: (0, client_id_js_1.computeClientIdFromSecretKey)(secretKey),
	            secretKey,
	        };
	    }
	    // otherwise if clientId is provided, use it
	    if (clientId) {
	        return {
	            ...rest,
	            clientId: options.clientId,
	            secretKey: undefined,
	        };
	    }
	    // otherwise throw an error
	    throw new Error("clientId or secretKey must be provided");
	}

	var utils$7 = {};

	var domains = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getThirdwebBaseUrl = exports.getThirdwebDomains = exports.setThirdwebDomains = exports.DEFAULT_RPC_URL = void 0;
		exports.DEFAULT_RPC_URL = "rpc.thirdweb.com";
		const DEFAULT_IN_APP_WALLET_URL = "embedded-wallet.thirdweb.com";
		const DEFAULT_PAY_URL = "pay.thirdweb.com";
		const DEFAULT_STORAGE_URL = "storage.thirdweb.com";
		const DEFAULT_BUNDLER_URL = "bundler.thirdweb.com";
		let domains = {
		    rpc: exports.DEFAULT_RPC_URL,
		    inAppWallet: DEFAULT_IN_APP_WALLET_URL,
		    pay: DEFAULT_PAY_URL,
		    storage: DEFAULT_STORAGE_URL,
		    bundler: DEFAULT_BUNDLER_URL,
		};
		/**
		 * @internal
		 */
		const setThirdwebDomains = (DomainOverrides) => {
		    domains = {
		        rpc: DomainOverrides.rpc ?? exports.DEFAULT_RPC_URL,
		        inAppWallet: DomainOverrides.inAppWallet ?? DEFAULT_IN_APP_WALLET_URL,
		        pay: DomainOverrides.pay ?? DEFAULT_PAY_URL,
		        storage: DomainOverrides.storage ?? DEFAULT_STORAGE_URL,
		        bundler: DomainOverrides.bundler ?? DEFAULT_BUNDLER_URL,
		    };
		};
		exports.setThirdwebDomains = setThirdwebDomains;
		/**
		 * @internal
		 */
		const getThirdwebDomains = () => {
		    return domains;
		};
		exports.getThirdwebDomains = getThirdwebDomains;
		/**
		 * @internal
		 */
		const getThirdwebBaseUrl = (service) => {
		    const origin = domains[service];
		    if (origin.startsWith("localhost")) {
		        return `http://${origin}`;
		    }
		    return `https://${origin}`;
		};
		exports.getThirdwebBaseUrl = getThirdwebBaseUrl;
		
	} (domains));

	var fetch$1 = {};

	var version$2 = {};

	Object.defineProperty(version$2, "__esModule", { value: true });
	version$2.version = void 0;
	version$2.version = "5.50.0";

	var detectPlatform$1 = {};

	Object.defineProperty(detectPlatform$1, "__esModule", { value: true });
	detectPlatform$1.detectPlatform = detectPlatform;
	detectPlatform$1.detectOS = detectOS;
	const operatingSystemRules = [
	    ["iOS", /iP(hone|od|ad)/],
	    ["Android OS", /Android/],
	    ["BlackBerry OS", /BlackBerry|BB10/],
	    ["Windows Mobile", /IEMobile/],
	    ["Amazon OS", /Kindle/],
	    ["Windows 3.11", /Win16/],
	    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
	    ["Windows 98", /(Windows 98)|(Win98)/],
	    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
	    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
	    ["Windows Server 2003", /(Windows NT 5.2)/],
	    ["Windows Vista", /(Windows NT 6.0)/],
	    ["Windows 7", /(Windows NT 6.1)/],
	    ["Windows 8", /(Windows NT 6.2)/],
	    ["Windows 8.1", /(Windows NT 6.3)/],
	    ["Windows 10", /(Windows NT 10.0)/],
	    ["Windows ME", /Windows ME/],
	    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
	    ["Open BSD", /OpenBSD/],
	    ["Sun OS", /SunOS/],
	    ["Chrome OS", /CrOS/],
	    ["Linux", /(Linux)|(X11)/],
	    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
	    ["QNX", /QNX/],
	    ["BeOS", /BeOS/],
	    ["OS/2", /OS\/2/],
	];
	function detectPlatform() {
	    if (typeof document === "undefined" &&
	        typeof navigator !== "undefined" &&
	        navigator.product === "ReactNative") {
	        // react-native
	        return "mobile";
	    }
	    if (typeof navigator !== "undefined") {
	        return "browser";
	    }
	    return "node";
	}
	function detectOS(ua) {
	    for (let ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
	        const [os, regex] = operatingSystemRules[ii];
	        const match = regex.exec(ua);
	        if (match) {
	            return os;
	        }
	    }
	    return null;
	}

	Object.defineProperty(fetch$1, "__esModule", { value: true });
	fetch$1.getClientFetch = getClientFetch;
	fetch$1.isThirdwebUrl = isThirdwebUrl;
	fetch$1.getPlatformHeaders = getPlatformHeaders;
	const version_js_1$2 = version$2;
	const lru_js_1$3 = lru$1;
	const detect_platform_js_1$1 = detectPlatform$1;
	const DEFAULT_REQUEST_TIMEOUT = 60000;
	const FETCH_CACHE = new WeakMap();
	/**
	 * @internal
	 */
	function getClientFetch(client, ecosystem) {
	    if (FETCH_CACHE.has({ client, ecosystem })) {
	        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
	        return FETCH_CACHE.get({ client, ecosystem });
	    }
	    /**
	     * @internal
	     */
	    async function fetchWithHeaders(url, init) {
	        const { requestTimeoutMs = DEFAULT_REQUEST_TIMEOUT, ...restInit } = init || {};
	        let headers = restInit.headers ? new Headers(restInit.headers) : undefined;
	        // check if we are making a request to a thirdweb service (we don't want to send any headers to non-thirdweb services)
	        if (isThirdwebUrl(url)) {
	            if (!headers) {
	                headers = new Headers();
	            }
	            const authToken = getTWAuthToken();
	            // if we have an auth token set, use that (thirdweb.com/dashboard sets this for the user)
	            // pay urls should never send the auth token, because we always want the "developer" to be the one making the request, not the "end user"
	            if (authToken && !isPayUrl(url)) {
	                headers.set("authorization", `Bearer ${authToken}`);
	            }
	            else if (client.secretKey) {
	                headers.set("x-secret-key", client.secretKey);
	            }
	            else if (client.clientId) {
	                headers.set("x-client-id", client.clientId);
	            }
	            if (ecosystem) {
	                headers.set("x-ecosystem-id", ecosystem.id);
	                if (ecosystem.partnerId) {
	                    headers.set("x-ecosystem-partner-id", ecosystem.partnerId);
	                }
	            }
	            // this already internally caches
	            for (const [key, value] of getPlatformHeaders()) {
	                headers.set(key, value);
	            }
	        }
	        let controller;
	        let abortTimeout;
	        if (requestTimeoutMs) {
	            controller = new AbortController();
	            abortTimeout = setTimeout(() => {
	                controller?.abort();
	            }, requestTimeoutMs);
	        }
	        return fetch(url, {
	            ...restInit,
	            headers,
	            signal: controller?.signal,
	        }).finally(() => {
	            if (abortTimeout) {
	                clearTimeout(abortTimeout);
	            }
	        });
	    }
	    FETCH_CACHE.set({ client, ecosystem }, fetchWithHeaders);
	    return fetchWithHeaders;
	}
	// NOTE: these all start with "." because we want to make sure we don't match (for example) "otherthirdweb.com"
	const THIRDWEB_DOMAINS = [
	    ".thirdweb.com",
	    ".ipfscdn.io",
	    // dev domains
	    ".thirdweb.dev",
	    ".thirdweb-dev.com",
	];
	const IS_THIRDWEB_URL_CACHE = new lru_js_1$3.LruMap(4096);
	/**
	 * @internal
	 */
	function isThirdwebUrl(url) {
	    if (IS_THIRDWEB_URL_CACHE.has(url)) {
	        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
	        return IS_THIRDWEB_URL_CACHE.get(url);
	    }
	    try {
	        const { hostname } = new URL(url);
	        try {
	            // special case for localhost in development only
	            if ("production" === "development" ||
	                "production" === "test") ;
	        }
	        catch { }
	        const is = THIRDWEB_DOMAINS.some((domain) => hostname.endsWith(domain));
	        IS_THIRDWEB_URL_CACHE.set(url, is);
	        return is;
	    }
	    catch {
	        IS_THIRDWEB_URL_CACHE.set(url, false);
	        return false;
	    }
	}
	function isPayUrl(url) {
	    try {
	        const { hostname } = new URL(url);
	        // pay service hostname always starts with "pay."
	        return hostname.startsWith("pay.");
	    }
	    catch {
	        return false;
	    }
	}
	const SDK_NAME = "unified-sdk";
	let previousPlatform;
	/**
	 * @internal
	 */
	function getPlatformHeaders() {
	    if (previousPlatform) {
	        return previousPlatform;
	    }
	    let os = null;
	    if (typeof navigator !== "undefined") {
	        os = (0, detect_platform_js_1$1.detectOS)(navigator.userAgent);
	    }
	    let bundleId = undefined;
	    if (typeof globalThis !== "undefined" && "Application" in globalThis) {
	        // shims use wallet connect RN module which injects Application info in globalThis
	        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
	        bundleId = globalThis.Application.applicationId;
	    }
	    previousPlatform = Object.entries({
	        "x-sdk-platform": (0, detect_platform_js_1$1.detectPlatform)(),
	        "x-sdk-version": version_js_1$2.version,
	        "x-sdk-os": os ? parseOs(os) : "unknown",
	        "x-sdk-name": SDK_NAME,
	        ...(bundleId ? { "x-bundle-id": bundleId } : {}),
	    });
	    return previousPlatform;
	}
	/**
	 * @internal
	 */
	function parseOs(os) {
	    const osLowerCased = os.toLowerCase();
	    if (osLowerCased.startsWith("win")) {
	        return "win";
	    }
	    // we do NOT use the lowercase here
	    switch (os) {
	        case "Mac OS":
	            return "mac";
	        case "iOS":
	            return "ios";
	        case "Android OS":
	            return "android";
	        default:
	            // if we somehow fall through here, just replace all spaces with underscores and send it
	            return osLowerCased.replace(/\s/gi, "_");
	    }
	}
	function getTWAuthToken() {
	    if (typeof globalThis !== "undefined" &&
	        "TW_AUTH_TOKEN" in globalThis &&
	        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
	        typeof globalThis.TW_AUTH_TOKEN === "string") {
	        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
	        return globalThis.TW_AUTH_TOKEN;
	    }
	    return null;
	}

	var withCache$2 = {};

	// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts
	// with slight adjustments made to comply with our linting rules
	// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing
	// alternatively viem could maybe export this helpful util
	// TODO: explore using a LRU cache instead of a Map
	Object.defineProperty(withCache$2, "__esModule", { value: true });
	withCache$2.getCache = getCache;
	withCache$2.withCache = withCache$1;
	const promiseCache = /*#__PURE__*/ new Map();
	const responseCache = /*#__PURE__*/ new Map();
	/**
	 *@internal
	 */
	function getCache(cacheKey) {
	    const buildCache = (cacheKey_, cache) => ({
	        clear: () => cache.delete(cacheKey_),
	        get: () => cache.get(cacheKey_),
	        set: (data) => cache.set(cacheKey_, data),
	    });
	    const promise = buildCache(cacheKey, promiseCache);
	    const response = buildCache(cacheKey, responseCache);
	    return {
	        clear: () => {
	            promise.clear();
	            response.clear();
	        },
	        promise,
	        response,
	    };
	}
	/**
	 * Returns the result of a given promise, and caches the result for
	 * subsequent invocations against a provided cache key.
	 * @internal
	 */
	async function withCache$1(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
	    const cache = getCache(cacheKey);
	    // If a response exists in the cache, and it's not expired, return it
	    // and do not invoke the promise.
	    // If the max age is 0, the cache is disabled.
	    const response = cache.response.get();
	    if (response && cacheTime > 0) {
	        const age = new Date().getTime() - response.created.getTime();
	        if (age < cacheTime) {
	            return response.data;
	        }
	    }
	    let promise = cache.promise.get();
	    if (!promise) {
	        promise = fn();
	        // Store the promise in the cache so that subsequent invocations
	        // will wait for the same promise to resolve (deduping).
	        cache.promise.set(promise);
	    }
	    try {
	        const data = await promise;
	        // Store the response in the cache so that subsequent invocations
	        // will return the same response.
	        cache.response.set({ created: new Date(), data });
	        return data;
	    }
	    finally {
	        // Clear the promise cache so that subsequent invocations will
	        // invoke the promise again.
	        cache.promise.clear();
	    }
	}

	Object.defineProperty(utils$7, "__esModule", { value: true });
	utils$7.defineChain = defineChain$2;
	utils$7.cacheChains = cacheChains;
	utils$7.getCachedChain = getCachedChain;
	utils$7.getCachedChainIfExists = getCachedChainIfExists;
	utils$7.getRpcUrlForChain = getRpcUrlForChain;
	utils$7.getChainSymbol = getChainSymbol;
	utils$7.getChainDecimals = getChainDecimals;
	utils$7.getChainNativeCurrencyName = getChainNativeCurrencyName;
	utils$7.getChainMetadata = getChainMetadata;
	utils$7.convertApiChainToChain = convertApiChainToChain;
	const domains_js_1$2 = domains;
	const fetch_js_1$9 = fetch$1;
	const withCache_js_1$1 = withCache$2;
	const CUSTOM_CHAIN_MAP = new Map();
	/**
	 * Defines a chain with the given options.
	 * @param options The options for the chain.
	 * @returns The defined chain.
	 * @example
	 * Just pass the chain ID to connect to:
	 * ```ts
	 * const chain = defineChain(1);
	 * ```
	 * Or pass your own RPC or custom values:
	 * ```ts
	 * const chain = defineChain({
	 *  id: 1,
	 *  rpc: "https://my-rpc.com",
	 *  nativeCurrency: {
	 *    name: "Ether",
	 *    symbol: "ETH",
	 *    decimals: 18,
	 *  },
	 * });
	 * ```
	 * @chain
	 */
	function defineChain$2(options) {
	    const RPC_URL = (0, domains_js_1$2.getThirdwebDomains)().rpc;
	    if (typeof options === "number") {
	        return {
	            id: options,
	            rpc: `https://${options}.${RPC_URL}`,
	        };
	    }
	    if (isViemChain(options)) {
	        return convertViemChain(options);
	    }
	    if (isLegacyChain(options)) {
	        return convertLegacyChain(options);
	    }
	    // otherwise if it's not a viem chain, continue
	    let rpc = options.rpc;
	    if (!rpc) {
	        rpc = `https://${options.id}.${RPC_URL}`;
	    }
	    const chain = { ...options, rpc };
	    CUSTOM_CHAIN_MAP.set(options.id, chain);
	    return chain;
	}
	/**
	 * @internal
	 */
	function cacheChains(chains) {
	    for (const chain of chains) {
	        CUSTOM_CHAIN_MAP.set(chain.id, chain);
	    }
	}
	/**
	 * @internal
	 */
	function getCachedChain(id) {
	    if (CUSTOM_CHAIN_MAP.has(id)) {
	        return CUSTOM_CHAIN_MAP.get(id);
	    }
	    const RPC_URL = (0, domains_js_1$2.getThirdwebDomains)().rpc;
	    const chain = {
	        id: id,
	        rpc: `https://${id}.${RPC_URL}`,
	    };
	    return chain;
	}
	/**
	 * @internal
	 */
	function getCachedChainIfExists(id) {
	    return CUSTOM_CHAIN_MAP.get(id);
	}
	function isLegacyChain(chain) {
	    return "rpc" in chain && Array.isArray(chain.rpc) && "slug" in chain;
	}
	function convertLegacyChain(legacyChain) {
	    const RPC_URL = (0, domains_js_1$2.getThirdwebDomains)().rpc;
	    return {
	        id: legacyChain.chainId,
	        name: legacyChain.name,
	        rpc: legacyChain.rpc[0] ?? `https://${legacyChain.chainId}.${RPC_URL}`,
	        blockExplorers: legacyChain?.explorers?.map((explorer) => ({
	            name: explorer.name,
	            url: explorer.url,
	            apiUrl: explorer.url,
	        })),
	        nativeCurrency: {
	            name: legacyChain.nativeCurrency.name,
	            symbol: legacyChain.nativeCurrency.symbol,
	            decimals: legacyChain.nativeCurrency.decimals,
	        },
	        faucets: legacyChain.faucets ? [...legacyChain.faucets] : undefined,
	        icon: legacyChain.icon,
	        testnet: legacyChain.testnet ? true : undefined,
	    };
	}
	function isViemChain(chain) {
	    return "rpcUrls" in chain && !("rpc" in chain);
	}
	function convertViemChain(viemChain) {
	    const RPC_URL = (0, domains_js_1$2.getThirdwebDomains)().rpc;
	    return {
	        id: viemChain.id,
	        name: viemChain.name,
	        nativeCurrency: {
	            name: viemChain.nativeCurrency.name,
	            symbol: viemChain.nativeCurrency.symbol,
	            decimals: viemChain.nativeCurrency.decimals,
	        },
	        rpc: viemChain.rpcUrls.default.http[0] ?? `https://${viemChain.id}.${RPC_URL}`,
	        blockExplorers: viemChain?.blockExplorers
	            ? Object.values(viemChain?.blockExplorers).map((explorer) => {
	                return {
	                    name: explorer.name,
	                    url: explorer.url,
	                    apiUrl: explorer.apiUrl,
	                };
	            })
	            : [],
	        testnet: viemChain.testnet ? true : undefined,
	    };
	}
	/**
	 * Retrieves the RPC URL for the specified chain.
	 * If a custom RPC URL is defined in the options, it will be used.
	 * Otherwise, a thirdweb RPC URL will be constructed using the chain ID and client ID.
	 * @param options - The options object containing the chain and client information.
	 * @returns The RPC URL for the specified chain.
	 * @example
	 * ```ts
	 * import { getRpcUrlForChain } from "thirdweb/chains";
	 * const rpcUrl = getRpcUrlForChain({ chain: 1, client });
	 * console.log(rpcUrl); // "https://1.rpc.thirdweb.com/...
	 * ```
	 * @chain
	 */
	function getRpcUrlForChain(options) {
	    const baseRpcUrl = (0, domains_js_1$2.getThirdwebDomains)().rpc;
	    // if the chain is just a number, construct the RPC URL using the chain ID and client ID
	    if (typeof options.chain === "number") {
	        return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;
	    }
	    const { rpc } = options.chain;
	    // add on the client ID to the RPC URL if it's a thirdweb URL
	    if ((0, fetch_js_1$9.isThirdwebUrl)(rpc)) {
	        const rpcUrl = new URL(options.chain.rpc.replace(domains_js_1$2.DEFAULT_RPC_URL, baseRpcUrl));
	        rpcUrl.pathname = `/${options.client.clientId}`;
	        return rpcUrl.toString();
	    }
	    return rpc;
	}
	/**
	 * Retrieves the chain symbol from the provided chain.
	 * @param chain - The chain.
	 * @returns The chain symbol.
	 * @internal
	 */
	async function getChainSymbol(chain) {
	    if (!chain.nativeCurrency?.symbol) {
	        return getChainMetadata(chain)
	            .then((data) => data.nativeCurrency.symbol)
	            .catch(() => {
	            // if we fail to fetch the chain data, return "ETH" as a fallback
	            return "ETH";
	        });
	    }
	    // if we have a symbol, return it
	    return chain.nativeCurrency.symbol;
	}
	/**
	 * Retrieves the number of decimals for the native currency of a given chain.
	 * If the chain is not recognized or the data cannot be fetched, it returns a fallback value of 18.
	 * @param chain - The chain for which to retrieve the decimals.
	 * @returns A promise that resolves to the number of decimals for the native currency of the chain.
	 * @internal
	 */
	async function getChainDecimals(chain) {
	    if (!chain.nativeCurrency?.decimals) {
	        return getChainMetadata(chain)
	            .then((data) => data.nativeCurrency.decimals)
	            .catch(() => {
	            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)
	            return 18;
	        });
	    }
	    // if we have decimals, return it
	    return chain.nativeCurrency.decimals;
	}
	/**
	 * Retrieves the name of the native currency for a given chain.
	 * If the chain object does not have a native currency name, it attempts to fetch the chain data and retrieve the native currency name from there.
	 * If fetching the chain data fails, it falls back to returning "ETH".
	 * @param chain The chain object for which to retrieve the native currency name.
	 * @returns A promise that resolves to the native currency name.
	 * @internal
	 */
	async function getChainNativeCurrencyName(chain) {
	    if (!chain.nativeCurrency?.name) {
	        return getChainMetadata(chain)
	            .then((data) => data.nativeCurrency.name)
	            .catch(() => {
	            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)
	            return "ETH";
	        });
	    }
	    // if we have a name, return it
	    return chain.nativeCurrency.name;
	}
	/**
	 * Retrieves chain data for a given chain.
	 * @param chain - The chain object containing the chain ID.
	 * @returns A Promise that resolves to the chain data.
	 * @throws If there is an error fetching the chain data.
	 * @example
	 * ```ts
	 * const chain = defineChain({ id: 1 });
	 * const chainData = await getChainMetadata(chain);
	 * console.log(chainData);
	 * ```
	 * @chain
	 */
	function getChainMetadata(chain) {
	    const chainId = chain.id;
	    return (0, withCache_js_1$1.withCache)(async () => {
	        try {
	            const res = await fetch(`https://api.thirdweb.com/v1/chains/${chainId}`);
	            if (!res.ok) {
	                res.body?.cancel();
	                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
	            }
	            const response = (await res.json());
	            if (response.error) {
	                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
	            }
	            if (!response.data) {
	                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
	            }
	            const data = response.data;
	            return createChainMetadata(chain, data);
	        }
	        catch {
	            return createChainMetadata(chain);
	        }
	    }, {
	        cacheKey: `chain:${chainId}`,
	        cacheTime: 5 * 60 * 1000, // 5 minutes
	    });
	}
	/**
	 * Convert `ApiChain` to `Chain` object
	 * @internal
	 */
	function convertApiChainToChain(apiChain) {
	    return {
	        id: apiChain.chainId,
	        name: apiChain.name,
	        rpc: apiChain.rpc[0] || "",
	        testnet: apiChain.testnet === true ? true : undefined,
	        nativeCurrency: apiChain.nativeCurrency,
	        blockExplorers: apiChain.explorers?.map((explorer) => {
	            return {
	                name: explorer.name,
	                url: explorer.url,
	                apiUrl: explorer.url,
	            };
	        }),
	        faucets: apiChain.faucets ? [...apiChain.faucets] : undefined,
	        icon: apiChain.icon,
	    };
	}
	function createChainMetadata(chain, data) {
	    const nativeCurrency = chain.nativeCurrency
	        ? {
	            ...data?.nativeCurrency,
	            ...chain.nativeCurrency,
	        }
	        : data?.nativeCurrency;
	    return {
	        ...data,
	        name: chain.name || data?.name || "",
	        chainId: chain.id || data?.chainId || -1,
	        rpc: chain.rpc ? [chain.rpc] : data?.rpc || [""],
	        testnet: chain.testnet || data?.testnet || false,
	        nativeCurrency: {
	            name: nativeCurrency?.name || "",
	            symbol: nativeCurrency?.symbol || "",
	            decimals: nativeCurrency?.decimals || 18,
	        },
	        icon: chain.icon || data?.icon,
	        chain: data?.chain || chain.name || "",
	        shortName: data?.shortName || chain.name || "",
	        slug: data?.slug || chain.name || "",
	        explorers: chain.blockExplorers?.map((e) => ({
	            name: e.name,
	            url: e.url,
	            standard: "EIP3091",
	        })) || data?.explorers,
	    };
	}

	var rpc$1 = {};

	var fetchRpc$1 = {};

	var json = {};

	Object.defineProperty(json, "__esModule", { value: true });
	json.stringify = void 0;
	/**
	 * Stringify a JSON object and convert all bigint values to string
	 *
	 * If you are getting this error: "Exception: Do not know how to serialize a BigInt",
	 * you probably can use this function to parse the data.
	 * Because bigint is not an accepted value of the JSON format.
	 *
	 * @returns An object with all bigint values converted to string
	 * @example
	 * ```ts
	 * import { stringify } from "thirdweb/utils";
	 * const obj = { tokenId: 0n };
	 * const str = stringify(obj); // "{"tokenId":"0"}"
	 * ```
	 * @utils
	 */
	const stringify$2 = (value, replacer, space) => {
	    const res = JSON.stringify(value, (key, value_) => {
	        const value__ = typeof value_ === "bigint" ? value_.toString() : value_;
	        return typeof replacer === "function" ? replacer(key, value__) : value__;
	    }, space);
	    return res;
	};
	json.stringify = stringify$2;

	Object.defineProperty(fetchRpc$1, "__esModule", { value: true });
	fetchRpc$1.fetchRpc = fetchRpc;
	fetchRpc$1.fetchSingleRpc = fetchSingleRpc;
	const fetch_js_1$8 = fetch$1;
	const json_js_1$2 = json;
	/**
	 * @internal
	 */
	async function fetchRpc(rpcUrl, client, options) {
	    const response = await (0, fetch_js_1$8.getClientFetch)(client)(rpcUrl, {
	        headers: {
	            ...client.config?.rpc?.fetch?.headers,
	            "Content-Type": "application/json",
	        },
	        body: (0, json_js_1$2.stringify)(options.requests),
	        method: "POST",
	        requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
	        keepalive: client.config?.rpc?.fetch?.keepalive,
	    });
	    if (!response.ok) {
	        response.body?.cancel();
	        throw new Error(`RPC request failed with status ${response.status} - ${response.statusText}`);
	    }
	    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
	        return await response.json();
	    }
	    const text = await response.text();
	    try {
	        return JSON.parse(text);
	    }
	    catch (err) {
	        console.error("Error parsing response", err, text);
	        throw err;
	    }
	}
	/**
	 * @internal
	 */
	async function fetchSingleRpc(rpcUrl, client, options) {
	    const response = await (0, fetch_js_1$8.getClientFetch)(client)(rpcUrl, {
	        headers: {
	            ...(client.config?.rpc?.fetch?.headers || {}),
	            "Content-Type": "application/json",
	        },
	        body: (0, json_js_1$2.stringify)(options.request),
	        method: "POST",
	        requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
	        keepalive: client.config?.rpc?.fetch?.keepalive,
	    });
	    if (!response.ok) {
	        response.body?.cancel();
	        throw new Error(`RPC request failed with status ${response.status}`);
	    }
	    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
	        return await response.json();
	    }
	    const text = await response.text();
	    try {
	        return JSON.parse(text);
	    }
	    catch (err) {
	        console.error("Error parsing response", err, text);
	        throw err;
	    }
	}

	Object.defineProperty(rpc$1, "__esModule", { value: true });
	rpc$1.getRpcClient = getRpcClient;
	const utils_js_1$q = utils$7;
	const fetch_rpc_js_1 = fetchRpc$1;
	const RPC_CLIENT_MAP = new WeakMap();
	/**
	 * @internal
	 */
	function getRpcClientMap(client) {
	    if (RPC_CLIENT_MAP.has(client)) {
	        return RPC_CLIENT_MAP.get(client);
	    }
	    const rpcClientMap = new Map();
	    RPC_CLIENT_MAP.set(client, rpcClientMap);
	    return rpcClientMap;
	}
	/**
	 * @internal
	 */
	function rpcRequestKey(request) {
	    return `${request.method}:${JSON.stringify(request.params)}`;
	}
	const DEFAULT_MAX_BATCH_SIZE = 100;
	// default to no timeout (next tick)
	const DEFAULT_BATCH_TIMEOUT_MS = 0;
	/**
	 * Returns an RPC request that can be used to make JSON-RPC requests.
	 * @param options - The RPC options.
	 * @returns The RPC request function.
	 * @rpc
	 * @example
	 * ```ts
	 * import { createThirdwebClient } from "thirdweb";
	 * import { getRpcClient } from "thirdweb/rpc";
	 * import { ethereum } from "thirdweb/chains";
	 * const client = createThirdwebClient({ clientId: "..." });
	 * const rpcRequest = getRpcClient({ client, chain: ethereum, });
	 * const blockNumber = await rpcRequest({
	 *  method: "eth_blockNumber",
	 * });
	 * ```
	 */
	function getRpcClient(options) {
	    const rpcClientMap = getRpcClientMap(options.client);
	    const rpcUrl = options.chain.rpc;
	    if (rpcClientMap.has(rpcUrl)) {
	        return rpcClientMap.get(rpcUrl);
	    }
	    const rpcClient = (() => {
	        // we can do this upfront because it cannot change later
	        const rpcUrl = (0, utils_js_1$q.getRpcUrlForChain)({
	            client: options.client,
	            chain: options.chain,
	        });
	        const batchSize = 
	        // look at the direct options passed
	        options.config?.maxBatchSize ??
	            // look at the client options
	            options.client.config?.rpc?.maxBatchSize ??
	            // use defaults
	            DEFAULT_MAX_BATCH_SIZE;
	        const batchTimeoutMs = 
	        // look at the direct options passed
	        options.config?.batchTimeoutMs ??
	            // look at the client options
	            options.client.config?.rpc?.batchTimeoutMs ??
	            DEFAULT_BATCH_TIMEOUT_MS;
	        // inflight requests
	        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	        const inflightRequests = new Map();
	        let pendingBatch = [];
	        let pendingBatchTimeout = null;
	        /**
	         * Sends the pending batch of requests.
	         * @internal
	         */
	        function sendPendingBatch() {
	            // clear the timeout if any
	            if (pendingBatchTimeout) {
	                clearTimeout(pendingBatchTimeout);
	                pendingBatchTimeout = null;
	            }
	            // prepare the requests array (we know the size)
	            const requests = new Array(pendingBatch.length);
	            const activeBatch = pendingBatch.slice().map((inflight, index) => {
	                // assign the id to the request
	                inflight.request.id = index;
	                // also assign the jsonrpc version
	                inflight.request.jsonrpc = "2.0";
	                // assing the request to the requests array (so we don't have to map it again later)
	                requests[index] = inflight.request;
	                return inflight;
	            });
	            // reset pendingBatch to empty
	            pendingBatch = [];
	            (0, fetch_rpc_js_1.fetchRpc)(rpcUrl, options.client, {
	                requests,
	                requestTimeoutMs: options.config?.requestTimeoutMs,
	            })
	                .then((responses) => {
	                // for each response, resolve the inflight request
	                activeBatch.forEach((inflight, index) => {
	                    const response = responses[index];
	                    // if we didn't get a response at all, reject the inflight request
	                    if (!response) {
	                        inflight.reject(new Error("No response"));
	                        return;
	                    }
	                    // handle errors in the response
	                    if (response instanceof Error) {
	                        inflight.reject(response);
	                        return;
	                    }
	                    // handle strings as responses??
	                    if (typeof response === "string") {
	                        inflight.reject(new Error(response));
	                        return;
	                    }
	                    if ("error" in response) {
	                        inflight.reject(response.error);
	                        // otherwise, resolve the inflight request
	                    }
	                    else if (response.method === "eth_subscription") {
	                        // TODO: handle subscription responses
	                        throw new Error("Subscriptions not supported yet");
	                    }
	                    else {
	                        inflight.resolve(response.result);
	                    }
	                    // remove the inflight request from the inflightRequests map
	                    inflightRequests.delete(inflight.requestKey);
	                });
	            })
	                .catch((err) => {
	                // http call failed, reject all inflight requests
	                for (const inflight of activeBatch) {
	                    inflight.reject(err);
	                    // remove the inflight request from the inflightRequests map
	                    inflightRequests.delete(inflight.requestKey);
	                }
	            });
	        }
	        // shortcut everything if we do not need to batch
	        if (batchSize === 1) {
	            return async (request) => {
	                // we can hard-code the id and jsonrpc version
	                // we also mutate the request object here to avoid copying it
	                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	                request.id = 1;
	                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	                request.jsonrpc = "2.0";
	                const rpcResponse = await (0, fetch_rpc_js_1.fetchSingleRpc)(rpcUrl, options.client, {
	                    request: request,
	                    requestTimeoutMs: options.config?.requestTimeoutMs,
	                });
	                if (!rpcResponse) {
	                    throw new Error("No response");
	                }
	                if ("error" in rpcResponse) {
	                    throw rpcResponse.error;
	                }
	                return rpcResponse.result;
	            };
	        }
	        return async (request) => {
	            const requestKey = rpcRequestKey(request);
	            // if the request for this key is already inflight, return the promise directly
	            if (inflightRequests.has(requestKey)) {
	                // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined
	                return inflightRequests.get(requestKey);
	            }
	            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	            let resolve;
	            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	            let reject;
	            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	            const promise = new Promise((resolve_, reject_) => {
	                resolve = resolve_;
	                reject = reject_;
	            });
	            inflightRequests.set(requestKey, promise);
	            // @ts-expect-error - they *are* definitely assgined within the promise constructor
	            pendingBatch.push({ request, resolve, reject, requestKey });
	            if (batchSize > 1) {
	                // if there is no timeout, set one
	                if (!pendingBatchTimeout) {
	                    pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);
	                }
	                // if the batch is full, send it
	                if (pendingBatch.length >= batchSize) {
	                    sendPendingBatch();
	                }
	            }
	            else {
	                sendPendingBatch();
	            }
	            return promise;
	        };
	    })();
	    rpcClientMap.set(rpcUrl, rpcClient);
	    return rpcClient;
	}

	var watchBlockNumber$3 = {};

	var eth_blockNumber$1 = {};

	Object.defineProperty(eth_blockNumber$1, "__esModule", { value: true });
	eth_blockNumber$1.eth_blockNumber = eth_blockNumber;
	const hex_js_1$e = hex;
	/**
	 * Retrieves the current block number from the Ethereum blockchain.
	 * @param request - The EIP1193 request function.
	 * @returns A promise that resolves to the current block number as a bigint.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_blockNumber } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const blockNumber = await eth_blockNumber(rpcRequest);
	 * ```
	 */
	async function eth_blockNumber(request) {
	    const blockNumberHex = await request({
	        method: "eth_blockNumber",
	    });
	    return (0, hex_js_1$e.hexToBigInt)(blockNumberHex);
	}

	Object.defineProperty(watchBlockNumber$3, "__esModule", { value: true });
	watchBlockNumber$3.watchBlockNumber = watchBlockNumber$2;
	const eth_blockNumber_js_1$1 = eth_blockNumber$1;
	const rpc_js_1$e = rpc$1;
	const MAX_POLL_DELAY = 5000; // 5 seconds
	const DEFAULT_POLL_DELAY = 1000; // 1 second
	const MIN_POLL_DELAY = 500; // 500 milliseconds
	const DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default
	const SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times
	/**
	 * TODO: document
	 * @internal
	 */
	function getAverageBlockTime(blockTimes) {
	    // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY
	    while (blockTimes.length < SLIDING_WINDOW_SIZE) {
	        blockTimes.unshift(DEFAULT_POLL_DELAY);
	    }
	    const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);
	    return sum / blockTimes.length;
	}
	/**
	 * TODO: document
	 * @internal
	 */
	function createBlockNumberPoller(client, chain, overPollRatio, onError) {
	    let subscribers = [];
	    let blockTimesWindow = [];
	    let isActive = false;
	    let lastBlockNumber;
	    let lastBlockAt;
	    const rpcRequest = (0, rpc_js_1$e.getRpcClient)({ client, chain });
	    /**
	     * TODO: document
	     * @internal
	     */
	    async function poll() {
	        // stop polling if there are no more subscriptions
	        if (!isActive) {
	            return;
	        }
	        try {
	            const blockNumber = await (0, eth_blockNumber_js_1$1.eth_blockNumber)(rpcRequest);
	            if (!lastBlockNumber || blockNumber > lastBlockNumber) {
	                let newBlockNumbers = [];
	                if (lastBlockNumber) {
	                    for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {
	                        newBlockNumbers.push(BigInt(i));
	                    }
	                }
	                else {
	                    newBlockNumbers = [blockNumber];
	                }
	                lastBlockNumber = blockNumber;
	                const currentTime = new Date().getTime();
	                if (lastBlockAt) {
	                    // if we skipped a block we need to adjust the block time down to that level
	                    const blockTime = (currentTime - lastBlockAt) / newBlockNumbers.length;
	                    blockTimesWindow.push(blockTime);
	                    blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);
	                }
	                lastBlockAt = currentTime;
	                // for all new blockNumbers...
	                for (const b of newBlockNumbers) {
	                    // ... call all current subscribers
	                    for (const subscriberCallback of subscribers) {
	                        subscriberCallback(b);
	                    }
	                }
	            }
	        }
	        catch (err) {
	            if (onError) {
	                onError(err);
	            }
	            else {
	                console.error(`[watchBlockNumber]: Failed to poll for latest block number: ${err}`);
	            }
	        }
	        const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);
	        // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay
	        const pollDelay = Math.max(MIN_POLL_DELAY, Math.min(MAX_POLL_DELAY, Math.max(MIN_POLL_DELAY, currentApproximateBlockTime)));
	        // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)
	        await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));
	        // poll again
	        poll();
	    }
	    // return the "subscribe" function
	    return function subscribe(callBack, initialBlockNumber) {
	        subscribers.push(callBack);
	        // if we are currently not active -> start polling
	        if (!isActive) {
	            lastBlockNumber = initialBlockNumber;
	            isActive = true;
	            poll();
	        }
	        // return the "unsubscribe" function (meaning the caller can unsubscribe)
	        return function unSubscribe() {
	            // filter out the callback from the subscribers
	            subscribers = subscribers.filter((fn) => fn !== callBack);
	            // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling
	            if (subscribers.length === 0) {
	                lastBlockNumber = undefined;
	                lastBlockAt = undefined;
	                isActive = false;
	            }
	        };
	    };
	}
	/**
	 * TODO: document
	 * @internal
	 */
	function sleep(ms) {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	}
	const existingPollers = new Map();
	/**
	 * Watches the block number for a specific chain.
	 * @param opts - The options for watching the block number.
	 * @returns The unwatch function.
	 * @example
	 * ```ts
	 * import { watchBlockNumber } from "thirdweb";
	 * const unwatch = watchBlockNumber({
	 *  client,
	 *  chainId,
	 *  onNewBlockNumber: (blockNumber) => {
	 *    // do something with the block number
	 *  },
	 *  onError: (err) => {
	 *    // do something if getting the block number fails
	 *  },
	 * });
	 *
	 * // later stop watching
	 * unwatch();
	 * ```
	 * @rpc
	 */
	function watchBlockNumber$2(opts) {
	    const { client, chain, onNewBlockNumber, overPollRatio, latestBlockNumber, onError, } = opts;
	    const chainId = chain.id;
	    // if we already have a poller for this chainId -> use it.
	    let poller = existingPollers.get(chainId);
	    // otherwise create a new poller
	    if (!poller) {
	        poller = createBlockNumberPoller(client, chain, overPollRatio, onError);
	        // and store it for later use
	        existingPollers.set(chainId, poller);
	    }
	    // subscribe to the poller and return the unSubscribe function to the caller
	    return poller(onNewBlockNumber, latestBlockNumber);
	}

	var eth_call$1 = {};

	Object.defineProperty(eth_call$1, "__esModule", { value: true });
	eth_call$1.eth_call = eth_call;
	const hex_js_1$d = hex;
	function encodeStateOverrides(overrides) {
	    return Object.fromEntries(Object.entries(overrides).map(([address, override]) => {
	        return [
	            address,
	            {
	                balance: override.balance ? (0, hex_js_1$d.numberToHex)(override.balance) : undefined,
	                nonce: override.nonce ? (0, hex_js_1$d.numberToHex)(override.nonce) : undefined,
	                code: override.code,
	                state: override.state,
	                stateDiff: override.stateDiff,
	            },
	        ];
	    }));
	}
	/**
	 * Executes a call or a transaction on the Ethereum network.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for the call or transaction.
	 * @returns A promise that resolves to the result of the call or transaction.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_call } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const result = await eth_call(rpcRequest, {
	 *  to: "0x...",
	 *  ...
	 * });
	 * ```
	 */
	async function eth_call(request, params) {
	    const { blockNumber, blockTag, ...txRequest } = params;
	    const blockNumberHex = blockNumber ? (0, hex_js_1$d.numberToHex)(blockNumber) : undefined;
	    // default to "latest" if no block is provided
	    const block = blockNumberHex || blockTag || "latest";
	    return await request({
	        method: "eth_call",
	        params: params.stateOverrides
	            ? [
	                txRequest,
	                block,
	                encodeStateOverrides(params.stateOverrides),
	            ]
	            : [txRequest, block],
	    });
	}

	var eth_estimateGas$1 = {};

	Object.defineProperty(eth_estimateGas$1, "__esModule", { value: true });
	eth_estimateGas$1.eth_estimateGas = eth_estimateGas;
	const hex_js_1$c = hex;
	/**
	 * Estimates the gas required to execute a transaction on the Ethereum network.
	 * @param request - The EIP1193 request function.
	 * @param transactionRequest - The transaction request object.
	 * @returns A promise that resolves to the estimated gas as a bigint.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_estimateGas } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const gas = await eth_estimateGas(rpcRequest, {
	 *  to: "0x...",
	 *  ...
	 * });
	 * ```
	 */
	async function eth_estimateGas(request, transactionRequest) {
	    const estimateResult = await request({
	        method: "eth_estimateGas",
	        params: [transactionRequest],
	    });
	    return (0, hex_js_1$c.hexToBigInt)(estimateResult);
	}

	var eth_gasPrice$1 = {};

	Object.defineProperty(eth_gasPrice$1, "__esModule", { value: true });
	eth_gasPrice$1.eth_gasPrice = eth_gasPrice;
	const hex_js_1$b = hex;
	/**
	 * Retrieves the current gas price from the Ethereum network.
	 * @param request - The EIP1193 request function.
	 * @returns A promise that resolves to the gas price as a bigint.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_gasPrice } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const gasPrice = await eth_gasPrice(rpcRequest);
	 * ```
	 */
	async function eth_gasPrice(request) {
	    const result = await request({
	        method: "eth_gasPrice",
	    });
	    return (0, hex_js_1$b.hexToBigInt)(result);
	}

	var eth_getBalance$1 = {};

	Object.defineProperty(eth_getBalance$1, "__esModule", { value: true });
	eth_getBalance$1.eth_getBalance = eth_getBalance;
	const hex_js_1$a = hex;
	/**
	 * Retrieves the balance of the specified Ethereum address.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for retrieving the balance.
	 * @returns A promise that resolves to the balance of the address in wei as bigint.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getBalance } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const balance = await eth_getBalance(rpcRequest, {
	 *  address: "0x...",
	 * });
	 * ```
	 */
	async function eth_getBalance(request, params) {
	    const hexBalance = await request({
	        method: "eth_getBalance",
	        params: [params.address, params.blockTag || "latest"],
	    });
	    return (0, hex_js_1$a.hexToBigInt)(hexBalance);
	}

	var eth_getBlockByHash$1 = {};

	var _cjs = {};

	var exports$1 = {};

	var errors$1 = {};

	var version$1 = {};

	Object.defineProperty(version$1, "__esModule", { value: true });
	version$1.version = void 0;
	version$1.version = '1.0.5';

	Object.defineProperty(errors$1, "__esModule", { value: true });
	errors$1.BaseError = void 0;
	const version_js_1$1 = version$1;
	class BaseError$1 extends Error {
	    constructor(shortMessage, args = {}) {
	        const details = args.cause instanceof BaseError$1
	            ? args.cause.details
	            : args.cause?.message
	                ? args.cause.message
	                : args.details;
	        const docsPath = args.cause instanceof BaseError$1
	            ? args.cause.docsPath || args.docsPath
	            : args.docsPath;
	        const message = [
	            shortMessage || 'An error occurred.',
	            '',
	            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
	            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),
	            ...(details ? [`Details: ${details}`] : []),
	            `Version: abitype@${version_js_1$1.version}`,
	        ].join('\n');
	        super(message);
	        Object.defineProperty(this, "details", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "docsPath", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "metaMessages", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "shortMessage", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'AbiTypeError'
	        });
	        if (args.cause)
	            this.cause = args.cause;
	        this.details = details;
	        this.docsPath = docsPath;
	        this.metaMessages = args.metaMessages;
	        this.shortMessage = shortMessage;
	    }
	}
	errors$1.BaseError = BaseError$1;

	var narrow$1 = {};

	Object.defineProperty(narrow$1, "__esModule", { value: true });
	narrow$1.narrow = narrow;
	function narrow(value) {
	    return value;
	}

	var formatAbi$1 = {};

	var formatAbiItem$2 = {};

	var formatAbiParameters$1 = {};

	var formatAbiParameter$1 = {};

	var regex$1 = {};

	Object.defineProperty(regex$1, "__esModule", { value: true });
	regex$1.isTupleRegex = regex$1.integerRegex = regex$1.bytesRegex = void 0;
	regex$1.execTyped = execTyped;
	function execTyped(regex, string) {
	    const match = regex.exec(string);
	    return match?.groups;
	}
	regex$1.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
	regex$1.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
	regex$1.isTupleRegex = /^\(.+?\).*?$/;

	Object.defineProperty(formatAbiParameter$1, "__esModule", { value: true });
	formatAbiParameter$1.formatAbiParameter = formatAbiParameter;
	const regex_js_1$4 = regex$1;
	const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
	function formatAbiParameter(abiParameter) {
	    let type = abiParameter.type;
	    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
	        type = '(';
	        const length = abiParameter.components.length;
	        for (let i = 0; i < length; i++) {
	            const component = abiParameter.components[i];
	            type += formatAbiParameter(component);
	            if (i < length - 1)
	                type += ', ';
	        }
	        const result = (0, regex_js_1$4.execTyped)(tupleRegex, abiParameter.type);
	        type += `)${result?.array ?? ''}`;
	        return formatAbiParameter({
	            ...abiParameter,
	            type,
	        });
	    }
	    if ('indexed' in abiParameter && abiParameter.indexed)
	        type = `${type} indexed`;
	    if (abiParameter.name)
	        return `${type} ${abiParameter.name}`;
	    return type;
	}

	Object.defineProperty(formatAbiParameters$1, "__esModule", { value: true });
	formatAbiParameters$1.formatAbiParameters = formatAbiParameters;
	const formatAbiParameter_js_1 = formatAbiParameter$1;
	function formatAbiParameters(abiParameters) {
	    let params = '';
	    const length = abiParameters.length;
	    for (let i = 0; i < length; i++) {
	        const abiParameter = abiParameters[i];
	        params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
	        if (i !== length - 1)
	            params += ', ';
	    }
	    return params;
	}

	Object.defineProperty(formatAbiItem$2, "__esModule", { value: true });
	formatAbiItem$2.formatAbiItem = formatAbiItem$1;
	const formatAbiParameters_js_1 = formatAbiParameters$1;
	function formatAbiItem$1(abiItem) {
	    if (abiItem.type === 'function')
	        return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'
            ? ` ${abiItem.stateMutability}`
            : ''}${abiItem.outputs.length
            ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})`
            : ''}`;
	    if (abiItem.type === 'event')
	        return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
	    if (abiItem.type === 'error')
	        return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
	    if (abiItem.type === 'constructor')
	        return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
	    if (abiItem.type === 'fallback')
	        return 'fallback()';
	    return 'receive() external payable';
	}

	Object.defineProperty(formatAbi$1, "__esModule", { value: true });
	formatAbi$1.formatAbi = formatAbi;
	const formatAbiItem_js_1$7 = formatAbiItem$2;
	function formatAbi(abi) {
	    const signatures = [];
	    const length = abi.length;
	    for (let i = 0; i < length; i++) {
	        const abiItem = abi[i];
	        const signature = (0, formatAbiItem_js_1$7.formatAbiItem)(abiItem);
	        signatures.push(signature);
	    }
	    return signatures;
	}

	var parseAbi$1 = {};

	var signatures = {};

	Object.defineProperty(signatures, "__esModule", { value: true });
	signatures.functionModifiers = signatures.eventModifiers = signatures.modifiers = void 0;
	signatures.isErrorSignature = isErrorSignature;
	signatures.execErrorSignature = execErrorSignature;
	signatures.isEventSignature = isEventSignature;
	signatures.execEventSignature = execEventSignature;
	signatures.isFunctionSignature = isFunctionSignature;
	signatures.execFunctionSignature = execFunctionSignature;
	signatures.isStructSignature = isStructSignature;
	signatures.execStructSignature = execStructSignature;
	signatures.isConstructorSignature = isConstructorSignature;
	signatures.execConstructorSignature = execConstructorSignature;
	signatures.isFallbackSignature = isFallbackSignature;
	signatures.isReceiveSignature = isReceiveSignature;
	const regex_js_1$3 = regex$1;
	const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
	function isErrorSignature(signature) {
	    return errorSignatureRegex.test(signature);
	}
	function execErrorSignature(signature) {
	    return (0, regex_js_1$3.execTyped)(errorSignatureRegex, signature);
	}
	const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
	function isEventSignature(signature) {
	    return eventSignatureRegex.test(signature);
	}
	function execEventSignature(signature) {
	    return (0, regex_js_1$3.execTyped)(eventSignatureRegex, signature);
	}
	const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
	function isFunctionSignature(signature) {
	    return functionSignatureRegex.test(signature);
	}
	function execFunctionSignature(signature) {
	    return (0, regex_js_1$3.execTyped)(functionSignatureRegex, signature);
	}
	const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
	function isStructSignature(signature) {
	    return structSignatureRegex.test(signature);
	}
	function execStructSignature(signature) {
	    return (0, regex_js_1$3.execTyped)(structSignatureRegex, signature);
	}
	const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
	function isConstructorSignature(signature) {
	    return constructorSignatureRegex.test(signature);
	}
	function execConstructorSignature(signature) {
	    return (0, regex_js_1$3.execTyped)(constructorSignatureRegex, signature);
	}
	const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
	function isFallbackSignature(signature) {
	    return fallbackSignatureRegex.test(signature);
	}
	const receiveSignatureRegex = /^receive\(\) external payable$/;
	function isReceiveSignature(signature) {
	    return receiveSignatureRegex.test(signature);
	}
	signatures.modifiers = new Set([
	    'memory',
	    'indexed',
	    'storage',
	    'calldata',
	]);
	signatures.eventModifiers = new Set(['indexed']);
	signatures.functionModifiers = new Set([
	    'calldata',
	    'memory',
	    'storage',
	]);

	var structs = {};

	var abiItem = {};

	Object.defineProperty(abiItem, "__esModule", { value: true });
	abiItem.UnknownSolidityTypeError = abiItem.UnknownTypeError = abiItem.InvalidAbiItemError = void 0;
	const errors_js_1$7 = errors$1;
	class InvalidAbiItemError extends errors_js_1$7.BaseError {
	    constructor({ signature }) {
	        super('Failed to parse ABI item.', {
	            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
	            docsPath: '/api/human#parseabiitem-1',
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidAbiItemError'
	        });
	    }
	}
	abiItem.InvalidAbiItemError = InvalidAbiItemError;
	class UnknownTypeError extends errors_js_1$7.BaseError {
	    constructor({ type }) {
	        super('Unknown type.', {
	            metaMessages: [
	                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
	            ],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'UnknownTypeError'
	        });
	    }
	}
	abiItem.UnknownTypeError = UnknownTypeError;
	class UnknownSolidityTypeError extends errors_js_1$7.BaseError {
	    constructor({ type }) {
	        super('Unknown type.', {
	            metaMessages: [`Type "${type}" is not a valid ABI type.`],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'UnknownSolidityTypeError'
	        });
	    }
	}
	abiItem.UnknownSolidityTypeError = UnknownSolidityTypeError;

	var abiParameter = {};

	Object.defineProperty(abiParameter, "__esModule", { value: true });
	abiParameter.InvalidAbiTypeParameterError = abiParameter.InvalidFunctionModifierError = abiParameter.InvalidModifierError = abiParameter.SolidityProtectedKeywordError = abiParameter.InvalidParameterError = abiParameter.InvalidAbiParametersError = abiParameter.InvalidAbiParameterError = void 0;
	const errors_js_1$6 = errors$1;
	class InvalidAbiParameterError extends errors_js_1$6.BaseError {
	    constructor({ param }) {
	        super('Failed to parse ABI parameter.', {
	            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
	            docsPath: '/api/human#parseabiparameter-1',
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidAbiParameterError'
	        });
	    }
	}
	abiParameter.InvalidAbiParameterError = InvalidAbiParameterError;
	class InvalidAbiParametersError extends errors_js_1$6.BaseError {
	    constructor({ params }) {
	        super('Failed to parse ABI parameters.', {
	            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
	            docsPath: '/api/human#parseabiparameters-1',
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidAbiParametersError'
	        });
	    }
	}
	abiParameter.InvalidAbiParametersError = InvalidAbiParametersError;
	class InvalidParameterError extends errors_js_1$6.BaseError {
	    constructor({ param }) {
	        super('Invalid ABI parameter.', {
	            details: param,
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidParameterError'
	        });
	    }
	}
	abiParameter.InvalidParameterError = InvalidParameterError;
	class SolidityProtectedKeywordError extends errors_js_1$6.BaseError {
	    constructor({ param, name }) {
	        super('Invalid ABI parameter.', {
	            details: param,
	            metaMessages: [
	                `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
	            ],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'SolidityProtectedKeywordError'
	        });
	    }
	}
	abiParameter.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
	class InvalidModifierError extends errors_js_1$6.BaseError {
	    constructor({ param, type, modifier, }) {
	        super('Invalid ABI parameter.', {
	            details: param,
	            metaMessages: [
	                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
	            ],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidModifierError'
	        });
	    }
	}
	abiParameter.InvalidModifierError = InvalidModifierError;
	class InvalidFunctionModifierError extends errors_js_1$6.BaseError {
	    constructor({ param, type, modifier, }) {
	        super('Invalid ABI parameter.', {
	            details: param,
	            metaMessages: [
	                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
	                `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`,
	            ],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidFunctionModifierError'
	        });
	    }
	}
	abiParameter.InvalidFunctionModifierError = InvalidFunctionModifierError;
	class InvalidAbiTypeParameterError extends errors_js_1$6.BaseError {
	    constructor({ abiParameter, }) {
	        super('Invalid ABI parameter.', {
	            details: JSON.stringify(abiParameter, null, 2),
	            metaMessages: ['ABI parameter type is invalid.'],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidAbiTypeParameterError'
	        });
	    }
	}
	abiParameter.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;

	var signature = {};

	Object.defineProperty(signature, "__esModule", { value: true });
	signature.InvalidStructSignatureError = signature.UnknownSignatureError = signature.InvalidSignatureError = void 0;
	const errors_js_1$5 = errors$1;
	class InvalidSignatureError extends errors_js_1$5.BaseError {
	    constructor({ signature, type, }) {
	        super(`Invalid ${type} signature.`, {
	            details: signature,
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidSignatureError'
	        });
	    }
	}
	signature.InvalidSignatureError = InvalidSignatureError;
	class UnknownSignatureError extends errors_js_1$5.BaseError {
	    constructor({ signature }) {
	        super('Unknown signature.', {
	            details: signature,
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'UnknownSignatureError'
	        });
	    }
	}
	signature.UnknownSignatureError = UnknownSignatureError;
	class InvalidStructSignatureError extends errors_js_1$5.BaseError {
	    constructor({ signature }) {
	        super('Invalid struct signature.', {
	            details: signature,
	            metaMessages: ['No properties exist.'],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidStructSignatureError'
	        });
	    }
	}
	signature.InvalidStructSignatureError = InvalidStructSignatureError;

	var struct = {};

	Object.defineProperty(struct, "__esModule", { value: true });
	struct.CircularReferenceError = void 0;
	const errors_js_1$4 = errors$1;
	class CircularReferenceError extends errors_js_1$4.BaseError {
	    constructor({ type }) {
	        super('Circular reference detected.', {
	            metaMessages: [`Struct "${type}" is a circular reference.`],
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'CircularReferenceError'
	        });
	    }
	}
	struct.CircularReferenceError = CircularReferenceError;

	var utils$6 = {};

	var splitParameters$1 = {};

	Object.defineProperty(splitParameters$1, "__esModule", { value: true });
	splitParameters$1.InvalidParenthesisError = void 0;
	const errors_js_1$3 = errors$1;
	class InvalidParenthesisError extends errors_js_1$3.BaseError {
	    constructor({ current, depth }) {
	        super('Unbalanced parentheses.', {
	            metaMessages: [
	                `"${current.trim()}" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,
	            ],
	            details: `Depth "${depth}"`,
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'InvalidParenthesisError'
	        });
	    }
	}
	splitParameters$1.InvalidParenthesisError = InvalidParenthesisError;

	var cache$1 = {};

	Object.defineProperty(cache$1, "__esModule", { value: true });
	cache$1.parameterCache = void 0;
	cache$1.getParameterCacheKey = getParameterCacheKey;
	function getParameterCacheKey(param, type) {
	    if (type)
	        return `${type}:${param}`;
	    return param;
	}
	cache$1.parameterCache = new Map([
	    ['address', { type: 'address' }],
	    ['bool', { type: 'bool' }],
	    ['bytes', { type: 'bytes' }],
	    ['bytes32', { type: 'bytes32' }],
	    ['int', { type: 'int256' }],
	    ['int256', { type: 'int256' }],
	    ['string', { type: 'string' }],
	    ['uint', { type: 'uint256' }],
	    ['uint8', { type: 'uint8' }],
	    ['uint16', { type: 'uint16' }],
	    ['uint24', { type: 'uint24' }],
	    ['uint32', { type: 'uint32' }],
	    ['uint64', { type: 'uint64' }],
	    ['uint96', { type: 'uint96' }],
	    ['uint112', { type: 'uint112' }],
	    ['uint160', { type: 'uint160' }],
	    ['uint192', { type: 'uint192' }],
	    ['uint256', { type: 'uint256' }],
	    ['address owner', { type: 'address', name: 'owner' }],
	    ['address to', { type: 'address', name: 'to' }],
	    ['bool approved', { type: 'bool', name: 'approved' }],
	    ['bytes _data', { type: 'bytes', name: '_data' }],
	    ['bytes data', { type: 'bytes', name: 'data' }],
	    ['bytes signature', { type: 'bytes', name: 'signature' }],
	    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],
	    ['bytes32 r', { type: 'bytes32', name: 'r' }],
	    ['bytes32 root', { type: 'bytes32', name: 'root' }],
	    ['bytes32 s', { type: 'bytes32', name: 's' }],
	    ['string name', { type: 'string', name: 'name' }],
	    ['string symbol', { type: 'string', name: 'symbol' }],
	    ['string tokenURI', { type: 'string', name: 'tokenURI' }],
	    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],
	    ['uint8 v', { type: 'uint8', name: 'v' }],
	    ['uint256 balance', { type: 'uint256', name: 'balance' }],
	    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],
	    ['uint256 value', { type: 'uint256', name: 'value' }],
	    [
	        'event:address indexed from',
	        { type: 'address', name: 'from', indexed: true },
	    ],
	    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],
	    [
	        'event:uint indexed tokenId',
	        { type: 'uint256', name: 'tokenId', indexed: true },
	    ],
	    [
	        'event:uint256 indexed tokenId',
	        { type: 'uint256', name: 'tokenId', indexed: true },
	    ],
	]);

	Object.defineProperty(utils$6, "__esModule", { value: true });
	utils$6.parseSignature = parseSignature$2;
	utils$6.parseAbiParameter = parseAbiParameter$2;
	utils$6.splitParameters = splitParameters;
	utils$6.isSolidityType = isSolidityType;
	utils$6.isSolidityKeyword = isSolidityKeyword;
	utils$6.isValidDataLocation = isValidDataLocation;
	const regex_js_1$2 = regex$1;
	const abiItem_js_1$2 = abiItem;
	const abiParameter_js_1$3 = abiParameter;
	const signature_js_1$1 = signature;
	const splitParameters_js_1 = splitParameters$1;
	const cache_js_1 = cache$1;
	const signatures_js_1$5 = signatures;
	function parseSignature$2(signature, structs = {}) {
	    if ((0, signatures_js_1$5.isFunctionSignature)(signature)) {
	        const match = (0, signatures_js_1$5.execFunctionSignature)(signature);
	        if (!match)
	            throw new signature_js_1$1.InvalidSignatureError({ signature, type: 'function' });
	        const inputParams = splitParameters(match.parameters);
	        const inputs = [];
	        const inputLength = inputParams.length;
	        for (let i = 0; i < inputLength; i++) {
	            inputs.push(parseAbiParameter$2(inputParams[i], {
	                modifiers: signatures_js_1$5.functionModifiers,
	                structs,
	                type: 'function',
	            }));
	        }
	        const outputs = [];
	        if (match.returns) {
	            const outputParams = splitParameters(match.returns);
	            const outputLength = outputParams.length;
	            for (let i = 0; i < outputLength; i++) {
	                outputs.push(parseAbiParameter$2(outputParams[i], {
	                    modifiers: signatures_js_1$5.functionModifiers,
	                    structs,
	                    type: 'function',
	                }));
	            }
	        }
	        return {
	            name: match.name,
	            type: 'function',
	            stateMutability: match.stateMutability ?? 'nonpayable',
	            inputs,
	            outputs,
	        };
	    }
	    if ((0, signatures_js_1$5.isEventSignature)(signature)) {
	        const match = (0, signatures_js_1$5.execEventSignature)(signature);
	        if (!match)
	            throw new signature_js_1$1.InvalidSignatureError({ signature, type: 'event' });
	        const params = splitParameters(match.parameters);
	        const abiParameters = [];
	        const length = params.length;
	        for (let i = 0; i < length; i++) {
	            abiParameters.push(parseAbiParameter$2(params[i], {
	                modifiers: signatures_js_1$5.eventModifiers,
	                structs,
	                type: 'event',
	            }));
	        }
	        return { name: match.name, type: 'event', inputs: abiParameters };
	    }
	    if ((0, signatures_js_1$5.isErrorSignature)(signature)) {
	        const match = (0, signatures_js_1$5.execErrorSignature)(signature);
	        if (!match)
	            throw new signature_js_1$1.InvalidSignatureError({ signature, type: 'error' });
	        const params = splitParameters(match.parameters);
	        const abiParameters = [];
	        const length = params.length;
	        for (let i = 0; i < length; i++) {
	            abiParameters.push(parseAbiParameter$2(params[i], { structs, type: 'error' }));
	        }
	        return { name: match.name, type: 'error', inputs: abiParameters };
	    }
	    if ((0, signatures_js_1$5.isConstructorSignature)(signature)) {
	        const match = (0, signatures_js_1$5.execConstructorSignature)(signature);
	        if (!match)
	            throw new signature_js_1$1.InvalidSignatureError({ signature, type: 'constructor' });
	        const params = splitParameters(match.parameters);
	        const abiParameters = [];
	        const length = params.length;
	        for (let i = 0; i < length; i++) {
	            abiParameters.push(parseAbiParameter$2(params[i], { structs, type: 'constructor' }));
	        }
	        return {
	            type: 'constructor',
	            stateMutability: match.stateMutability ?? 'nonpayable',
	            inputs: abiParameters,
	        };
	    }
	    if ((0, signatures_js_1$5.isFallbackSignature)(signature))
	        return { type: 'fallback' };
	    if ((0, signatures_js_1$5.isReceiveSignature)(signature))
	        return {
	            type: 'receive',
	            stateMutability: 'payable',
	        };
	    throw new signature_js_1$1.UnknownSignatureError({ signature });
	}
	const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
	const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
	const dynamicIntegerRegex = /^u?int$/;
	function parseAbiParameter$2(param, options) {
	    const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
	    if (cache_js_1.parameterCache.has(parameterCacheKey))
	        return cache_js_1.parameterCache.get(parameterCacheKey);
	    const isTuple = regex_js_1$2.isTupleRegex.test(param);
	    const match = (0, regex_js_1$2.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
	    if (!match)
	        throw new abiParameter_js_1$3.InvalidParameterError({ param });
	    if (match.name && isSolidityKeyword(match.name))
	        throw new abiParameter_js_1$3.SolidityProtectedKeywordError({ param, name: match.name });
	    const name = match.name ? { name: match.name } : {};
	    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};
	    const structs = options?.structs ?? {};
	    let type;
	    let components = {};
	    if (isTuple) {
	        type = 'tuple';
	        const params = splitParameters(match.type);
	        const components_ = [];
	        const length = params.length;
	        for (let i = 0; i < length; i++) {
	            components_.push(parseAbiParameter$2(params[i], { structs }));
	        }
	        components = { components: components_ };
	    }
	    else if (match.type in structs) {
	        type = 'tuple';
	        components = { components: structs[match.type] };
	    }
	    else if (dynamicIntegerRegex.test(match.type)) {
	        type = `${match.type}256`;
	    }
	    else {
	        type = match.type;
	        if (!(options?.type === 'struct') && !isSolidityType(type))
	            throw new abiItem_js_1$2.UnknownSolidityTypeError({ type });
	    }
	    if (match.modifier) {
	        if (!options?.modifiers?.has?.(match.modifier))
	            throw new abiParameter_js_1$3.InvalidModifierError({
	                param,
	                type: options?.type,
	                modifier: match.modifier,
	            });
	        if (signatures_js_1$5.functionModifiers.has(match.modifier) &&
	            !isValidDataLocation(type, !!match.array))
	            throw new abiParameter_js_1$3.InvalidFunctionModifierError({
	                param,
	                type: options?.type,
	                modifier: match.modifier,
	            });
	    }
	    const abiParameter = {
	        type: `${type}${match.array ?? ''}`,
	        ...name,
	        ...indexed,
	        ...components,
	    };
	    cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
	    return abiParameter;
	}
	function splitParameters(params, result = [], current = '', depth = 0) {
	    const length = params.trim().length;
	    for (let i = 0; i < length; i++) {
	        const char = params[i];
	        const tail = params.slice(i + 1);
	        switch (char) {
	            case ',':
	                return depth === 0
	                    ? splitParameters(tail, [...result, current.trim()])
	                    : splitParameters(tail, result, `${current}${char}`, depth);
	            case '(':
	                return splitParameters(tail, result, `${current}${char}`, depth + 1);
	            case ')':
	                return splitParameters(tail, result, `${current}${char}`, depth - 1);
	            default:
	                return splitParameters(tail, result, `${current}${char}`, depth);
	        }
	    }
	    if (current === '')
	        return result;
	    if (depth !== 0)
	        throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
	    result.push(current.trim());
	    return result;
	}
	function isSolidityType(type) {
	    return (type === 'address' ||
	        type === 'bool' ||
	        type === 'function' ||
	        type === 'string' ||
	        regex_js_1$2.bytesRegex.test(type) ||
	        regex_js_1$2.integerRegex.test(type));
	}
	const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
	function isSolidityKeyword(name) {
	    return (name === 'address' ||
	        name === 'bool' ||
	        name === 'function' ||
	        name === 'string' ||
	        name === 'tuple' ||
	        regex_js_1$2.bytesRegex.test(name) ||
	        regex_js_1$2.integerRegex.test(name) ||
	        protectedKeywordsRegex.test(name));
	}
	function isValidDataLocation(type, isArray) {
	    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';
	}

	Object.defineProperty(structs, "__esModule", { value: true });
	structs.parseStructs = parseStructs;
	const regex_js_1$1 = regex$1;
	const abiItem_js_1$1 = abiItem;
	const abiParameter_js_1$2 = abiParameter;
	const signature_js_1 = signature;
	const struct_js_1 = struct;
	const signatures_js_1$4 = signatures;
	const utils_js_1$p = utils$6;
	function parseStructs(signatures) {
	    const shallowStructs = {};
	    const signaturesLength = signatures.length;
	    for (let i = 0; i < signaturesLength; i++) {
	        const signature = signatures[i];
	        if (!(0, signatures_js_1$4.isStructSignature)(signature))
	            continue;
	        const match = (0, signatures_js_1$4.execStructSignature)(signature);
	        if (!match)
	            throw new signature_js_1.InvalidSignatureError({ signature, type: 'struct' });
	        const properties = match.properties.split(';');
	        const components = [];
	        const propertiesLength = properties.length;
	        for (let k = 0; k < propertiesLength; k++) {
	            const property = properties[k];
	            const trimmed = property.trim();
	            if (!trimmed)
	                continue;
	            const abiParameter = (0, utils_js_1$p.parseAbiParameter)(trimmed, {
	                type: 'struct',
	            });
	            components.push(abiParameter);
	        }
	        if (!components.length)
	            throw new signature_js_1.InvalidStructSignatureError({ signature });
	        shallowStructs[match.name] = components;
	    }
	    const resolvedStructs = {};
	    const entries = Object.entries(shallowStructs);
	    const entriesLength = entries.length;
	    for (let i = 0; i < entriesLength; i++) {
	        const [name, parameters] = entries[i];
	        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
	    }
	    return resolvedStructs;
	}
	const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
	function resolveStructs(abiParameters, structs, ancestors = new Set()) {
	    const components = [];
	    const length = abiParameters.length;
	    for (let i = 0; i < length; i++) {
	        const abiParameter = abiParameters[i];
	        const isTuple = regex_js_1$1.isTupleRegex.test(abiParameter.type);
	        if (isTuple)
	            components.push(abiParameter);
	        else {
	            const match = (0, regex_js_1$1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
	            if (!match?.type)
	                throw new abiParameter_js_1$2.InvalidAbiTypeParameterError({ abiParameter });
	            const { array, type } = match;
	            if (type in structs) {
	                if (ancestors.has(type))
	                    throw new struct_js_1.CircularReferenceError({ type });
	                components.push({
	                    ...abiParameter,
	                    type: `tuple${array ?? ''}`,
	                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),
	                });
	            }
	            else {
	                if ((0, utils_js_1$p.isSolidityType)(type))
	                    components.push(abiParameter);
	                else
	                    throw new abiItem_js_1$1.UnknownTypeError({ type });
	            }
	        }
	    }
	    return components;
	}

	Object.defineProperty(parseAbi$1, "__esModule", { value: true });
	parseAbi$1.parseAbi = parseAbi;
	const signatures_js_1$3 = signatures;
	const structs_js_1$3 = structs;
	const utils_js_1$o = utils$6;
	function parseAbi(signatures) {
	    const structs = (0, structs_js_1$3.parseStructs)(signatures);
	    const abi = [];
	    const length = signatures.length;
	    for (let i = 0; i < length; i++) {
	        const signature = signatures[i];
	        if ((0, signatures_js_1$3.isStructSignature)(signature))
	            continue;
	        abi.push((0, utils_js_1$o.parseSignature)(signature, structs));
	    }
	    return abi;
	}

	var parseAbiItem$1 = {};

	Object.defineProperty(parseAbiItem$1, "__esModule", { value: true });
	parseAbiItem$1.parseAbiItem = parseAbiItem;
	const abiItem_js_1 = abiItem;
	const signatures_js_1$2 = signatures;
	const structs_js_1$2 = structs;
	const utils_js_1$n = utils$6;
	function parseAbiItem(signature) {
	    let abiItem;
	    if (typeof signature === 'string')
	        abiItem = (0, utils_js_1$n.parseSignature)(signature);
	    else {
	        const structs = (0, structs_js_1$2.parseStructs)(signature);
	        const length = signature.length;
	        for (let i = 0; i < length; i++) {
	            const signature_ = signature[i];
	            if ((0, signatures_js_1$2.isStructSignature)(signature_))
	                continue;
	            abiItem = (0, utils_js_1$n.parseSignature)(signature_, structs);
	            break;
	        }
	    }
	    if (!abiItem)
	        throw new abiItem_js_1.InvalidAbiItemError({ signature });
	    return abiItem;
	}

	var parseAbiParameter$1 = {};

	Object.defineProperty(parseAbiParameter$1, "__esModule", { value: true });
	parseAbiParameter$1.parseAbiParameter = parseAbiParameter;
	const abiParameter_js_1$1 = abiParameter;
	const signatures_js_1$1 = signatures;
	const structs_js_1$1 = structs;
	const utils_js_1$m = utils$6;
	function parseAbiParameter(param) {
	    let abiParameter;
	    if (typeof param === 'string')
	        abiParameter = (0, utils_js_1$m.parseAbiParameter)(param, {
	            modifiers: signatures_js_1$1.modifiers,
	        });
	    else {
	        const structs = (0, structs_js_1$1.parseStructs)(param);
	        const length = param.length;
	        for (let i = 0; i < length; i++) {
	            const signature = param[i];
	            if ((0, signatures_js_1$1.isStructSignature)(signature))
	                continue;
	            abiParameter = (0, utils_js_1$m.parseAbiParameter)(signature, { modifiers: signatures_js_1$1.modifiers, structs });
	            break;
	        }
	    }
	    if (!abiParameter)
	        throw new abiParameter_js_1$1.InvalidAbiParameterError({ param });
	    return abiParameter;
	}

	var parseAbiParameters$1 = {};

	Object.defineProperty(parseAbiParameters$1, "__esModule", { value: true });
	parseAbiParameters$1.parseAbiParameters = parseAbiParameters;
	const abiParameter_js_1 = abiParameter;
	const signatures_js_1 = signatures;
	const structs_js_1 = structs;
	const utils_js_1$l = utils$6;
	const utils_js_2 = utils$6;
	function parseAbiParameters(params) {
	    const abiParameters = [];
	    if (typeof params === 'string') {
	        const parameters = (0, utils_js_1$l.splitParameters)(params);
	        const length = parameters.length;
	        for (let i = 0; i < length; i++) {
	            abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], { modifiers: signatures_js_1.modifiers }));
	        }
	    }
	    else {
	        const structs = (0, structs_js_1.parseStructs)(params);
	        const length = params.length;
	        for (let i = 0; i < length; i++) {
	            const signature = params[i];
	            if ((0, signatures_js_1.isStructSignature)(signature))
	                continue;
	            const parameters = (0, utils_js_1$l.splitParameters)(signature);
	            const length = parameters.length;
	            for (let k = 0; k < length; k++) {
	                abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], { modifiers: signatures_js_1.modifiers, structs }));
	            }
	        }
	    }
	    if (abiParameters.length === 0)
	        throw new abiParameter_js_1.InvalidAbiParametersError({ params });
	    return abiParameters;
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = void 0;
		var errors_js_1 = errors$1;
		Object.defineProperty(exports, "BaseError", { enumerable: true, get: function () { return errors_js_1.BaseError; } });
		var narrow_js_1 = narrow$1;
		Object.defineProperty(exports, "narrow", { enumerable: true, get: function () { return narrow_js_1.narrow; } });
		var formatAbi_js_1 = formatAbi$1;
		Object.defineProperty(exports, "formatAbi", { enumerable: true, get: function () { return formatAbi_js_1.formatAbi; } });
		var formatAbiItem_js_1 = formatAbiItem$2;
		Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiItem; } });
		var formatAbiParameter_js_1 = formatAbiParameter$1;
		Object.defineProperty(exports, "formatAbiParameter", { enumerable: true, get: function () { return formatAbiParameter_js_1.formatAbiParameter; } });
		var formatAbiParameters_js_1 = formatAbiParameters$1;
		Object.defineProperty(exports, "formatAbiParameters", { enumerable: true, get: function () { return formatAbiParameters_js_1.formatAbiParameters; } });
		var parseAbi_js_1 = parseAbi$1;
		Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function () { return parseAbi_js_1.parseAbi; } });
		var parseAbiItem_js_1 = parseAbiItem$1;
		Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function () { return parseAbiItem_js_1.parseAbiItem; } });
		var parseAbiParameter_js_1 = parseAbiParameter$1;
		Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function () { return parseAbiParameter_js_1.parseAbiParameter; } });
		var parseAbiParameters_js_1 = parseAbiParameters$1;
		Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function () { return parseAbiParameters_js_1.parseAbiParameters; } });
		var abiItem_js_1 = abiItem;
		Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function () { return abiItem_js_1.UnknownTypeError; } });
		Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function () { return abiItem_js_1.InvalidAbiItemError; } });
		Object.defineProperty(exports, "UnknownSolidityTypeError", { enumerable: true, get: function () { return abiItem_js_1.UnknownSolidityTypeError; } });
		var abiParameter_js_1 = abiParameter;
		Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiTypeParameterError; } });
		Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function () { return abiParameter_js_1.InvalidFunctionModifierError; } });
		Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function () { return abiParameter_js_1.InvalidModifierError; } });
		Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function () { return abiParameter_js_1.SolidityProtectedKeywordError; } });
		Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function () { return abiParameter_js_1.InvalidParameterError; } });
		Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiParametersError; } });
		Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiParameterError; } });
		var signature_js_1 = signature;
		Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function () { return signature_js_1.InvalidStructSignatureError; } });
		Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function () { return signature_js_1.InvalidSignatureError; } });
		Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function () { return signature_js_1.UnknownSignatureError; } });
		var splitParameters_js_1 = splitParameters$1;
		Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function () { return splitParameters_js_1.InvalidParenthesisError; } });
		var struct_js_1 = struct;
		Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function () { return struct_js_1.CircularReferenceError; } });
		
	} (exports$1));

	var getContract$2 = {};

	var getAction$1 = {};

	Object.defineProperty(getAction$1, "__esModule", { value: true });
	getAction$1.getAction = getAction;
	function getAction(client, actionFn, name) {
	    const action_implicit = client[actionFn.name];
	    if (typeof action_implicit === 'function')
	        return action_implicit;
	    const action_explicit = client[name];
	    if (typeof action_explicit === 'function')
	        return action_explicit;
	    return (params) => actionFn(client, params);
	}

	var createContractEventFilter$1 = {};

	var encodeEventTopics$1 = {};

	var abi$1 = {};

	var formatAbiItem = {};

	var hasRequiredFormatAbiItem;

	function requireFormatAbiItem () {
		if (hasRequiredFormatAbiItem) return formatAbiItem;
		hasRequiredFormatAbiItem = 1;
		Object.defineProperty(formatAbiItem, "__esModule", { value: true });
		formatAbiItem.formatAbiItem = formatAbiItem$1;
		formatAbiItem.formatAbiParams = formatAbiParams;
		const abi_js_1 = requireAbi();
		function formatAbiItem$1(abiItem, { includeName = false } = {}) {
		    if (abiItem.type !== 'function' &&
		        abiItem.type !== 'event' &&
		        abiItem.type !== 'error')
		        throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
		    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
		}
		function formatAbiParams(params, { includeName = false } = {}) {
		    if (!params)
		        return '';
		    return params
		        .map((param) => formatAbiParam(param, { includeName }))
		        .join(includeName ? ', ' : ',');
		}
		function formatAbiParam(param, { includeName }) {
		    if (param.type.startsWith('tuple')) {
		        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;
		    }
		    return param.type + (includeName && param.name ? ` ${param.name}` : '');
		}
		
		return formatAbiItem;
	}

	var size$2 = {};

	var isHex$1 = {};

	Object.defineProperty(isHex$1, "__esModule", { value: true });
	isHex$1.isHex = isHex;
	function isHex(value, { strict = true } = {}) {
	    if (!value)
	        return false;
	    if (typeof value !== 'string')
	        return false;
	    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
	}

	Object.defineProperty(size$2, "__esModule", { value: true });
	size$2.size = size$1;
	const isHex_js_1$b = isHex$1;
	function size$1(value) {
	    if ((0, isHex_js_1$b.isHex)(value, { strict: false }))
	        return Math.ceil((value.length - 2) / 2);
	    return value.length;
	}

	var base$1 = {};

	var version = {};

	Object.defineProperty(version, "__esModule", { value: true });
	version.version = void 0;
	version.version = '2.21.1';

	Object.defineProperty(base$1, "__esModule", { value: true });
	base$1.BaseError = void 0;
	base$1.setErrorConfig = setErrorConfig;
	const version_js_1 = version;
	let errorConfig = {
	    getDocsUrl: ({ docsBaseUrl, docsPath = '', docsSlug, }) => docsPath
	        ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}`
	        : undefined,
	    version: version_js_1.version,
	};
	function setErrorConfig(config) {
	    errorConfig = config;
	}
	class BaseError extends Error {
	    constructor(shortMessage, args = {}) {
	        const details = (() => {
	            if (args.cause instanceof BaseError)
	                return args.cause.details;
	            if (args.cause?.message)
	                return args.cause.message;
	            return args.details;
	        })();
	        const docsPath = (() => {
	            if (args.cause instanceof BaseError)
	                return args.cause.docsPath || args.docsPath;
	            return args.docsPath;
	        })();
	        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
	        const message = [
	            shortMessage || 'An error occurred.',
	            '',
	            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
	            ...(docsUrl ? [`Docs: ${docsUrl}`] : []),
	            ...(details ? [`Details: ${details}`] : []),
	            ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),
	        ].join('\n');
	        super(message, args.cause ? { cause: args.cause } : undefined);
	        Object.defineProperty(this, "details", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "docsPath", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "metaMessages", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "shortMessage", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "version", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'BaseError'
	        });
	        this.details = details;
	        this.docsPath = docsPath;
	        this.metaMessages = args.metaMessages;
	        this.name = args.name ?? this.name;
	        this.shortMessage = shortMessage;
	        this.version = version_js_1.version;
	    }
	    walk(fn) {
	        return walk(this, fn);
	    }
	}
	base$1.BaseError = BaseError;
	function walk(err, fn) {
	    if (fn?.(err))
	        return err;
	    if (err && typeof err === 'object' && 'cause' in err)
	        return walk(err.cause, fn);
	    return fn ? null : err;
	}

	var hasRequiredAbi;

	function requireAbi () {
		if (hasRequiredAbi) return abi$1;
		hasRequiredAbi = 1;
		Object.defineProperty(abi$1, "__esModule", { value: true });
		abi$1.UnsupportedPackedAbiType = abi$1.InvalidDefinitionTypeError = abi$1.InvalidArrayError = abi$1.InvalidAbiDecodingTypeError = abi$1.InvalidAbiEncodingTypeError = abi$1.DecodeLogTopicsMismatch = abi$1.DecodeLogDataMismatch = abi$1.BytesSizeMismatchError = abi$1.AbiItemAmbiguityError = abi$1.AbiFunctionSignatureNotFoundError = abi$1.AbiFunctionOutputsNotFoundError = abi$1.AbiFunctionNotFoundError = abi$1.AbiEventNotFoundError = abi$1.AbiEventSignatureNotFoundError = abi$1.AbiEventSignatureEmptyTopicsError = abi$1.AbiErrorSignatureNotFoundError = abi$1.AbiErrorNotFoundError = abi$1.AbiErrorInputsNotFoundError = abi$1.AbiEncodingLengthMismatchError = abi$1.AbiEncodingBytesSizeMismatchError = abi$1.AbiEncodingArrayLengthMismatchError = abi$1.AbiDecodingZeroDataError = abi$1.AbiDecodingDataSizeTooSmallError = abi$1.AbiDecodingDataSizeInvalidError = abi$1.AbiConstructorParamsNotFoundError = abi$1.AbiConstructorNotFoundError = void 0;
		const formatAbiItem_js_1 = requireFormatAbiItem();
		const size_js_1 = size$2;
		const base_js_1 = base$1;
		class AbiConstructorNotFoundError extends base_js_1.BaseError {
		    constructor({ docsPath }) {
		        super([
		            'A constructor was not found on the ABI.',
		            'Make sure you are using the correct ABI and that the constructor exists on it.',
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiConstructorNotFoundError',
		        });
		    }
		}
		abi$1.AbiConstructorNotFoundError = AbiConstructorNotFoundError;
		class AbiConstructorParamsNotFoundError extends base_js_1.BaseError {
		    constructor({ docsPath }) {
		        super([
		            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
		            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiConstructorParamsNotFoundError',
		        });
		    }
		}
		abi$1.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError;
		class AbiDecodingDataSizeInvalidError extends base_js_1.BaseError {
		    constructor({ data, size }) {
		        super([
		            `Data size of ${size} bytes is invalid.`,
		            'Size must be in increments of 32 bytes (size % 32 === 0).',
		        ].join('\n'), {
		            metaMessages: [`Data: ${data} (${size} bytes)`],
		            name: 'AbiDecodingDataSizeInvalidError',
		        });
		    }
		}
		abi$1.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
		class AbiDecodingDataSizeTooSmallError extends base_js_1.BaseError {
		    constructor({ data, params, size, }) {
		        super([`Data size of ${size} bytes is too small for given parameters.`].join('\n'), {
		            metaMessages: [
		                `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
		                `Data:   ${data} (${size} bytes)`,
		            ],
		            name: 'AbiDecodingDataSizeTooSmallError',
		        });
		        Object.defineProperty(this, "data", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        Object.defineProperty(this, "params", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        Object.defineProperty(this, "size", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        this.data = data;
		        this.params = params;
		        this.size = size;
		    }
		}
		abi$1.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError;
		class AbiDecodingZeroDataError extends base_js_1.BaseError {
		    constructor() {
		        super('Cannot decode zero data ("0x") with ABI parameters.', {
		            name: 'AbiDecodingZeroDataError',
		        });
		    }
		}
		abi$1.AbiDecodingZeroDataError = AbiDecodingZeroDataError;
		class AbiEncodingArrayLengthMismatchError extends base_js_1.BaseError {
		    constructor({ expectedLength, givenLength, type, }) {
		        super([
		            `ABI encoding array length mismatch for type ${type}.`,
		            `Expected length: ${expectedLength}`,
		            `Given length: ${givenLength}`,
		        ].join('\n'), { name: 'AbiEncodingArrayLengthMismatchError' });
		    }
		}
		abi$1.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError;
		class AbiEncodingBytesSizeMismatchError extends base_js_1.BaseError {
		    constructor({ expectedSize, value }) {
		        super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`, { name: 'AbiEncodingBytesSizeMismatchError' });
		    }
		}
		abi$1.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError;
		class AbiEncodingLengthMismatchError extends base_js_1.BaseError {
		    constructor({ expectedLength, givenLength, }) {
		        super([
		            'ABI encoding params/values length mismatch.',
		            `Expected length (params): ${expectedLength}`,
		            `Given length (values): ${givenLength}`,
		        ].join('\n'), { name: 'AbiEncodingLengthMismatchError' });
		    }
		}
		abi$1.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError;
		class AbiErrorInputsNotFoundError extends base_js_1.BaseError {
		    constructor(errorName, { docsPath }) {
		        super([
		            `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
		            'Cannot encode error result without knowing what the parameter types are.',
		            'Make sure you are using the correct ABI and that the inputs exist on it.',
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiErrorInputsNotFoundError',
		        });
		    }
		}
		abi$1.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
		class AbiErrorNotFoundError extends base_js_1.BaseError {
		    constructor(errorName, { docsPath } = {}) {
		        super([
		            `Error ${errorName ? `"${errorName}" ` : ''}not found on ABI.`,
		            'Make sure you are using the correct ABI and that the error exists on it.',
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiErrorNotFoundError',
		        });
		    }
		}
		abi$1.AbiErrorNotFoundError = AbiErrorNotFoundError;
		class AbiErrorSignatureNotFoundError extends base_js_1.BaseError {
		    constructor(signature, { docsPath }) {
		        super([
		            `Encoded error signature "${signature}" not found on ABI.`,
		            'Make sure you are using the correct ABI and that the error exists on it.',
		            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiErrorSignatureNotFoundError',
		        });
		        Object.defineProperty(this, "signature", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        this.signature = signature;
		    }
		}
		abi$1.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError;
		class AbiEventSignatureEmptyTopicsError extends base_js_1.BaseError {
		    constructor({ docsPath }) {
		        super('Cannot extract event signature from empty topics.', {
		            docsPath,
		            name: 'AbiEventSignatureEmptyTopicsError',
		        });
		    }
		}
		abi$1.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError;
		class AbiEventSignatureNotFoundError extends base_js_1.BaseError {
		    constructor(signature, { docsPath }) {
		        super([
		            `Encoded event signature "${signature}" not found on ABI.`,
		            'Make sure you are using the correct ABI and that the event exists on it.',
		            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiEventSignatureNotFoundError',
		        });
		    }
		}
		abi$1.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError;
		class AbiEventNotFoundError extends base_js_1.BaseError {
		    constructor(eventName, { docsPath } = {}) {
		        super([
		            `Event ${eventName ? `"${eventName}" ` : ''}not found on ABI.`,
		            'Make sure you are using the correct ABI and that the event exists on it.',
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiEventNotFoundError',
		        });
		    }
		}
		abi$1.AbiEventNotFoundError = AbiEventNotFoundError;
		class AbiFunctionNotFoundError extends base_js_1.BaseError {
		    constructor(functionName, { docsPath } = {}) {
		        super([
		            `Function ${functionName ? `"${functionName}" ` : ''}not found on ABI.`,
		            'Make sure you are using the correct ABI and that the function exists on it.',
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiFunctionNotFoundError',
		        });
		    }
		}
		abi$1.AbiFunctionNotFoundError = AbiFunctionNotFoundError;
		class AbiFunctionOutputsNotFoundError extends base_js_1.BaseError {
		    constructor(functionName, { docsPath }) {
		        super([
		            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
		            'Cannot decode function result without knowing what the parameter types are.',
		            'Make sure you are using the correct ABI and that the function exists on it.',
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiFunctionOutputsNotFoundError',
		        });
		    }
		}
		abi$1.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError;
		class AbiFunctionSignatureNotFoundError extends base_js_1.BaseError {
		    constructor(signature, { docsPath }) {
		        super([
		            `Encoded function signature "${signature}" not found on ABI.`,
		            'Make sure you are using the correct ABI and that the function exists on it.',
		            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
		        ].join('\n'), {
		            docsPath,
		            name: 'AbiFunctionSignatureNotFoundError',
		        });
		    }
		}
		abi$1.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
		class AbiItemAmbiguityError extends base_js_1.BaseError {
		    constructor(x, y) {
		        super('Found ambiguous types in overloaded ABI items.', {
		            metaMessages: [
		                `\`${x.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(x.abiItem)}\`, and`,
		                `\`${y.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(y.abiItem)}\``,
		                '',
		                'These types encode differently and cannot be distinguished at runtime.',
		                'Remove one of the ambiguous items in the ABI.',
		            ],
		            name: 'AbiItemAmbiguityError',
		        });
		    }
		}
		abi$1.AbiItemAmbiguityError = AbiItemAmbiguityError;
		class BytesSizeMismatchError extends base_js_1.BaseError {
		    constructor({ expectedSize, givenSize, }) {
		        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
		            name: 'BytesSizeMismatchError',
		        });
		    }
		}
		abi$1.BytesSizeMismatchError = BytesSizeMismatchError;
		class DecodeLogDataMismatch extends base_js_1.BaseError {
		    constructor({ abiItem, data, params, size, }) {
		        super([
		            `Data size of ${size} bytes is too small for non-indexed event parameters.`,
		        ].join('\n'), {
		            metaMessages: [
		                `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
		                `Data:   ${data} (${size} bytes)`,
		            ],
		            name: 'DecodeLogDataMismatch',
		        });
		        Object.defineProperty(this, "abiItem", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        Object.defineProperty(this, "data", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        Object.defineProperty(this, "params", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        Object.defineProperty(this, "size", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        this.abiItem = abiItem;
		        this.data = data;
		        this.params = params;
		        this.size = size;
		    }
		}
		abi$1.DecodeLogDataMismatch = DecodeLogDataMismatch;
		class DecodeLogTopicsMismatch extends base_js_1.BaseError {
		    constructor({ abiItem, param, }) {
		        super([
		            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ''} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`,
		        ].join('\n'), { name: 'DecodeLogTopicsMismatch' });
		        Object.defineProperty(this, "abiItem", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        this.abiItem = abiItem;
		    }
		}
		abi$1.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch;
		class InvalidAbiEncodingTypeError extends base_js_1.BaseError {
		    constructor(type, { docsPath }) {
		        super([
		            `Type "${type}" is not a valid encoding type.`,
		            'Please provide a valid ABI type.',
		        ].join('\n'), { docsPath, name: 'InvalidAbiEncodingType' });
		    }
		}
		abi$1.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError;
		class InvalidAbiDecodingTypeError extends base_js_1.BaseError {
		    constructor(type, { docsPath }) {
		        super([
		            `Type "${type}" is not a valid decoding type.`,
		            'Please provide a valid ABI type.',
		        ].join('\n'), { docsPath, name: 'InvalidAbiDecodingType' });
		    }
		}
		abi$1.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError;
		class InvalidArrayError extends base_js_1.BaseError {
		    constructor(value) {
		        super([`Value "${value}" is not a valid array.`].join('\n'), {
		            name: 'InvalidArrayError',
		        });
		    }
		}
		abi$1.InvalidArrayError = InvalidArrayError;
		class InvalidDefinitionTypeError extends base_js_1.BaseError {
		    constructor(type) {
		        super([
		            `"${type}" is not a valid definition type.`,
		            'Valid types: "function", "event", "error"',
		        ].join('\n'), { name: 'InvalidDefinitionTypeError' });
		    }
		}
		abi$1.InvalidDefinitionTypeError = InvalidDefinitionTypeError;
		class UnsupportedPackedAbiType extends base_js_1.BaseError {
		    constructor(type) {
		        super(`Type "${type}" is not supported for packed encoding.`, {
		            name: 'UnsupportedPackedAbiType',
		        });
		    }
		}
		abi$1.UnsupportedPackedAbiType = UnsupportedPackedAbiType;
		
		return abi$1;
	}

	var log$1 = {};

	Object.defineProperty(log$1, "__esModule", { value: true });
	log$1.FilterTypeNotSupportedError = void 0;
	const base_js_1$w = base$1;
	class FilterTypeNotSupportedError extends base_js_1$w.BaseError {
	    constructor(type) {
	        super(`Filter type "${type}" is not supported.`, {
	            name: 'FilterTypeNotSupportedError',
	        });
	    }
	}
	log$1.FilterTypeNotSupportedError = FilterTypeNotSupportedError;

	var toBytes = {};

	var pad$1 = {};

	var data = {};

	Object.defineProperty(data, "__esModule", { value: true });
	data.InvalidBytesLengthError = data.SizeExceedsPaddingSizeError = data.SliceOffsetOutOfBoundsError = void 0;
	const base_js_1$v = base$1;
	class SliceOffsetOutOfBoundsError extends base_js_1$v.BaseError {
	    constructor({ offset, position, size, }) {
	        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`, { name: 'SliceOffsetOutOfBoundsError' });
	    }
	}
	data.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
	class SizeExceedsPaddingSizeError extends base_js_1$v.BaseError {
	    constructor({ size, targetSize, type, }) {
	        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, { name: 'SizeExceedsPaddingSizeError' });
	    }
	}
	data.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
	class InvalidBytesLengthError extends base_js_1$v.BaseError {
	    constructor({ size, targetSize, type, }) {
	        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`, { name: 'InvalidBytesLengthError' });
	    }
	}
	data.InvalidBytesLengthError = InvalidBytesLengthError;

	Object.defineProperty(pad$1, "__esModule", { value: true });
	pad$1.pad = pad;
	pad$1.padHex = padHex;
	pad$1.padBytes = padBytes;
	const data_js_1$2 = data;
	function pad(hexOrBytes, { dir, size = 32 } = {}) {
	    if (typeof hexOrBytes === 'string')
	        return padHex(hexOrBytes, { dir, size });
	    return padBytes(hexOrBytes, { dir, size });
	}
	function padHex(hex_, { dir, size = 32 } = {}) {
	    if (size === null)
	        return hex_;
	    const hex = hex_.replace('0x', '');
	    if (hex.length > size * 2)
	        throw new data_js_1$2.SizeExceedsPaddingSizeError({
	            size: Math.ceil(hex.length / 2),
	            targetSize: size,
	            type: 'hex',
	        });
	    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
	}
	function padBytes(bytes, { dir, size = 32 } = {}) {
	    if (size === null)
	        return bytes;
	    if (bytes.length > size)
	        throw new data_js_1$2.SizeExceedsPaddingSizeError({
	            size: bytes.length,
	            targetSize: size,
	            type: 'bytes',
	        });
	    const paddedBytes = new Uint8Array(size);
	    for (let i = 0; i < size; i++) {
	        const padEnd = dir === 'right';
	        paddedBytes[padEnd ? i : size - i - 1] =
	            bytes[padEnd ? i : bytes.length - i - 1];
	    }
	    return paddedBytes;
	}

	var fromHex = {};

	var encoding = {};

	Object.defineProperty(encoding, "__esModule", { value: true });
	encoding.SizeOverflowError = encoding.InvalidHexValueError = encoding.InvalidHexBooleanError = encoding.InvalidBytesBooleanError = encoding.IntegerOutOfRangeError = void 0;
	const base_js_1$u = base$1;
	class IntegerOutOfRangeError extends base_js_1$u.BaseError {
	    constructor({ max, min, signed, size, value, }) {
	        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: 'IntegerOutOfRangeError' });
	    }
	}
	encoding.IntegerOutOfRangeError = IntegerOutOfRangeError;
	class InvalidBytesBooleanError extends base_js_1$u.BaseError {
	    constructor(bytes) {
	        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
	            name: 'InvalidBytesBooleanError',
	        });
	    }
	}
	encoding.InvalidBytesBooleanError = InvalidBytesBooleanError;
	class InvalidHexBooleanError extends base_js_1$u.BaseError {
	    constructor(hex) {
	        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: 'InvalidHexBooleanError' });
	    }
	}
	encoding.InvalidHexBooleanError = InvalidHexBooleanError;
	class InvalidHexValueError extends base_js_1$u.BaseError {
	    constructor(value) {
	        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`, { name: 'InvalidHexValueError' });
	    }
	}
	encoding.InvalidHexValueError = InvalidHexValueError;
	class SizeOverflowError extends base_js_1$u.BaseError {
	    constructor({ givenSize, maxSize }) {
	        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: 'SizeOverflowError' });
	    }
	}
	encoding.SizeOverflowError = SizeOverflowError;

	var trim$3 = {};

	Object.defineProperty(trim$3, "__esModule", { value: true });
	trim$3.trim = trim$2;
	function trim$2(hexOrBytes, { dir = 'left' } = {}) {
	    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
	    let sliceLength = 0;
	    for (let i = 0; i < data.length - 1; i++) {
	        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')
	            sliceLength++;
	        else
	            break;
	    }
	    data =
	        dir === 'left'
	            ? data.slice(sliceLength)
	            : data.slice(0, data.length - sliceLength);
	    if (typeof hexOrBytes === 'string') {
	        if (data.length === 1 && dir === 'right')
	            data = `${data}0`;
	        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
	    }
	    return data;
	}

	var hasRequiredFromHex;

	function requireFromHex () {
		if (hasRequiredFromHex) return fromHex;
		hasRequiredFromHex = 1;
		Object.defineProperty(fromHex, "__esModule", { value: true });
		fromHex.assertSize = assertSize;
		fromHex.fromHex = fromHex$1;
		fromHex.hexToBigInt = hexToBigInt;
		fromHex.hexToBool = hexToBool;
		fromHex.hexToNumber = hexToNumber;
		fromHex.hexToString = hexToString;
		const encoding_js_1 = encoding;
		const size_js_1 = size$2;
		const trim_js_1 = trim$3;
		const toBytes_js_1 = requireToBytes();
		function assertSize(hexOrBytes, { size }) {
		    if ((0, size_js_1.size)(hexOrBytes) > size)
		        throw new encoding_js_1.SizeOverflowError({
		            givenSize: (0, size_js_1.size)(hexOrBytes),
		            maxSize: size,
		        });
		}
		function fromHex$1(hex, toOrOpts) {
		    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;
		    const to = opts.to;
		    if (to === 'number')
		        return hexToNumber(hex, opts);
		    if (to === 'bigint')
		        return hexToBigInt(hex, opts);
		    if (to === 'string')
		        return hexToString(hex, opts);
		    if (to === 'boolean')
		        return hexToBool(hex, opts);
		    return (0, toBytes_js_1.hexToBytes)(hex, opts);
		}
		function hexToBigInt(hex, opts = {}) {
		    const { signed } = opts;
		    if (opts.size)
		        assertSize(hex, { size: opts.size });
		    const value = BigInt(hex);
		    if (!signed)
		        return value;
		    const size = (hex.length - 2) / 2;
		    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
		    if (value <= max)
		        return value;
		    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
		}
		function hexToBool(hex_, opts = {}) {
		    let hex = hex_;
		    if (opts.size) {
		        assertSize(hex, { size: opts.size });
		        hex = (0, trim_js_1.trim)(hex);
		    }
		    if ((0, trim_js_1.trim)(hex) === '0x00')
		        return false;
		    if ((0, trim_js_1.trim)(hex) === '0x01')
		        return true;
		    throw new encoding_js_1.InvalidHexBooleanError(hex);
		}
		function hexToNumber(hex, opts = {}) {
		    return Number(hexToBigInt(hex, opts));
		}
		function hexToString(hex, opts = {}) {
		    let bytes = (0, toBytes_js_1.hexToBytes)(hex);
		    if (opts.size) {
		        assertSize(bytes, { size: opts.size });
		        bytes = (0, trim_js_1.trim)(bytes, { dir: 'right' });
		    }
		    return new TextDecoder().decode(bytes);
		}
		
		return fromHex;
	}

	var toHex = {};

	var hasRequiredToHex;

	function requireToHex () {
		if (hasRequiredToHex) return toHex;
		hasRequiredToHex = 1;
		Object.defineProperty(toHex, "__esModule", { value: true });
		toHex.toHex = toHex$1;
		toHex.boolToHex = boolToHex;
		toHex.bytesToHex = bytesToHex;
		toHex.numberToHex = numberToHex;
		toHex.stringToHex = stringToHex;
		const encoding_js_1 = encoding;
		const pad_js_1 = pad$1;
		const fromHex_js_1 = requireFromHex();
		const hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
		function toHex$1(value, opts = {}) {
		    if (typeof value === 'number' || typeof value === 'bigint')
		        return numberToHex(value, opts);
		    if (typeof value === 'string') {
		        return stringToHex(value, opts);
		    }
		    if (typeof value === 'boolean')
		        return boolToHex(value, opts);
		    return bytesToHex(value, opts);
		}
		function boolToHex(value, opts = {}) {
		    const hex = `0x${Number(value)}`;
		    if (typeof opts.size === 'number') {
		        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
		        return (0, pad_js_1.pad)(hex, { size: opts.size });
		    }
		    return hex;
		}
		function bytesToHex(value, opts = {}) {
		    let string = '';
		    for (let i = 0; i < value.length; i++) {
		        string += hexes[value[i]];
		    }
		    const hex = `0x${string}`;
		    if (typeof opts.size === 'number') {
		        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
		        return (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });
		    }
		    return hex;
		}
		function numberToHex(value_, opts = {}) {
		    const { signed, size } = opts;
		    const value = BigInt(value_);
		    let maxValue;
		    if (size) {
		        if (signed)
		            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
		        else
		            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
		    }
		    else if (typeof value_ === 'number') {
		        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
		    }
		    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
		    if ((maxValue && value > maxValue) || value < minValue) {
		        const suffix = typeof value_ === 'bigint' ? 'n' : '';
		        throw new encoding_js_1.IntegerOutOfRangeError({
		            max: maxValue ? `${maxValue}${suffix}` : undefined,
		            min: `${minValue}${suffix}`,
		            signed,
		            size,
		            value: `${value_}${suffix}`,
		        });
		    }
		    const hex = `0x${(signed && value < 0
	        ? (1n << BigInt(size * 8)) + BigInt(value)
	        : value).toString(16)}`;
		    if (size)
		        return (0, pad_js_1.pad)(hex, { size });
		    return hex;
		}
		const encoder = new TextEncoder();
		function stringToHex(value_, opts = {}) {
		    const value = encoder.encode(value_);
		    return bytesToHex(value, opts);
		}
		
		return toHex;
	}

	var hasRequiredToBytes;

	function requireToBytes () {
		if (hasRequiredToBytes) return toBytes;
		hasRequiredToBytes = 1;
		Object.defineProperty(toBytes, "__esModule", { value: true });
		toBytes.toBytes = toBytes$1;
		toBytes.boolToBytes = boolToBytes;
		toBytes.hexToBytes = hexToBytes;
		toBytes.numberToBytes = numberToBytes;
		toBytes.stringToBytes = stringToBytes;
		const base_js_1 = base$1;
		const isHex_js_1 = isHex$1;
		const pad_js_1 = pad$1;
		const fromHex_js_1 = requireFromHex();
		const toHex_js_1 = requireToHex();
		const encoder = new TextEncoder();
		function toBytes$1(value, opts = {}) {
		    if (typeof value === 'number' || typeof value === 'bigint')
		        return numberToBytes(value, opts);
		    if (typeof value === 'boolean')
		        return boolToBytes(value, opts);
		    if ((0, isHex_js_1.isHex)(value))
		        return hexToBytes(value, opts);
		    return stringToBytes(value, opts);
		}
		function boolToBytes(value, opts = {}) {
		    const bytes = new Uint8Array(1);
		    bytes[0] = Number(value);
		    if (typeof opts.size === 'number') {
		        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
		        return (0, pad_js_1.pad)(bytes, { size: opts.size });
		    }
		    return bytes;
		}
		const charCodeMap = {
		    zero: 48,
		    nine: 57,
		    A: 65,
		    F: 70,
		    a: 97,
		    f: 102,
		};
		function charCodeToBase16(char) {
		    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
		        return char - charCodeMap.zero;
		    if (char >= charCodeMap.A && char <= charCodeMap.F)
		        return char - (charCodeMap.A - 10);
		    if (char >= charCodeMap.a && char <= charCodeMap.f)
		        return char - (charCodeMap.a - 10);
		    return undefined;
		}
		function hexToBytes(hex_, opts = {}) {
		    let hex = hex_;
		    if (opts.size) {
		        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
		        hex = (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });
		    }
		    let hexString = hex.slice(2);
		    if (hexString.length % 2)
		        hexString = `0${hexString}`;
		    const length = hexString.length / 2;
		    const bytes = new Uint8Array(length);
		    for (let index = 0, j = 0; index < length; index++) {
		        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
		        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
		        if (nibbleLeft === undefined || nibbleRight === undefined) {
		            throw new base_js_1.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
		        }
		        bytes[index] = nibbleLeft * 16 + nibbleRight;
		    }
		    return bytes;
		}
		function numberToBytes(value, opts) {
		    const hex = (0, toHex_js_1.numberToHex)(value, opts);
		    return hexToBytes(hex);
		}
		function stringToBytes(value, opts = {}) {
		    const bytes = encoder.encode(value);
		    if (typeof opts.size === 'number') {
		        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
		        return (0, pad_js_1.pad)(bytes, { dir: 'right', size: opts.size });
		    }
		    return bytes;
		}
		
		return toBytes;
	}

	var keccak256$3 = {};

	var sha3 = {};

	var _u64 = {};

	Object.defineProperty(_u64, "__esModule", { value: true });
	_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.add = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = _u64.split = _u64.fromBig = void 0;
	const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
	const _32n = /* @__PURE__ */ BigInt(32);
	// We are not using BigUint64Array, because they are extremely slow as per 2022
	function fromBig(n, le = false) {
	    if (le)
	        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
	    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
	}
	_u64.fromBig = fromBig;
	function split(lst, le = false) {
	    let Ah = new Uint32Array(lst.length);
	    let Al = new Uint32Array(lst.length);
	    for (let i = 0; i < lst.length; i++) {
	        const { h, l } = fromBig(lst[i], le);
	        [Ah[i], Al[i]] = [h, l];
	    }
	    return [Ah, Al];
	}
	_u64.split = split;
	const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
	_u64.toBig = toBig;
	// for Shift in [0, 32)
	const shrSH = (h, _l, s) => h >>> s;
	_u64.shrSH = shrSH;
	const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
	_u64.shrSL = shrSL;
	// Right rotate for Shift in [1, 32)
	const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
	_u64.rotrSH = rotrSH;
	const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
	_u64.rotrSL = rotrSL;
	// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
	const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
	_u64.rotrBH = rotrBH;
	const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
	_u64.rotrBL = rotrBL;
	// Right rotate for shift===32 (just swaps l&h)
	const rotr32H = (_h, l) => l;
	_u64.rotr32H = rotr32H;
	const rotr32L = (h, _l) => h;
	_u64.rotr32L = rotr32L;
	// Left rotate for Shift in [1, 32)
	const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
	_u64.rotlSH = rotlSH;
	const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
	_u64.rotlSL = rotlSL;
	// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
	const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
	_u64.rotlBH = rotlBH;
	const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
	_u64.rotlBL = rotlBL;
	// JS uses 32-bit signed integers for bitwise operations which means we cannot
	// simple take carry out of low bit sum by shift, we need to use division.
	function add(Ah, Al, Bh, Bl) {
	    const l = (Al >>> 0) + (Bl >>> 0);
	    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
	}
	_u64.add = add;
	// Addition with more than 2 elements
	const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
	_u64.add3L = add3L;
	const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
	_u64.add3H = add3H;
	const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
	_u64.add4L = add4L;
	const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
	_u64.add4H = add4H;
	const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
	_u64.add5L = add5L;
	const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
	_u64.add5H = add5H;
	// prettier-ignore
	const u64 = {
	    fromBig, split, toBig,
	    shrSH, shrSL,
	    rotrSH, rotrSL, rotrBH, rotrBL,
	    rotr32H, rotr32L,
	    rotlSH, rotlSL, rotlBH, rotlBL,
	    add, add3L, add3H, add4L, add4H, add5H, add5L,
	};
	_u64.default = u64;

	Object.defineProperty(sha3, "__esModule", { value: true });
	sha3.shake256 = sha3.shake128 = sha3.keccak_512 = sha3.keccak_384 = sha3.keccak_256 = sha3.keccak_224 = sha3.sha3_512 = sha3.sha3_384 = sha3.sha3_256 = sha3.sha3_224 = sha3.Keccak = sha3.keccakP = void 0;
	const _assert_js_1 = _assert;
	const _u64_js_1 = _u64;
	const utils_js_1$k = utils$8;
	// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
	// It's called a sponge function.
	// Various per round constants calculations
	const SHA3_PI = [];
	const SHA3_ROTL = [];
	const _SHA3_IOTA = [];
	const _0n$3 = /* @__PURE__ */ BigInt(0);
	const _1n$3 = /* @__PURE__ */ BigInt(1);
	const _2n$2 = /* @__PURE__ */ BigInt(2);
	const _7n = /* @__PURE__ */ BigInt(7);
	const _256n = /* @__PURE__ */ BigInt(256);
	const _0x71n = /* @__PURE__ */ BigInt(0x71);
	for (let round = 0, R = _1n$3, x = 1, y = 0; round < 24; round++) {
	    // Pi
	    [x, y] = [y, (2 * x + 3 * y) % 5];
	    SHA3_PI.push(2 * (5 * y + x));
	    // Rotational
	    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
	    // Iota
	    let t = _0n$3;
	    for (let j = 0; j < 7; j++) {
	        R = ((R << _1n$3) ^ ((R >> _7n) * _0x71n)) % _256n;
	        if (R & _2n$2)
	            t ^= _1n$3 << ((_1n$3 << /* @__PURE__ */ BigInt(j)) - _1n$3);
	    }
	    _SHA3_IOTA.push(t);
	}
	const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
	// Left rotation (without 0, 32, 64)
	const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
	const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
	// Same as keccakf1600, but allows to skip some rounds
	function keccakP(s, rounds = 24) {
	    const B = new Uint32Array(5 * 2);
	    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
	    for (let round = 24 - rounds; round < 24; round++) {
	        // Theta θ
	        for (let x = 0; x < 10; x++)
	            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
	        for (let x = 0; x < 10; x += 2) {
	            const idx1 = (x + 8) % 10;
	            const idx0 = (x + 2) % 10;
	            const B0 = B[idx0];
	            const B1 = B[idx0 + 1];
	            const Th = rotlH(B0, B1, 1) ^ B[idx1];
	            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
	            for (let y = 0; y < 50; y += 10) {
	                s[x + y] ^= Th;
	                s[x + y + 1] ^= Tl;
	            }
	        }
	        // Rho (ρ) and Pi (π)
	        let curH = s[2];
	        let curL = s[3];
	        for (let t = 0; t < 24; t++) {
	            const shift = SHA3_ROTL[t];
	            const Th = rotlH(curH, curL, shift);
	            const Tl = rotlL(curH, curL, shift);
	            const PI = SHA3_PI[t];
	            curH = s[PI];
	            curL = s[PI + 1];
	            s[PI] = Th;
	            s[PI + 1] = Tl;
	        }
	        // Chi (χ)
	        for (let y = 0; y < 50; y += 10) {
	            for (let x = 0; x < 10; x++)
	                B[x] = s[y + x];
	            for (let x = 0; x < 10; x++)
	                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
	        }
	        // Iota (ι)
	        s[0] ^= SHA3_IOTA_H[round];
	        s[1] ^= SHA3_IOTA_L[round];
	    }
	    B.fill(0);
	}
	sha3.keccakP = keccakP;
	class Keccak extends utils_js_1$k.Hash {
	    // NOTE: we accept arguments in bytes instead of bits here.
	    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
	        super();
	        this.blockLen = blockLen;
	        this.suffix = suffix;
	        this.outputLen = outputLen;
	        this.enableXOF = enableXOF;
	        this.rounds = rounds;
	        this.pos = 0;
	        this.posOut = 0;
	        this.finished = false;
	        this.destroyed = false;
	        // Can be passed from user as dkLen
	        (0, _assert_js_1.number)(outputLen);
	        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
	        if (0 >= this.blockLen || this.blockLen >= 200)
	            throw new Error('Sha3 supports only keccak-f1600 function');
	        this.state = new Uint8Array(200);
	        this.state32 = (0, utils_js_1$k.u32)(this.state);
	    }
	    keccak() {
	        if (!utils_js_1$k.isLE)
	            (0, utils_js_1$k.byteSwap32)(this.state32);
	        keccakP(this.state32, this.rounds);
	        if (!utils_js_1$k.isLE)
	            (0, utils_js_1$k.byteSwap32)(this.state32);
	        this.posOut = 0;
	        this.pos = 0;
	    }
	    update(data) {
	        (0, _assert_js_1.exists)(this);
	        const { blockLen, state } = this;
	        data = (0, utils_js_1$k.toBytes)(data);
	        const len = data.length;
	        for (let pos = 0; pos < len;) {
	            const take = Math.min(blockLen - this.pos, len - pos);
	            for (let i = 0; i < take; i++)
	                state[this.pos++] ^= data[pos++];
	            if (this.pos === blockLen)
	                this.keccak();
	        }
	        return this;
	    }
	    finish() {
	        if (this.finished)
	            return;
	        this.finished = true;
	        const { state, suffix, pos, blockLen } = this;
	        // Do the padding
	        state[pos] ^= suffix;
	        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
	            this.keccak();
	        state[blockLen - 1] ^= 0x80;
	        this.keccak();
	    }
	    writeInto(out) {
	        (0, _assert_js_1.exists)(this, false);
	        (0, _assert_js_1.bytes)(out);
	        this.finish();
	        const bufferOut = this.state;
	        const { blockLen } = this;
	        for (let pos = 0, len = out.length; pos < len;) {
	            if (this.posOut >= blockLen)
	                this.keccak();
	            const take = Math.min(blockLen - this.posOut, len - pos);
	            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
	            this.posOut += take;
	            pos += take;
	        }
	        return out;
	    }
	    xofInto(out) {
	        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
	        if (!this.enableXOF)
	            throw new Error('XOF is not possible for this instance');
	        return this.writeInto(out);
	    }
	    xof(bytes) {
	        (0, _assert_js_1.number)(bytes);
	        return this.xofInto(new Uint8Array(bytes));
	    }
	    digestInto(out) {
	        (0, _assert_js_1.output)(out, this);
	        if (this.finished)
	            throw new Error('digest() was already called');
	        this.writeInto(out);
	        this.destroy();
	        return out;
	    }
	    digest() {
	        return this.digestInto(new Uint8Array(this.outputLen));
	    }
	    destroy() {
	        this.destroyed = true;
	        this.state.fill(0);
	    }
	    _cloneInto(to) {
	        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
	        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
	        to.state32.set(this.state32);
	        to.pos = this.pos;
	        to.posOut = this.posOut;
	        to.finished = this.finished;
	        to.rounds = rounds;
	        // Suffix can change in cSHAKE
	        to.suffix = suffix;
	        to.outputLen = outputLen;
	        to.enableXOF = enableXOF;
	        to.destroyed = this.destroyed;
	        return to;
	    }
	}
	sha3.Keccak = Keccak;
	const gen = (suffix, blockLen, outputLen) => (0, utils_js_1$k.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
	sha3.sha3_224 = gen(0x06, 144, 224 / 8);
	/**
	 * SHA3-256 hash function
	 * @param message - that would be hashed
	 */
	sha3.sha3_256 = gen(0x06, 136, 256 / 8);
	sha3.sha3_384 = gen(0x06, 104, 384 / 8);
	sha3.sha3_512 = gen(0x06, 72, 512 / 8);
	sha3.keccak_224 = gen(0x01, 144, 224 / 8);
	/**
	 * keccak-256 hash function. Different from SHA3-256.
	 * @param message - that would be hashed
	 */
	sha3.keccak_256 = gen(0x01, 136, 256 / 8);
	sha3.keccak_384 = gen(0x01, 104, 384 / 8);
	sha3.keccak_512 = gen(0x01, 72, 512 / 8);
	const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1$k.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
	sha3.shake128 = genShake(0x1f, 168, 128 / 8);
	sha3.shake256 = genShake(0x1f, 136, 256 / 8);

	Object.defineProperty(keccak256$3, "__esModule", { value: true });
	keccak256$3.keccak256 = keccak256$2;
	const sha3_1$1 = sha3;
	const isHex_js_1$a = isHex$1;
	const toBytes_js_1$m = requireToBytes();
	const toHex_js_1$S = requireToHex();
	function keccak256$2(value, to_) {
	    const to = to_ || 'hex';
	    const bytes = (0, sha3_1$1.keccak_256)((0, isHex_js_1$a.isHex)(value, { strict: false }) ? (0, toBytes_js_1$m.toBytes)(value) : value);
	    if (to === 'bytes')
	        return bytes;
	    return (0, toHex_js_1$S.toHex)(bytes);
	}

	var toEventSelector = {};

	var toSignatureHash$1 = {};

	var hashSignature$1 = {};

	Object.defineProperty(hashSignature$1, "__esModule", { value: true });
	hashSignature$1.hashSignature = hashSignature;
	const toBytes_js_1$l = requireToBytes();
	const keccak256_js_1$c = keccak256$3;
	const hash = (value) => (0, keccak256_js_1$c.keccak256)((0, toBytes_js_1$l.toBytes)(value));
	function hashSignature(sig) {
	    return hash(sig);
	}

	var toSignature$1 = {};

	var normalizeSignature$1 = {};

	Object.defineProperty(normalizeSignature$1, "__esModule", { value: true });
	normalizeSignature$1.normalizeSignature = normalizeSignature;
	const base_js_1$t = base$1;
	function normalizeSignature(signature) {
	    let active = true;
	    let current = '';
	    let level = 0;
	    let result = '';
	    let valid = false;
	    for (let i = 0; i < signature.length; i++) {
	        const char = signature[i];
	        if (['(', ')', ','].includes(char))
	            active = true;
	        if (char === '(')
	            level++;
	        if (char === ')')
	            level--;
	        if (!active)
	            continue;
	        if (level === 0) {
	            if (char === ' ' && ['event', 'function', ''].includes(result))
	                result = '';
	            else {
	                result += char;
	                if (char === ')') {
	                    valid = true;
	                    break;
	                }
	            }
	            continue;
	        }
	        if (char === ' ') {
	            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {
	                current = '';
	                active = false;
	            }
	            continue;
	        }
	        result += char;
	        current += char;
	    }
	    if (!valid)
	        throw new base_js_1$t.BaseError('Unable to normalize signature.');
	    return result;
	}

	Object.defineProperty(toSignature$1, "__esModule", { value: true });
	toSignature$1.toSignature = void 0;
	const abitype_1$5 = exports$1;
	const normalizeSignature_js_1 = normalizeSignature$1;
	const toSignature = (def) => {
	    const def_ = (() => {
	        if (typeof def === 'string')
	            return def;
	        return (0, abitype_1$5.formatAbiItem)(def);
	    })();
	    return (0, normalizeSignature_js_1.normalizeSignature)(def_);
	};
	toSignature$1.toSignature = toSignature;

	Object.defineProperty(toSignatureHash$1, "__esModule", { value: true });
	toSignatureHash$1.toSignatureHash = toSignatureHash;
	const hashSignature_js_1 = hashSignature$1;
	const toSignature_js_1 = toSignature$1;
	function toSignatureHash(fn) {
	    return (0, hashSignature_js_1.hashSignature)((0, toSignature_js_1.toSignature)(fn));
	}

	Object.defineProperty(toEventSelector, "__esModule", { value: true });
	toEventSelector.toEventSelector = void 0;
	const toSignatureHash_js_1$1 = toSignatureHash$1;
	toEventSelector.toEventSelector = toSignatureHash_js_1$1.toSignatureHash;

	var encodeAbiParameters$3 = {};

	var address$2 = {};

	Object.defineProperty(address$2, "__esModule", { value: true });
	address$2.InvalidAddressError = void 0;
	const base_js_1$s = base$1;
	class InvalidAddressError extends base_js_1$s.BaseError {
	    constructor({ address }) {
	        super(`Address "${address}" is invalid.`, {
	            metaMessages: [
	                '- Address must be a hex value of 20 bytes (40 hex characters).',
	                '- Address must match its checksum counterpart.',
	            ],
	            name: 'InvalidAddressError',
	        });
	    }
	}
	address$2.InvalidAddressError = InvalidAddressError;

	var isAddress$1 = {};

	var lru = {};

	Object.defineProperty(lru, "__esModule", { value: true });
	lru.LruMap = void 0;
	class LruMap extends Map {
	    constructor(size) {
	        super();
	        Object.defineProperty(this, "maxSize", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.maxSize = size;
	    }
	    set(key, value) {
	        super.set(key, value);
	        if (this.maxSize && this.size > this.maxSize)
	            this.delete(this.keys().next().value);
	        return this;
	    }
	}
	lru.LruMap = LruMap;

	var getAddress$1 = {};

	var hasRequiredGetAddress;

	function requireGetAddress () {
		if (hasRequiredGetAddress) return getAddress$1;
		hasRequiredGetAddress = 1;
		Object.defineProperty(getAddress$1, "__esModule", { value: true });
		getAddress$1.checksumAddress = checksumAddress;
		getAddress$1.getAddress = getAddress;
		const address_js_1 = address$2;
		const toBytes_js_1 = requireToBytes();
		const keccak256_js_1 = keccak256$3;
		const lru_js_1 = lru;
		const isAddress_js_1 = requireIsAddress();
		const checksumAddressCache = new lru_js_1.LruMap(8192);
		function checksumAddress(address_, chainId) {
		    if (checksumAddressCache.has(`${address_}.${chainId}`))
		        return checksumAddressCache.get(`${address_}.${chainId}`);
		    const hexAddress = chainId
		        ? `${chainId}${address_.toLowerCase()}`
		        : address_.substring(2).toLowerCase();
		    const hash = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), 'bytes');
		    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
		    for (let i = 0; i < 40; i += 2) {
		        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
		            address[i] = address[i].toUpperCase();
		        }
		        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
		            address[i + 1] = address[i + 1].toUpperCase();
		        }
		    }
		    const result = `0x${address.join('')}`;
		    checksumAddressCache.set(`${address_}.${chainId}`, result);
		    return result;
		}
		function getAddress(address, chainId) {
		    if (!(0, isAddress_js_1.isAddress)(address, { strict: false }))
		        throw new address_js_1.InvalidAddressError({ address });
		    return checksumAddress(address, chainId);
		}
		
		return getAddress$1;
	}

	var hasRequiredIsAddress;

	function requireIsAddress () {
		if (hasRequiredIsAddress) return isAddress$1;
		hasRequiredIsAddress = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.isAddressCache = void 0;
			exports.isAddress = isAddress;
			const lru_js_1 = lru;
			const getAddress_js_1 = requireGetAddress();
			const addressRegex = /^0x[a-fA-F0-9]{40}$/;
			exports.isAddressCache = new lru_js_1.LruMap(8192);
			function isAddress(address, options) {
			    const { strict = true } = options ?? {};
			    const cacheKey = `${address}.${strict}`;
			    if (exports.isAddressCache.has(cacheKey))
			        return exports.isAddressCache.get(cacheKey);
			    const result = (() => {
			        if (!addressRegex.test(address))
			            return false;
			        if (address.toLowerCase() === address)
			            return true;
			        if (strict)
			            return (0, getAddress_js_1.checksumAddress)(address) === address;
			        return true;
			    })();
			    exports.isAddressCache.set(cacheKey, result);
			    return result;
			}
			
		} (isAddress$1));
		return isAddress$1;
	}

	var concat$1 = {};

	Object.defineProperty(concat$1, "__esModule", { value: true });
	concat$1.concat = concat;
	concat$1.concatBytes = concatBytes$1;
	concat$1.concatHex = concatHex$2;
	function concat(values) {
	    if (typeof values[0] === 'string')
	        return concatHex$2(values);
	    return concatBytes$1(values);
	}
	function concatBytes$1(values) {
	    let length = 0;
	    for (const arr of values) {
	        length += arr.length;
	    }
	    const result = new Uint8Array(length);
	    let offset = 0;
	    for (const arr of values) {
	        result.set(arr, offset);
	        offset += arr.length;
	    }
	    return result;
	}
	function concatHex$2(values) {
	    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;
	}

	var slice$1 = {};

	Object.defineProperty(slice$1, "__esModule", { value: true });
	slice$1.slice = slice;
	slice$1.sliceBytes = sliceBytes;
	slice$1.sliceHex = sliceHex;
	const data_js_1$1 = data;
	const isHex_js_1$9 = isHex$1;
	const size_js_1$7 = size$2;
	function slice(value, start, end, { strict } = {}) {
	    if ((0, isHex_js_1$9.isHex)(value, { strict: false }))
	        return sliceHex(value, start, end, {
	            strict,
	        });
	    return sliceBytes(value, start, end, {
	        strict,
	    });
	}
	function assertStartOffset(value, start) {
	    if (typeof start === 'number' && start > 0 && start > (0, size_js_1$7.size)(value) - 1)
	        throw new data_js_1$1.SliceOffsetOutOfBoundsError({
	            offset: start,
	            position: 'start',
	            size: (0, size_js_1$7.size)(value),
	        });
	}
	function assertEndOffset(value, start, end) {
	    if (typeof start === 'number' &&
	        typeof end === 'number' &&
	        (0, size_js_1$7.size)(value) !== end - start) {
	        throw new data_js_1$1.SliceOffsetOutOfBoundsError({
	            offset: end,
	            position: 'end',
	            size: (0, size_js_1$7.size)(value),
	        });
	    }
	}
	function sliceBytes(value_, start, end, { strict } = {}) {
	    assertStartOffset(value_, start);
	    const value = value_.slice(start, end);
	    if (strict)
	        assertEndOffset(value, start, end);
	    return value;
	}
	function sliceHex(value_, start, end, { strict } = {}) {
	    assertStartOffset(value_, start);
	    const value = `0x${value_
        .replace('0x', '')
        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
	    if (strict)
	        assertEndOffset(value, start, end);
	    return value;
	}

	Object.defineProperty(encodeAbiParameters$3, "__esModule", { value: true });
	encodeAbiParameters$3.encodeAbiParameters = encodeAbiParameters$2;
	encodeAbiParameters$3.getArrayComponents = getArrayComponents$1;
	const abi_js_1$j = requireAbi();
	const address_js_1$8 = address$2;
	const base_js_1$r = base$1;
	const isAddress_js_1$8 = requireIsAddress();
	const concat_js_1$9 = concat$1;
	const pad_js_1$3 = pad$1;
	const size_js_1$6 = size$2;
	const slice_js_1$8 = slice$1;
	const toHex_js_1$R = requireToHex();
	function encodeAbiParameters$2(params, values) {
	    if (params.length !== values.length)
	        throw new abi_js_1$j.AbiEncodingLengthMismatchError({
	            expectedLength: params.length,
	            givenLength: values.length,
	        });
	    const preparedParams = prepareParams$1({
	        params: params,
	        values: values,
	    });
	    const data = encodeParams$1(preparedParams);
	    if (data.length === 0)
	        return '0x';
	    return data;
	}
	function prepareParams$1({ params, values, }) {
	    const preparedParams = [];
	    for (let i = 0; i < params.length; i++) {
	        preparedParams.push(prepareParam$1({ param: params[i], value: values[i] }));
	    }
	    return preparedParams;
	}
	function prepareParam$1({ param, value, }) {
	    const arrayComponents = getArrayComponents$1(param.type);
	    if (arrayComponents) {
	        const [length, type] = arrayComponents;
	        return encodeArray$1(value, { length, param: { ...param, type } });
	    }
	    if (param.type === 'tuple') {
	        return encodeTuple$1(value, {
	            param: param,
	        });
	    }
	    if (param.type === 'address') {
	        return encodeAddress$1(value);
	    }
	    if (param.type === 'bool') {
	        return encodeBool$1(value);
	    }
	    if (param.type.startsWith('uint') || param.type.startsWith('int')) {
	        const signed = param.type.startsWith('int');
	        return encodeNumber$1(value, { signed });
	    }
	    if (param.type.startsWith('bytes')) {
	        return encodeBytes$1(value, { param });
	    }
	    if (param.type === 'string') {
	        return encodeString$1(value);
	    }
	    throw new abi_js_1$j.InvalidAbiEncodingTypeError(param.type, {
	        docsPath: '/docs/contract/encodeAbiParameters',
	    });
	}
	function encodeParams$1(preparedParams) {
	    let staticSize = 0;
	    for (let i = 0; i < preparedParams.length; i++) {
	        const { dynamic, encoded } = preparedParams[i];
	        if (dynamic)
	            staticSize += 32;
	        else
	            staticSize += (0, size_js_1$6.size)(encoded);
	    }
	    const staticParams = [];
	    const dynamicParams = [];
	    let dynamicSize = 0;
	    for (let i = 0; i < preparedParams.length; i++) {
	        const { dynamic, encoded } = preparedParams[i];
	        if (dynamic) {
	            staticParams.push((0, toHex_js_1$R.numberToHex)(staticSize + dynamicSize, { size: 32 }));
	            dynamicParams.push(encoded);
	            dynamicSize += (0, size_js_1$6.size)(encoded);
	        }
	        else {
	            staticParams.push(encoded);
	        }
	    }
	    return (0, concat_js_1$9.concat)([...staticParams, ...dynamicParams]);
	}
	function encodeAddress$1(value) {
	    if (!(0, isAddress_js_1$8.isAddress)(value))
	        throw new address_js_1$8.InvalidAddressError({ address: value });
	    return { dynamic: false, encoded: (0, pad_js_1$3.padHex)(value.toLowerCase()) };
	}
	function encodeArray$1(value, { length, param, }) {
	    const dynamic = length === null;
	    if (!Array.isArray(value))
	        throw new abi_js_1$j.InvalidArrayError(value);
	    if (!dynamic && value.length !== length)
	        throw new abi_js_1$j.AbiEncodingArrayLengthMismatchError({
	            expectedLength: length,
	            givenLength: value.length,
	            type: `${param.type}[${length}]`,
	        });
	    let dynamicChild = false;
	    const preparedParams = [];
	    for (let i = 0; i < value.length; i++) {
	        const preparedParam = prepareParam$1({ param, value: value[i] });
	        if (preparedParam.dynamic)
	            dynamicChild = true;
	        preparedParams.push(preparedParam);
	    }
	    if (dynamic || dynamicChild) {
	        const data = encodeParams$1(preparedParams);
	        if (dynamic) {
	            const length = (0, toHex_js_1$R.numberToHex)(preparedParams.length, { size: 32 });
	            return {
	                dynamic: true,
	                encoded: preparedParams.length > 0 ? (0, concat_js_1$9.concat)([length, data]) : length,
	            };
	        }
	        if (dynamicChild)
	            return { dynamic: true, encoded: data };
	    }
	    return {
	        dynamic: false,
	        encoded: (0, concat_js_1$9.concat)(preparedParams.map(({ encoded }) => encoded)),
	    };
	}
	function encodeBytes$1(value, { param }) {
	    const [, paramSize] = param.type.split('bytes');
	    const bytesSize = (0, size_js_1$6.size)(value);
	    if (!paramSize) {
	        let value_ = value;
	        if (bytesSize % 32 !== 0)
	            value_ = (0, pad_js_1$3.padHex)(value_, {
	                dir: 'right',
	                size: Math.ceil((value.length - 2) / 2 / 32) * 32,
	            });
	        return {
	            dynamic: true,
	            encoded: (0, concat_js_1$9.concat)([(0, pad_js_1$3.padHex)((0, toHex_js_1$R.numberToHex)(bytesSize, { size: 32 })), value_]),
	        };
	    }
	    if (bytesSize !== Number.parseInt(paramSize))
	        throw new abi_js_1$j.AbiEncodingBytesSizeMismatchError({
	            expectedSize: Number.parseInt(paramSize),
	            value,
	        });
	    return { dynamic: false, encoded: (0, pad_js_1$3.padHex)(value, { dir: 'right' }) };
	}
	function encodeBool$1(value) {
	    if (typeof value !== 'boolean')
	        throw new base_js_1$r.BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
	    return { dynamic: false, encoded: (0, pad_js_1$3.padHex)((0, toHex_js_1$R.boolToHex)(value)) };
	}
	function encodeNumber$1(value, { signed }) {
	    return {
	        dynamic: false,
	        encoded: (0, toHex_js_1$R.numberToHex)(value, {
	            size: 32,
	            signed,
	        }),
	    };
	}
	function encodeString$1(value) {
	    const hexValue = (0, toHex_js_1$R.stringToHex)(value);
	    const partsLength = Math.ceil((0, size_js_1$6.size)(hexValue) / 32);
	    const parts = [];
	    for (let i = 0; i < partsLength; i++) {
	        parts.push((0, pad_js_1$3.padHex)((0, slice_js_1$8.slice)(hexValue, i * 32, (i + 1) * 32), {
	            dir: 'right',
	        }));
	    }
	    return {
	        dynamic: true,
	        encoded: (0, concat_js_1$9.concat)([
	            (0, pad_js_1$3.padHex)((0, toHex_js_1$R.numberToHex)((0, size_js_1$6.size)(hexValue), { size: 32 })),
	            ...parts,
	        ]),
	    };
	}
	function encodeTuple$1(value, { param }) {
	    let dynamic = false;
	    const preparedParams = [];
	    for (let i = 0; i < param.components.length; i++) {
	        const param_ = param.components[i];
	        const index = Array.isArray(value) ? i : param_.name;
	        const preparedParam = prepareParam$1({
	            param: param_,
	            value: value[index],
	        });
	        preparedParams.push(preparedParam);
	        if (preparedParam.dynamic)
	            dynamic = true;
	    }
	    return {
	        dynamic,
	        encoded: dynamic
	            ? encodeParams$1(preparedParams)
	            : (0, concat_js_1$9.concat)(preparedParams.map(({ encoded }) => encoded)),
	    };
	}
	function getArrayComponents$1(type) {
	    const matches = type.match(/^(.*)\[(\d+)?\]$/);
	    return matches
	        ?
	            [matches[2] ? Number(matches[2]) : null, matches[1]]
	        : undefined;
	}

	var getAbiItem$1 = {};

	var toFunctionSelector$1 = {};

	Object.defineProperty(toFunctionSelector$1, "__esModule", { value: true });
	toFunctionSelector$1.toFunctionSelector = void 0;
	const slice_js_1$7 = slice$1;
	const toSignatureHash_js_1 = toSignatureHash$1;
	const toFunctionSelector = (fn) => (0, slice_js_1$7.slice)((0, toSignatureHash_js_1.toSignatureHash)(fn), 0, 4);
	toFunctionSelector$1.toFunctionSelector = toFunctionSelector;

	Object.defineProperty(getAbiItem$1, "__esModule", { value: true });
	getAbiItem$1.getAbiItem = getAbiItem;
	getAbiItem$1.isArgOfType = isArgOfType;
	getAbiItem$1.getAmbiguousTypes = getAmbiguousTypes;
	const abi_js_1$i = requireAbi();
	const isHex_js_1$8 = isHex$1;
	const isAddress_js_1$7 = requireIsAddress();
	const toEventSelector_js_1$2 = toEventSelector;
	const toFunctionSelector_js_1$4 = toFunctionSelector$1;
	function getAbiItem(parameters) {
	    const { abi, args = [], name } = parameters;
	    const isSelector = (0, isHex_js_1$8.isHex)(name, { strict: false });
	    const abiItems = abi.filter((abiItem) => {
	        if (isSelector) {
	            if (abiItem.type === 'function')
	                return (0, toFunctionSelector_js_1$4.toFunctionSelector)(abiItem) === name;
	            if (abiItem.type === 'event')
	                return (0, toEventSelector_js_1$2.toEventSelector)(abiItem) === name;
	            return false;
	        }
	        return 'name' in abiItem && abiItem.name === name;
	    });
	    if (abiItems.length === 0)
	        return undefined;
	    if (abiItems.length === 1)
	        return abiItems[0];
	    let matchedAbiItem = undefined;
	    for (const abiItem of abiItems) {
	        if (!('inputs' in abiItem))
	            continue;
	        if (!args || args.length === 0) {
	            if (!abiItem.inputs || abiItem.inputs.length === 0)
	                return abiItem;
	            continue;
	        }
	        if (!abiItem.inputs)
	            continue;
	        if (abiItem.inputs.length === 0)
	            continue;
	        if (abiItem.inputs.length !== args.length)
	            continue;
	        const matched = args.every((arg, index) => {
	            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
	            if (!abiParameter)
	                return false;
	            return isArgOfType(arg, abiParameter);
	        });
	        if (matched) {
	            if (matchedAbiItem &&
	                'inputs' in matchedAbiItem &&
	                matchedAbiItem.inputs) {
	                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
	                if (ambiguousTypes)
	                    throw new abi_js_1$i.AbiItemAmbiguityError({
	                        abiItem,
	                        type: ambiguousTypes[0],
	                    }, {
	                        abiItem: matchedAbiItem,
	                        type: ambiguousTypes[1],
	                    });
	            }
	            matchedAbiItem = abiItem;
	        }
	    }
	    if (matchedAbiItem)
	        return matchedAbiItem;
	    return abiItems[0];
	}
	function isArgOfType(arg, abiParameter) {
	    const argType = typeof arg;
	    const abiParameterType = abiParameter.type;
	    switch (abiParameterType) {
	        case 'address':
	            return (0, isAddress_js_1$7.isAddress)(arg, { strict: false });
	        case 'bool':
	            return argType === 'boolean';
	        case 'function':
	            return argType === 'string';
	        case 'string':
	            return argType === 'string';
	        default: {
	            if (abiParameterType === 'tuple' && 'components' in abiParameter)
	                return Object.values(abiParameter.components).every((component, index) => {
	                    return isArgOfType(Object.values(arg)[index], component);
	                });
	            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
	                return argType === 'number' || argType === 'bigint';
	            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
	                return argType === 'string' || arg instanceof Uint8Array;
	            if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
	                return (Array.isArray(arg) &&
	                    arg.every((x) => isArgOfType(x, {
	                        ...abiParameter,
	                        type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, ''),
	                    })));
	            }
	            return false;
	        }
	    }
	}
	function getAmbiguousTypes(sourceParameters, targetParameters, args) {
	    for (const parameterIndex in sourceParameters) {
	        const sourceParameter = sourceParameters[parameterIndex];
	        const targetParameter = targetParameters[parameterIndex];
	        if (sourceParameter.type === 'tuple' &&
	            targetParameter.type === 'tuple' &&
	            'components' in sourceParameter &&
	            'components' in targetParameter)
	            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
	        const types = [sourceParameter.type, targetParameter.type];
	        const ambiguous = (() => {
	            if (types.includes('address') && types.includes('bytes20'))
	                return true;
	            if (types.includes('address') && types.includes('string'))
	                return (0, isAddress_js_1$7.isAddress)(args[parameterIndex], { strict: false });
	            if (types.includes('address') && types.includes('bytes'))
	                return (0, isAddress_js_1$7.isAddress)(args[parameterIndex], { strict: false });
	            return false;
	        })();
	        if (ambiguous)
	            return types;
	    }
	    return;
	}

	Object.defineProperty(encodeEventTopics$1, "__esModule", { value: true });
	encodeEventTopics$1.encodeEventTopics = encodeEventTopics;
	const abi_js_1$h = requireAbi();
	const log_js_1$5 = log$1;
	const toBytes_js_1$k = requireToBytes();
	const keccak256_js_1$b = keccak256$3;
	const toEventSelector_js_1$1 = toEventSelector;
	const encodeAbiParameters_js_1$9 = encodeAbiParameters$3;
	const formatAbiItem_js_1$6 = requireFormatAbiItem();
	const getAbiItem_js_1$7 = getAbiItem$1;
	const docsPath$7 = '/docs/contract/encodeEventTopics';
	function encodeEventTopics(parameters) {
	    const { abi, eventName, args } = parameters;
	    let abiItem = abi[0];
	    if (eventName) {
	        const item = (0, getAbiItem_js_1$7.getAbiItem)({ abi, name: eventName });
	        if (!item)
	            throw new abi_js_1$h.AbiEventNotFoundError(eventName, { docsPath: docsPath$7 });
	        abiItem = item;
	    }
	    if (abiItem.type !== 'event')
	        throw new abi_js_1$h.AbiEventNotFoundError(undefined, { docsPath: docsPath$7 });
	    const definition = (0, formatAbiItem_js_1$6.formatAbiItem)(abiItem);
	    const signature = (0, toEventSelector_js_1$1.toEventSelector)(definition);
	    let topics = [];
	    if (args && 'inputs' in abiItem) {
	        const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);
	        const args_ = Array.isArray(args)
	            ? args
	            : Object.values(args).length > 0
	                ? indexedInputs?.map((x) => args[x.name]) ?? []
	                : [];
	        if (args_.length > 0) {
	            topics =
	                indexedInputs?.map((param, i) => {
	                    if (Array.isArray(args_[i]))
	                        return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));
	                    return args_[i] ? encodeArg({ param, value: args_[i] }) : null;
	                }) ?? [];
	        }
	    }
	    return [signature, ...topics];
	}
	function encodeArg({ param, value, }) {
	    if (param.type === 'string' || param.type === 'bytes')
	        return (0, keccak256_js_1$b.keccak256)((0, toBytes_js_1$k.toBytes)(value));
	    if (param.type === 'tuple' || param.type.match(/^(.*)\[(\d+)?\]$/))
	        throw new log_js_1$5.FilterTypeNotSupportedError(param.type);
	    return (0, encodeAbiParameters_js_1$9.encodeAbiParameters)([param], [value]);
	}

	var createFilterRequestScope$1 = {};

	Object.defineProperty(createFilterRequestScope$1, "__esModule", { value: true });
	createFilterRequestScope$1.createFilterRequestScope = createFilterRequestScope;
	function createFilterRequestScope(client, { method }) {
	    const requestMap = {};
	    if (client.transport.type === 'fallback')
	        client.transport.onResponse?.(({ method: method_, response: id, status, transport, }) => {
	            if (status === 'success' && method === method_)
	                requestMap[id] = transport.request;
	        });
	    return ((id) => requestMap[id] || client.request);
	}

	Object.defineProperty(createContractEventFilter$1, "__esModule", { value: true });
	createContractEventFilter$1.createContractEventFilter = createContractEventFilter;
	const encodeEventTopics_js_1$4 = encodeEventTopics$1;
	const toHex_js_1$Q = requireToHex();
	const createFilterRequestScope_js_1$3 = createFilterRequestScope$1;
	async function createContractEventFilter(client, parameters) {
	    const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
	    const getRequest = (0, createFilterRequestScope_js_1$3.createFilterRequestScope)(client, {
	        method: 'eth_newFilter',
	    });
	    const topics = eventName
	        ? (0, encodeEventTopics_js_1$4.encodeEventTopics)({
	            abi,
	            args,
	            eventName,
	        })
	        : undefined;
	    const id = await client.request({
	        method: 'eth_newFilter',
	        params: [
	            {
	                address,
	                fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1$Q.numberToHex)(fromBlock) : fromBlock,
	                toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1$Q.numberToHex)(toBlock) : toBlock,
	                topics,
	            },
	        ],
	    });
	    return {
	        abi,
	        args,
	        eventName,
	        id,
	        request: getRequest(id),
	        strict: Boolean(strict),
	        type: 'event',
	    };
	}

	var estimateContractGas$1 = {};

	var parseAccount$1 = {};

	Object.defineProperty(parseAccount$1, "__esModule", { value: true });
	parseAccount$1.parseAccount = parseAccount;
	function parseAccount(account) {
	    if (typeof account === 'string')
	        return { address: account, type: 'json-rpc' };
	    return account;
	}

	var encodeFunctionData$1 = {};

	var prepareEncodeFunctionData$1 = {};

	Object.defineProperty(prepareEncodeFunctionData$1, "__esModule", { value: true });
	prepareEncodeFunctionData$1.prepareEncodeFunctionData = prepareEncodeFunctionData;
	const abi_js_1$g = requireAbi();
	const toFunctionSelector_js_1$3 = toFunctionSelector$1;
	const formatAbiItem_js_1$5 = requireFormatAbiItem();
	const getAbiItem_js_1$6 = getAbiItem$1;
	const docsPath$6 = '/docs/contract/encodeFunctionData';
	function prepareEncodeFunctionData(parameters) {
	    const { abi, args, functionName } = parameters;
	    let abiItem = abi[0];
	    if (functionName) {
	        const item = (0, getAbiItem_js_1$6.getAbiItem)({
	            abi,
	            args,
	            name: functionName,
	        });
	        if (!item)
	            throw new abi_js_1$g.AbiFunctionNotFoundError(functionName, { docsPath: docsPath$6 });
	        abiItem = item;
	    }
	    if (abiItem.type !== 'function')
	        throw new abi_js_1$g.AbiFunctionNotFoundError(undefined, { docsPath: docsPath$6 });
	    return {
	        abi: [abiItem],
	        functionName: (0, toFunctionSelector_js_1$3.toFunctionSelector)((0, formatAbiItem_js_1$5.formatAbiItem)(abiItem)),
	    };
	}

	Object.defineProperty(encodeFunctionData$1, "__esModule", { value: true });
	encodeFunctionData$1.encodeFunctionData = encodeFunctionData;
	const concat_js_1$8 = concat$1;
	const encodeAbiParameters_js_1$8 = encodeAbiParameters$3;
	const prepareEncodeFunctionData_js_1 = prepareEncodeFunctionData$1;
	function encodeFunctionData(parameters) {
	    const { args } = parameters;
	    const { abi, functionName } = (() => {
	        if (parameters.abi.length === 1 &&
	            parameters.functionName?.startsWith('0x'))
	            return parameters;
	        return (0, prepareEncodeFunctionData_js_1.prepareEncodeFunctionData)(parameters);
	    })();
	    const abiItem = abi[0];
	    const signature = functionName;
	    const data = 'inputs' in abiItem && abiItem.inputs
	        ? (0, encodeAbiParameters_js_1$8.encodeAbiParameters)(abiItem.inputs, args ?? [])
	        : undefined;
	    return (0, concat_js_1$8.concatHex)([signature, data ?? '0x']);
	}

	var getContractError$1 = {};

	var contract$2 = {};

	var solidity = {};

	Object.defineProperty(solidity, "__esModule", { value: true });
	solidity.solidityPanic = solidity.solidityError = solidity.panicReasons = void 0;
	solidity.panicReasons = {
	    1: 'An `assert` condition failed.',
	    17: 'Arithmetic operation resulted in underflow or overflow.',
	    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
	    33: 'Attempted to convert to an invalid type.',
	    34: 'Attempted to access a storage byte array that is incorrectly encoded.',
	    49: 'Performed `.pop()` on an empty array',
	    50: 'Array index is out of bounds.',
	    65: 'Allocated too much memory or created an array which is too large.',
	    81: 'Attempted to call a zero-initialized variable of internal function type.',
	};
	solidity.solidityError = {
	    inputs: [
	        {
	            name: 'message',
	            type: 'string',
	        },
	    ],
	    name: 'Error',
	    type: 'error',
	};
	solidity.solidityPanic = {
	    inputs: [
	        {
	            name: 'reason',
	            type: 'uint256',
	        },
	    ],
	    name: 'Panic',
	    type: 'error',
	};

	var decodeErrorResult$1 = {};

	var decodeAbiParameters$1 = {};

	var cursor$1 = {};

	var cursor = {};

	Object.defineProperty(cursor, "__esModule", { value: true });
	cursor.RecursiveReadLimitExceededError = cursor.PositionOutOfBoundsError = cursor.NegativeOffsetError = void 0;
	const base_js_1$q = base$1;
	class NegativeOffsetError extends base_js_1$q.BaseError {
	    constructor({ offset }) {
	        super(`Offset \`${offset}\` cannot be negative.`, {
	            name: 'NegativeOffsetError',
	        });
	    }
	}
	cursor.NegativeOffsetError = NegativeOffsetError;
	class PositionOutOfBoundsError extends base_js_1$q.BaseError {
	    constructor({ length, position }) {
	        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: 'PositionOutOfBoundsError' });
	    }
	}
	cursor.PositionOutOfBoundsError = PositionOutOfBoundsError;
	class RecursiveReadLimitExceededError extends base_js_1$q.BaseError {
	    constructor({ count, limit }) {
	        super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: 'RecursiveReadLimitExceededError' });
	    }
	}
	cursor.RecursiveReadLimitExceededError = RecursiveReadLimitExceededError;

	Object.defineProperty(cursor$1, "__esModule", { value: true });
	cursor$1.createCursor = createCursor;
	const cursor_js_1$6 = cursor;
	const staticCursor = {
	    bytes: new Uint8Array(),
	    dataView: new DataView(new ArrayBuffer(0)),
	    position: 0,
	    positionReadCount: new Map(),
	    recursiveReadCount: 0,
	    recursiveReadLimit: Number.POSITIVE_INFINITY,
	    assertReadLimit() {
	        if (this.recursiveReadCount >= this.recursiveReadLimit)
	            throw new cursor_js_1$6.RecursiveReadLimitExceededError({
	                count: this.recursiveReadCount + 1,
	                limit: this.recursiveReadLimit,
	            });
	    },
	    assertPosition(position) {
	        if (position < 0 || position > this.bytes.length - 1)
	            throw new cursor_js_1$6.PositionOutOfBoundsError({
	                length: this.bytes.length,
	                position,
	            });
	    },
	    decrementPosition(offset) {
	        if (offset < 0)
	            throw new cursor_js_1$6.NegativeOffsetError({ offset });
	        const position = this.position - offset;
	        this.assertPosition(position);
	        this.position = position;
	    },
	    getReadCount(position) {
	        return this.positionReadCount.get(position || this.position) || 0;
	    },
	    incrementPosition(offset) {
	        if (offset < 0)
	            throw new cursor_js_1$6.NegativeOffsetError({ offset });
	        const position = this.position + offset;
	        this.assertPosition(position);
	        this.position = position;
	    },
	    inspectByte(position_) {
	        const position = position_ ?? this.position;
	        this.assertPosition(position);
	        return this.bytes[position];
	    },
	    inspectBytes(length, position_) {
	        const position = position_ ?? this.position;
	        this.assertPosition(position + length - 1);
	        return this.bytes.subarray(position, position + length);
	    },
	    inspectUint8(position_) {
	        const position = position_ ?? this.position;
	        this.assertPosition(position);
	        return this.bytes[position];
	    },
	    inspectUint16(position_) {
	        const position = position_ ?? this.position;
	        this.assertPosition(position + 1);
	        return this.dataView.getUint16(position);
	    },
	    inspectUint24(position_) {
	        const position = position_ ?? this.position;
	        this.assertPosition(position + 2);
	        return ((this.dataView.getUint16(position) << 8) +
	            this.dataView.getUint8(position + 2));
	    },
	    inspectUint32(position_) {
	        const position = position_ ?? this.position;
	        this.assertPosition(position + 3);
	        return this.dataView.getUint32(position);
	    },
	    pushByte(byte) {
	        this.assertPosition(this.position);
	        this.bytes[this.position] = byte;
	        this.position++;
	    },
	    pushBytes(bytes) {
	        this.assertPosition(this.position + bytes.length - 1);
	        this.bytes.set(bytes, this.position);
	        this.position += bytes.length;
	    },
	    pushUint8(value) {
	        this.assertPosition(this.position);
	        this.bytes[this.position] = value;
	        this.position++;
	    },
	    pushUint16(value) {
	        this.assertPosition(this.position + 1);
	        this.dataView.setUint16(this.position, value);
	        this.position += 2;
	    },
	    pushUint24(value) {
	        this.assertPosition(this.position + 2);
	        this.dataView.setUint16(this.position, value >> 8);
	        this.dataView.setUint8(this.position + 2, value & ~4294967040);
	        this.position += 3;
	    },
	    pushUint32(value) {
	        this.assertPosition(this.position + 3);
	        this.dataView.setUint32(this.position, value);
	        this.position += 4;
	    },
	    readByte() {
	        this.assertReadLimit();
	        this._touch();
	        const value = this.inspectByte();
	        this.position++;
	        return value;
	    },
	    readBytes(length, size) {
	        this.assertReadLimit();
	        this._touch();
	        const value = this.inspectBytes(length);
	        this.position += size ?? length;
	        return value;
	    },
	    readUint8() {
	        this.assertReadLimit();
	        this._touch();
	        const value = this.inspectUint8();
	        this.position += 1;
	        return value;
	    },
	    readUint16() {
	        this.assertReadLimit();
	        this._touch();
	        const value = this.inspectUint16();
	        this.position += 2;
	        return value;
	    },
	    readUint24() {
	        this.assertReadLimit();
	        this._touch();
	        const value = this.inspectUint24();
	        this.position += 3;
	        return value;
	    },
	    readUint32() {
	        this.assertReadLimit();
	        this._touch();
	        const value = this.inspectUint32();
	        this.position += 4;
	        return value;
	    },
	    get remaining() {
	        return this.bytes.length - this.position;
	    },
	    setPosition(position) {
	        const oldPosition = this.position;
	        this.assertPosition(position);
	        this.position = position;
	        return () => (this.position = oldPosition);
	    },
	    _touch() {
	        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
	            return;
	        const count = this.getReadCount();
	        this.positionReadCount.set(this.position, count + 1);
	        if (count > 0)
	            this.recursiveReadCount++;
	    },
	};
	function createCursor(bytes, { recursiveReadLimit = 8_192 } = {}) {
	    const cursor = Object.create(staticCursor);
	    cursor.bytes = bytes;
	    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
	    cursor.positionReadCount = new Map();
	    cursor.recursiveReadLimit = recursiveReadLimit;
	    return cursor;
	}

	var fromBytes$3 = {};

	Object.defineProperty(fromBytes$3, "__esModule", { value: true });
	fromBytes$3.fromBytes = fromBytes$2;
	fromBytes$3.bytesToBigInt = bytesToBigInt$1;
	fromBytes$3.bytesToBool = bytesToBool$1;
	fromBytes$3.bytesToNumber = bytesToNumber$1;
	fromBytes$3.bytesToString = bytesToString$1;
	const encoding_js_1$1 = encoding;
	const trim_js_1$4 = trim$3;
	const fromHex_js_1$c = requireFromHex();
	const toHex_js_1$P = requireToHex();
	function fromBytes$2(bytes, toOrOpts) {
	    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;
	    const to = opts.to;
	    if (to === 'number')
	        return bytesToNumber$1(bytes, opts);
	    if (to === 'bigint')
	        return bytesToBigInt$1(bytes, opts);
	    if (to === 'boolean')
	        return bytesToBool$1(bytes, opts);
	    if (to === 'string')
	        return bytesToString$1(bytes, opts);
	    return (0, toHex_js_1$P.bytesToHex)(bytes, opts);
	}
	function bytesToBigInt$1(bytes, opts = {}) {
	    if (typeof opts.size !== 'undefined')
	        (0, fromHex_js_1$c.assertSize)(bytes, { size: opts.size });
	    const hex = (0, toHex_js_1$P.bytesToHex)(bytes, opts);
	    return (0, fromHex_js_1$c.hexToBigInt)(hex, opts);
	}
	function bytesToBool$1(bytes_, opts = {}) {
	    let bytes = bytes_;
	    if (typeof opts.size !== 'undefined') {
	        (0, fromHex_js_1$c.assertSize)(bytes, { size: opts.size });
	        bytes = (0, trim_js_1$4.trim)(bytes);
	    }
	    if (bytes.length > 1 || bytes[0] > 1)
	        throw new encoding_js_1$1.InvalidBytesBooleanError(bytes);
	    return Boolean(bytes[0]);
	}
	function bytesToNumber$1(bytes, opts = {}) {
	    if (typeof opts.size !== 'undefined')
	        (0, fromHex_js_1$c.assertSize)(bytes, { size: opts.size });
	    const hex = (0, toHex_js_1$P.bytesToHex)(bytes, opts);
	    return (0, fromHex_js_1$c.hexToNumber)(hex, opts);
	}
	function bytesToString$1(bytes_, opts = {}) {
	    let bytes = bytes_;
	    if (typeof opts.size !== 'undefined') {
	        (0, fromHex_js_1$c.assertSize)(bytes, { size: opts.size });
	        bytes = (0, trim_js_1$4.trim)(bytes, { dir: 'right' });
	    }
	    return new TextDecoder().decode(bytes);
	}

	Object.defineProperty(decodeAbiParameters$1, "__esModule", { value: true });
	decodeAbiParameters$1.decodeAbiParameters = decodeAbiParameters;
	const abi_js_1$f = requireAbi();
	const getAddress_js_1$8 = requireGetAddress();
	const cursor_js_1$5 = cursor$1;
	const size_js_1$5 = size$2;
	const slice_js_1$6 = slice$1;
	const trim_js_1$3 = trim$3;
	const fromBytes_js_1 = fromBytes$3;
	const toBytes_js_1$j = requireToBytes();
	const toHex_js_1$O = requireToHex();
	const encodeAbiParameters_js_1$7 = encodeAbiParameters$3;
	function decodeAbiParameters(params, data) {
	    const bytes = typeof data === 'string' ? (0, toBytes_js_1$j.hexToBytes)(data) : data;
	    const cursor = (0, cursor_js_1$5.createCursor)(bytes);
	    if ((0, size_js_1$5.size)(bytes) === 0 && params.length > 0)
	        throw new abi_js_1$f.AbiDecodingZeroDataError();
	    if ((0, size_js_1$5.size)(data) && (0, size_js_1$5.size)(data) < 32)
	        throw new abi_js_1$f.AbiDecodingDataSizeTooSmallError({
	            data: typeof data === 'string' ? data : (0, toHex_js_1$O.bytesToHex)(data),
	            params: params,
	            size: (0, size_js_1$5.size)(data),
	        });
	    let consumed = 0;
	    const values = [];
	    for (let i = 0; i < params.length; ++i) {
	        const param = params[i];
	        cursor.setPosition(consumed);
	        const [data, consumed_] = decodeParameter(cursor, param, {
	            staticPosition: 0,
	        });
	        consumed += consumed_;
	        values.push(data);
	    }
	    return values;
	}
	function decodeParameter(cursor, param, { staticPosition }) {
	    const arrayComponents = (0, encodeAbiParameters_js_1$7.getArrayComponents)(param.type);
	    if (arrayComponents) {
	        const [length, type] = arrayComponents;
	        return decodeArray(cursor, { ...param, type }, { length, staticPosition });
	    }
	    if (param.type === 'tuple')
	        return decodeTuple(cursor, param, { staticPosition });
	    if (param.type === 'address')
	        return decodeAddress(cursor);
	    if (param.type === 'bool')
	        return decodeBool(cursor);
	    if (param.type.startsWith('bytes'))
	        return decodeBytes(cursor, param, { staticPosition });
	    if (param.type.startsWith('uint') || param.type.startsWith('int'))
	        return decodeNumber(cursor, param);
	    if (param.type === 'string')
	        return decodeString(cursor, { staticPosition });
	    throw new abi_js_1$f.InvalidAbiDecodingTypeError(param.type, {
	        docsPath: '/docs/contract/decodeAbiParameters',
	    });
	}
	const sizeOfLength = 32;
	const sizeOfOffset = 32;
	function decodeAddress(cursor) {
	    const value = cursor.readBytes(32);
	    return [(0, getAddress_js_1$8.checksumAddress)((0, toHex_js_1$O.bytesToHex)((0, slice_js_1$6.sliceBytes)(value, -20))), 32];
	}
	function decodeArray(cursor, param, { length, staticPosition }) {
	    if (!length) {
	        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));
	        const start = staticPosition + offset;
	        const startOfData = start + sizeOfLength;
	        cursor.setPosition(start);
	        const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfLength));
	        const dynamicChild = hasDynamicChild(param);
	        let consumed = 0;
	        const value = [];
	        for (let i = 0; i < length; ++i) {
	            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));
	            const [data, consumed_] = decodeParameter(cursor, param, {
	                staticPosition: startOfData,
	            });
	            consumed += consumed_;
	            value.push(data);
	        }
	        cursor.setPosition(staticPosition + 32);
	        return [value, 32];
	    }
	    if (hasDynamicChild(param)) {
	        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));
	        const start = staticPosition + offset;
	        const value = [];
	        for (let i = 0; i < length; ++i) {
	            cursor.setPosition(start + i * 32);
	            const [data] = decodeParameter(cursor, param, {
	                staticPosition: start,
	            });
	            value.push(data);
	        }
	        cursor.setPosition(staticPosition + 32);
	        return [value, 32];
	    }
	    let consumed = 0;
	    const value = [];
	    for (let i = 0; i < length; ++i) {
	        const [data, consumed_] = decodeParameter(cursor, param, {
	            staticPosition: staticPosition + consumed,
	        });
	        consumed += consumed_;
	        value.push(data);
	    }
	    return [value, consumed];
	}
	function decodeBool(cursor) {
	    return [(0, fromBytes_js_1.bytesToBool)(cursor.readBytes(32), { size: 32 }), 32];
	}
	function decodeBytes(cursor, param, { staticPosition }) {
	    const [_, size] = param.type.split('bytes');
	    if (!size) {
	        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
	        cursor.setPosition(staticPosition + offset);
	        const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
	        if (length === 0) {
	            cursor.setPosition(staticPosition + 32);
	            return ['0x', 32];
	        }
	        const data = cursor.readBytes(length);
	        cursor.setPosition(staticPosition + 32);
	        return [(0, toHex_js_1$O.bytesToHex)(data), 32];
	    }
	    const value = (0, toHex_js_1$O.bytesToHex)(cursor.readBytes(Number.parseInt(size), 32));
	    return [value, 32];
	}
	function decodeNumber(cursor, param) {
	    const signed = param.type.startsWith('int');
	    const size = Number.parseInt(param.type.split('int')[1] || '256');
	    const value = cursor.readBytes(32);
	    return [
	        size > 48
	            ? (0, fromBytes_js_1.bytesToBigInt)(value, { signed })
	            : (0, fromBytes_js_1.bytesToNumber)(value, { signed }),
	        32,
	    ];
	}
	function decodeTuple(cursor, param, { staticPosition }) {
	    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
	    const value = hasUnnamedChild ? [] : {};
	    let consumed = 0;
	    if (hasDynamicChild(param)) {
	        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));
	        const start = staticPosition + offset;
	        for (let i = 0; i < param.components.length; ++i) {
	            const component = param.components[i];
	            cursor.setPosition(start + consumed);
	            const [data, consumed_] = decodeParameter(cursor, component, {
	                staticPosition: start,
	            });
	            consumed += consumed_;
	            value[hasUnnamedChild ? i : component?.name] = data;
	        }
	        cursor.setPosition(staticPosition + 32);
	        return [value, 32];
	    }
	    for (let i = 0; i < param.components.length; ++i) {
	        const component = param.components[i];
	        const [data, consumed_] = decodeParameter(cursor, component, {
	            staticPosition,
	        });
	        value[hasUnnamedChild ? i : component?.name] = data;
	        consumed += consumed_;
	    }
	    return [value, consumed];
	}
	function decodeString(cursor, { staticPosition }) {
	    const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
	    const start = staticPosition + offset;
	    cursor.setPosition(start);
	    const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
	    if (length === 0) {
	        cursor.setPosition(staticPosition + 32);
	        return ['', 32];
	    }
	    const data = cursor.readBytes(length, 32);
	    const value = (0, fromBytes_js_1.bytesToString)((0, trim_js_1$3.trim)(data));
	    cursor.setPosition(staticPosition + 32);
	    return [value, 32];
	}
	function hasDynamicChild(param) {
	    const { type } = param;
	    if (type === 'string')
	        return true;
	    if (type === 'bytes')
	        return true;
	    if (type.endsWith('[]'))
	        return true;
	    if (type === 'tuple')
	        return param.components?.some(hasDynamicChild);
	    const arrayComponents = (0, encodeAbiParameters_js_1$7.getArrayComponents)(param.type);
	    if (arrayComponents &&
	        hasDynamicChild({ ...param, type: arrayComponents[1] }))
	        return true;
	    return false;
	}

	Object.defineProperty(decodeErrorResult$1, "__esModule", { value: true });
	decodeErrorResult$1.decodeErrorResult = decodeErrorResult;
	const solidity_js_1$2 = solidity;
	const abi_js_1$e = requireAbi();
	const slice_js_1$5 = slice$1;
	const toFunctionSelector_js_1$2 = toFunctionSelector$1;
	const decodeAbiParameters_js_1$5 = decodeAbiParameters$1;
	const formatAbiItem_js_1$4 = requireFormatAbiItem();
	function decodeErrorResult(parameters) {
	    const { abi, data } = parameters;
	    const signature = (0, slice_js_1$5.slice)(data, 0, 4);
	    if (signature === '0x')
	        throw new abi_js_1$e.AbiDecodingZeroDataError();
	    const abi_ = [...(abi || []), solidity_js_1$2.solidityError, solidity_js_1$2.solidityPanic];
	    const abiItem = abi_.find((x) => x.type === 'error' && signature === (0, toFunctionSelector_js_1$2.toFunctionSelector)((0, formatAbiItem_js_1$4.formatAbiItem)(x)));
	    if (!abiItem)
	        throw new abi_js_1$e.AbiErrorSignatureNotFoundError(signature, {
	            docsPath: '/docs/contract/decodeErrorResult',
	        });
	    return {
	        abiItem,
	        args: 'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0
	            ? (0, decodeAbiParameters_js_1$5.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1$5.slice)(data, 4))
	            : undefined,
	        errorName: abiItem.name,
	    };
	}

	var formatAbiItemWithArgs$1 = {};

	var stringify$1 = {};

	Object.defineProperty(stringify$1, "__esModule", { value: true });
	stringify$1.stringify = void 0;
	const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
	    const value = typeof value_ === 'bigint' ? value_.toString() : value_;
	    return typeof replacer === 'function' ? replacer(key, value) : value;
	}, space);
	stringify$1.stringify = stringify;

	Object.defineProperty(formatAbiItemWithArgs$1, "__esModule", { value: true });
	formatAbiItemWithArgs$1.formatAbiItemWithArgs = formatAbiItemWithArgs;
	const stringify_js_1$a = stringify$1;
	function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false, }) {
	    if (!('name' in abiItem))
	        return;
	    if (!('inputs' in abiItem))
	        return;
	    if (!abiItem.inputs)
	        return;
	    return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs
        .map((input, i) => `${includeName && input.name ? `${input.name}: ` : ''}${typeof args[i] === 'object' ? (0, stringify_js_1$a.stringify)(args[i]) : args[i]}`)
        .join(', ')})`;
	}

	var formatEther$1 = {};

	var unit = {};

	Object.defineProperty(unit, "__esModule", { value: true });
	unit.weiUnits = unit.gweiUnits = unit.etherUnits = void 0;
	unit.etherUnits = {
	    gwei: 9,
	    wei: 18,
	};
	unit.gweiUnits = {
	    ether: -9,
	    wei: 9,
	};
	unit.weiUnits = {
	    ether: -18,
	    gwei: -9,
	};

	var formatUnits$1 = {};

	Object.defineProperty(formatUnits$1, "__esModule", { value: true });
	formatUnits$1.formatUnits = formatUnits;
	function formatUnits(value, decimals) {
	    let display = value.toString();
	    const negative = display.startsWith('-');
	    if (negative)
	        display = display.slice(1);
	    display = display.padStart(decimals, '0');
	    let [integer, fraction] = [
	        display.slice(0, display.length - decimals),
	        display.slice(display.length - decimals),
	    ];
	    fraction = fraction.replace(/(0+)$/, '');
	    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
	}

	Object.defineProperty(formatEther$1, "__esModule", { value: true });
	formatEther$1.formatEther = formatEther;
	const unit_js_1$3 = unit;
	const formatUnits_js_1$1 = formatUnits$1;
	function formatEther(wei, unit = 'wei') {
	    return (0, formatUnits_js_1$1.formatUnits)(wei, unit_js_1$3.etherUnits[unit]);
	}

	var formatGwei$1 = {};

	Object.defineProperty(formatGwei$1, "__esModule", { value: true });
	formatGwei$1.formatGwei = formatGwei;
	const unit_js_1$2 = unit;
	const formatUnits_js_1 = formatUnits$1;
	function formatGwei(wei, unit = 'wei') {
	    return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1$2.gweiUnits[unit]);
	}

	var stateOverride$1 = {};

	Object.defineProperty(stateOverride$1, "__esModule", { value: true });
	stateOverride$1.StateAssignmentConflictError = stateOverride$1.AccountStateConflictError = void 0;
	stateOverride$1.prettyStateMapping = prettyStateMapping;
	stateOverride$1.prettyStateOverride = prettyStateOverride;
	const base_js_1$p = base$1;
	class AccountStateConflictError extends base_js_1$p.BaseError {
	    constructor({ address }) {
	        super(`State for account "${address}" is set multiple times.`, {
	            name: 'AccountStateConflictError',
	        });
	    }
	}
	stateOverride$1.AccountStateConflictError = AccountStateConflictError;
	class StateAssignmentConflictError extends base_js_1$p.BaseError {
	    constructor() {
	        super('state and stateDiff are set on the same account.', {
	            name: 'StateAssignmentConflictError',
	        });
	    }
	}
	stateOverride$1.StateAssignmentConflictError = StateAssignmentConflictError;
	function prettyStateMapping(stateMapping) {
	    return stateMapping.reduce((pretty, { slot, value }) => {
	        return `${pretty}        ${slot}: ${value}\n`;
	    }, '');
	}
	function prettyStateOverride(stateOverride) {
	    return stateOverride
	        .reduce((pretty, { address, ...state }) => {
	        let val = `${pretty}    ${address}:\n`;
	        if (state.nonce)
	            val += `      nonce: ${state.nonce}\n`;
	        if (state.balance)
	            val += `      balance: ${state.balance}\n`;
	        if (state.code)
	            val += `      code: ${state.code}\n`;
	        if (state.state) {
	            val += '      state:\n';
	            val += prettyStateMapping(state.state);
	        }
	        if (state.stateDiff) {
	            val += '      stateDiff:\n';
	            val += prettyStateMapping(state.stateDiff);
	        }
	        return val;
	    }, '  State Override:\n')
	        .slice(0, -1);
	}

	var transaction$1 = {};

	Object.defineProperty(transaction$1, "__esModule", { value: true });
	transaction$1.WaitForTransactionReceiptTimeoutError = transaction$1.TransactionReceiptNotFoundError = transaction$1.TransactionNotFoundError = transaction$1.TransactionExecutionError = transaction$1.InvalidStorageKeySizeError = transaction$1.InvalidSerializedTransactionError = transaction$1.InvalidSerializedTransactionTypeError = transaction$1.InvalidSerializableTransactionError = transaction$1.InvalidLegacyVError = transaction$1.FeeConflictError = void 0;
	transaction$1.prettyPrint = prettyPrint;
	const formatEther_js_1$2 = formatEther$1;
	const formatGwei_js_1$4 = formatGwei$1;
	const base_js_1$o = base$1;
	function prettyPrint(args) {
	    const entries = Object.entries(args)
	        .map(([key, value]) => {
	        if (value === undefined || value === false)
	            return null;
	        return [key, value];
	    })
	        .filter(Boolean);
	    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
	    return entries
	        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
	        .join('\n');
	}
	class FeeConflictError extends base_js_1$o.BaseError {
	    constructor() {
	        super([
	            'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
	            'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',
	        ].join('\n'), { name: 'FeeConflictError' });
	    }
	}
	transaction$1.FeeConflictError = FeeConflictError;
	class InvalidLegacyVError extends base_js_1$o.BaseError {
	    constructor({ v }) {
	        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
	            name: 'InvalidLegacyVError',
	        });
	    }
	}
	transaction$1.InvalidLegacyVError = InvalidLegacyVError;
	class InvalidSerializableTransactionError extends base_js_1$o.BaseError {
	    constructor({ transaction }) {
	        super('Cannot infer a transaction type from provided transaction.', {
	            metaMessages: [
	                'Provided Transaction:',
	                '{',
	                prettyPrint(transaction),
	                '}',
	                '',
	                'To infer the type, either provide:',
	                '- a `type` to the Transaction, or',
	                '- an EIP-1559 Transaction with `maxFeePerGas`, or',
	                '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
	                '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',
	                '- an EIP-7702 Transaction with `authorizationList`, or',
	                '- a Legacy Transaction with `gasPrice`',
	            ],
	            name: 'InvalidSerializableTransactionError',
	        });
	    }
	}
	transaction$1.InvalidSerializableTransactionError = InvalidSerializableTransactionError;
	class InvalidSerializedTransactionTypeError extends base_js_1$o.BaseError {
	    constructor({ serializedType }) {
	        super(`Serialized transaction type "${serializedType}" is invalid.`, {
	            name: 'InvalidSerializedTransactionType',
	        });
	        Object.defineProperty(this, "serializedType", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.serializedType = serializedType;
	    }
	}
	transaction$1.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
	class InvalidSerializedTransactionError extends base_js_1$o.BaseError {
	    constructor({ attributes, serializedTransaction, type, }) {
	        const missing = Object.entries(attributes)
	            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))
	            .filter(Boolean);
	        super(`Invalid serialized transaction of type "${type}" was provided.`, {
	            metaMessages: [
	                `Serialized Transaction: "${serializedTransaction}"`,
	                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',
	            ].filter(Boolean),
	            name: 'InvalidSerializedTransactionError',
	        });
	        Object.defineProperty(this, "serializedTransaction", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "type", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.serializedTransaction = serializedTransaction;
	        this.type = type;
	    }
	}
	transaction$1.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
	class InvalidStorageKeySizeError extends base_js_1$o.BaseError {
	    constructor({ storageKey }) {
	        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: 'InvalidStorageKeySizeError' });
	    }
	}
	transaction$1.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
	class TransactionExecutionError extends base_js_1$o.BaseError {
	    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
	        const prettyArgs = prettyPrint({
	            chain: chain && `${chain?.name} (id: ${chain?.id})`,
	            from: account?.address,
	            to,
	            value: typeof value !== 'undefined' &&
	                `${(0, formatEther_js_1$2.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
	            data,
	            gas,
	            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1$4.formatGwei)(gasPrice)} gwei`,
	            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
	                `${(0, formatGwei_js_1$4.formatGwei)(maxFeePerGas)} gwei`,
	            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
	                `${(0, formatGwei_js_1$4.formatGwei)(maxPriorityFeePerGas)} gwei`,
	            nonce,
	        });
	        super(cause.shortMessage, {
	            cause,
	            docsPath,
	            metaMessages: [
	                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
	                'Request Arguments:',
	                prettyArgs,
	            ].filter(Boolean),
	            name: 'TransactionExecutionError',
	        });
	        Object.defineProperty(this, "cause", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.cause = cause;
	    }
	}
	transaction$1.TransactionExecutionError = TransactionExecutionError;
	class TransactionNotFoundError extends base_js_1$o.BaseError {
	    constructor({ blockHash, blockNumber, blockTag, hash, index, }) {
	        let identifier = 'Transaction';
	        if (blockTag && index !== undefined)
	            identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
	        if (blockHash && index !== undefined)
	            identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
	        if (blockNumber && index !== undefined)
	            identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
	        if (hash)
	            identifier = `Transaction with hash "${hash}"`;
	        super(`${identifier} could not be found.`, {
	            name: 'TransactionNotFoundError',
	        });
	    }
	}
	transaction$1.TransactionNotFoundError = TransactionNotFoundError;
	class TransactionReceiptNotFoundError extends base_js_1$o.BaseError {
	    constructor({ hash }) {
	        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`, {
	            name: 'TransactionReceiptNotFoundError',
	        });
	    }
	}
	transaction$1.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;
	class WaitForTransactionReceiptTimeoutError extends base_js_1$o.BaseError {
	    constructor({ hash }) {
	        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`, { name: 'WaitForTransactionReceiptTimeoutError' });
	    }
	}
	transaction$1.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;

	var utils$5 = {};

	Object.defineProperty(utils$5, "__esModule", { value: true });
	utils$5.getUrl = utils$5.getContractAddress = void 0;
	const getContractAddress$2 = (address) => address;
	utils$5.getContractAddress = getContractAddress$2;
	const getUrl = (url) => url;
	utils$5.getUrl = getUrl;

	Object.defineProperty(contract$2, "__esModule", { value: true });
	contract$2.RawContractError = contract$2.CounterfactualDeploymentFailedError = contract$2.ContractFunctionZeroDataError = contract$2.ContractFunctionRevertedError = contract$2.ContractFunctionExecutionError = contract$2.CallExecutionError = void 0;
	const parseAccount_js_1$9 = parseAccount$1;
	const solidity_js_1$1 = solidity;
	const decodeErrorResult_js_1 = decodeErrorResult$1;
	const formatAbiItem_js_1$3 = requireFormatAbiItem();
	const formatAbiItemWithArgs_js_1 = formatAbiItemWithArgs$1;
	const getAbiItem_js_1$5 = getAbiItem$1;
	const formatEther_js_1$1 = formatEther$1;
	const formatGwei_js_1$3 = formatGwei$1;
	const abi_js_1$d = requireAbi();
	const base_js_1$n = base$1;
	const stateOverride_js_1$1 = stateOverride$1;
	const transaction_js_1$b = transaction$1;
	const utils_js_1$j = utils$5;
	class CallExecutionError extends base_js_1$n.BaseError {
	    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, }) {
	        const account = account_ ? (0, parseAccount_js_1$9.parseAccount)(account_) : undefined;
	        let prettyArgs = (0, transaction_js_1$b.prettyPrint)({
	            from: account?.address,
	            to,
	            value: typeof value !== 'undefined' &&
	                `${(0, formatEther_js_1$1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
	            data,
	            gas,
	            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1$3.formatGwei)(gasPrice)} gwei`,
	            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
	                `${(0, formatGwei_js_1$3.formatGwei)(maxFeePerGas)} gwei`,
	            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
	                `${(0, formatGwei_js_1$3.formatGwei)(maxPriorityFeePerGas)} gwei`,
	            nonce,
	        });
	        if (stateOverride) {
	            prettyArgs += `\n${(0, stateOverride_js_1$1.prettyStateOverride)(stateOverride)}`;
	        }
	        super(cause.shortMessage, {
	            cause,
	            docsPath,
	            metaMessages: [
	                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
	                'Raw Call Arguments:',
	                prettyArgs,
	            ].filter(Boolean),
	            name: 'CallExecutionError',
	        });
	        Object.defineProperty(this, "cause", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.cause = cause;
	    }
	}
	contract$2.CallExecutionError = CallExecutionError;
	class ContractFunctionExecutionError extends base_js_1$n.BaseError {
	    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender, }) {
	        const abiItem = (0, getAbiItem_js_1$5.getAbiItem)({ abi, args, name: functionName });
	        const formattedArgs = abiItem
	            ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
	                abiItem,
	                args,
	                includeFunctionName: false,
	                includeName: false,
	            })
	            : undefined;
	        const functionWithParams = abiItem
	            ? (0, formatAbiItem_js_1$3.formatAbiItem)(abiItem, { includeName: true })
	            : undefined;
	        const prettyArgs = (0, transaction_js_1$b.prettyPrint)({
	            address: contractAddress && (0, utils_js_1$j.getContractAddress)(contractAddress),
	            function: functionWithParams,
	            args: formattedArgs &&
	                formattedArgs !== '()' &&
	                `${[...Array(functionName?.length ?? 0).keys()]
                    .map(() => ' ')
                    .join('')}${formattedArgs}`,
	            sender,
	        });
	        super(cause.shortMessage ||
	            `An unknown error occurred while executing the contract function "${functionName}".`, {
	            cause,
	            docsPath,
	            metaMessages: [
	                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
	                prettyArgs && 'Contract Call:',
	                prettyArgs,
	            ].filter(Boolean),
	            name: 'ContractFunctionExecutionError',
	        });
	        Object.defineProperty(this, "abi", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "args", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "cause", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "contractAddress", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "formattedArgs", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "functionName", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "sender", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.abi = abi;
	        this.args = args;
	        this.cause = cause;
	        this.contractAddress = contractAddress;
	        this.functionName = functionName;
	        this.sender = sender;
	    }
	}
	contract$2.ContractFunctionExecutionError = ContractFunctionExecutionError;
	class ContractFunctionRevertedError extends base_js_1$n.BaseError {
	    constructor({ abi, data, functionName, message, }) {
	        let cause;
	        let decodedData = undefined;
	        let metaMessages;
	        let reason;
	        if (data && data !== '0x') {
	            try {
	                decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
	                const { abiItem, errorName, args: errorArgs } = decodedData;
	                if (errorName === 'Error') {
	                    reason = errorArgs[0];
	                }
	                else if (errorName === 'Panic') {
	                    const [firstArg] = errorArgs;
	                    reason = solidity_js_1$1.panicReasons[firstArg];
	                }
	                else {
	                    const errorWithParams = abiItem
	                        ? (0, formatAbiItem_js_1$3.formatAbiItem)(abiItem, { includeName: true })
	                        : undefined;
	                    const formattedArgs = abiItem && errorArgs
	                        ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
	                            abiItem,
	                            args: errorArgs,
	                            includeFunctionName: false,
	                            includeName: false,
	                        })
	                        : undefined;
	                    metaMessages = [
	                        errorWithParams ? `Error: ${errorWithParams}` : '',
	                        formattedArgs && formattedArgs !== '()'
	                            ? `       ${[...Array(errorName?.length ?? 0).keys()]
                                .map(() => ' ')
                                .join('')}${formattedArgs}`
	                            : '',
	                    ];
	                }
	            }
	            catch (err) {
	                cause = err;
	            }
	        }
	        else if (message)
	            reason = message;
	        let signature;
	        if (cause instanceof abi_js_1$d.AbiErrorSignatureNotFoundError) {
	            signature = cause.signature;
	            metaMessages = [
	                `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
	                'Make sure you are using the correct ABI and that the error exists on it.',
	                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
	            ];
	        }
	        super((reason && reason !== 'execution reverted') || signature
	            ? [
	                `The contract function "${functionName}" reverted with the following ${signature ? 'signature' : 'reason'}:`,
	                reason || signature,
	            ].join('\n')
	            : `The contract function "${functionName}" reverted.`, {
	            cause,
	            metaMessages,
	            name: 'ContractFunctionRevertedError',
	        });
	        Object.defineProperty(this, "data", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "reason", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "signature", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.data = decodedData;
	        this.reason = reason;
	        this.signature = signature;
	    }
	}
	contract$2.ContractFunctionRevertedError = ContractFunctionRevertedError;
	class ContractFunctionZeroDataError extends base_js_1$n.BaseError {
	    constructor({ functionName }) {
	        super(`The contract function "${functionName}" returned no data ("0x").`, {
	            metaMessages: [
	                'This could be due to any of the following:',
	                `  - The contract does not have the function "${functionName}",`,
	                '  - The parameters passed to the contract function may be invalid, or',
	                '  - The address is not a contract.',
	            ],
	            name: 'ContractFunctionZeroDataError',
	        });
	    }
	}
	contract$2.ContractFunctionZeroDataError = ContractFunctionZeroDataError;
	class CounterfactualDeploymentFailedError extends base_js_1$n.BaseError {
	    constructor({ factory }) {
	        super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ''}`, {
	            metaMessages: [
	                'Please ensure:',
	                '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
	                '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.',
	            ],
	            name: 'CounterfactualDeploymentFailedError',
	        });
	    }
	}
	contract$2.CounterfactualDeploymentFailedError = CounterfactualDeploymentFailedError;
	class RawContractError extends base_js_1$n.BaseError {
	    constructor({ data, message, }) {
	        super(message || '', { name: 'RawContractError' });
	        Object.defineProperty(this, "code", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 3
	        });
	        Object.defineProperty(this, "data", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.data = data;
	    }
	}
	contract$2.RawContractError = RawContractError;

	var rpc = {};

	var request = {};

	Object.defineProperty(request, "__esModule", { value: true });
	request.TimeoutError = request.SocketClosedError = request.RpcRequestError = request.WebSocketRequestError = request.HttpRequestError = void 0;
	const stringify_js_1$9 = stringify$1;
	const base_js_1$m = base$1;
	const utils_js_1$i = utils$5;
	class HttpRequestError extends base_js_1$m.BaseError {
	    constructor({ body, cause, details, headers, status, url, }) {
	        super('HTTP request failed.', {
	            cause,
	            details,
	            metaMessages: [
	                status && `Status: ${status}`,
	                `URL: ${(0, utils_js_1$i.getUrl)(url)}`,
	                body && `Request body: ${(0, stringify_js_1$9.stringify)(body)}`,
	            ].filter(Boolean),
	            name: 'HttpRequestError',
	        });
	        Object.defineProperty(this, "body", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "headers", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "status", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "url", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.body = body;
	        this.headers = headers;
	        this.status = status;
	        this.url = url;
	    }
	}
	request.HttpRequestError = HttpRequestError;
	class WebSocketRequestError extends base_js_1$m.BaseError {
	    constructor({ body, cause, details, url, }) {
	        super('WebSocket request failed.', {
	            cause,
	            details,
	            metaMessages: [
	                `URL: ${(0, utils_js_1$i.getUrl)(url)}`,
	                body && `Request body: ${(0, stringify_js_1$9.stringify)(body)}`,
	            ].filter(Boolean),
	            name: 'WebSocketRequestError',
	        });
	    }
	}
	request.WebSocketRequestError = WebSocketRequestError;
	class RpcRequestError extends base_js_1$m.BaseError {
	    constructor({ body, error, url, }) {
	        super('RPC Request failed.', {
	            cause: error,
	            details: error.message,
	            metaMessages: [`URL: ${(0, utils_js_1$i.getUrl)(url)}`, `Request body: ${(0, stringify_js_1$9.stringify)(body)}`],
	            name: 'RpcRequestError',
	        });
	        Object.defineProperty(this, "code", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.code = error.code;
	    }
	}
	request.RpcRequestError = RpcRequestError;
	class SocketClosedError extends base_js_1$m.BaseError {
	    constructor({ url, } = {}) {
	        super('The socket has been closed.', {
	            metaMessages: [url && `URL: ${(0, utils_js_1$i.getUrl)(url)}`].filter(Boolean),
	            name: 'SocketClosedError',
	        });
	    }
	}
	request.SocketClosedError = SocketClosedError;
	class TimeoutError extends base_js_1$m.BaseError {
	    constructor({ body, url, }) {
	        super('The request took too long to respond.', {
	            details: 'The request timed out.',
	            metaMessages: [`URL: ${(0, utils_js_1$i.getUrl)(url)}`, `Request body: ${(0, stringify_js_1$9.stringify)(body)}`],
	            name: 'TimeoutError',
	        });
	    }
	}
	request.TimeoutError = TimeoutError;

	Object.defineProperty(rpc, "__esModule", { value: true });
	rpc.UnknownRpcError = rpc.SwitchChainError = rpc.ChainDisconnectedError = rpc.ProviderDisconnectedError = rpc.UnsupportedProviderMethodError = rpc.UnauthorizedProviderError = rpc.UserRejectedRequestError = rpc.JsonRpcVersionUnsupportedError = rpc.LimitExceededRpcError = rpc.MethodNotSupportedRpcError = rpc.TransactionRejectedRpcError = rpc.ResourceUnavailableRpcError = rpc.ResourceNotFoundRpcError = rpc.InvalidInputRpcError = rpc.InternalRpcError = rpc.InvalidParamsRpcError = rpc.MethodNotFoundRpcError = rpc.InvalidRequestRpcError = rpc.ParseRpcError = rpc.ProviderRpcError = rpc.RpcError = void 0;
	const base_js_1$l = base$1;
	const request_js_1$6 = request;
	const unknownErrorCode = -1;
	class RpcError extends base_js_1$l.BaseError {
	    constructor(cause, { code, docsPath, metaMessages, name, shortMessage, }) {
	        super(shortMessage, {
	            cause,
	            docsPath,
	            metaMessages: metaMessages || cause?.metaMessages,
	            name: name || 'RpcError',
	        });
	        Object.defineProperty(this, "code", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.name = name || cause.name;
	        this.code = (cause instanceof request_js_1$6.RpcRequestError ? cause.code : code ?? unknownErrorCode);
	    }
	}
	rpc.RpcError = RpcError;
	class ProviderRpcError$1 extends RpcError {
	    constructor(cause, options) {
	        super(cause, options);
	        Object.defineProperty(this, "data", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.data = options.data;
	    }
	}
	rpc.ProviderRpcError = ProviderRpcError$1;
	class ParseRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: ParseRpcError.code,
	            name: 'ParseRpcError',
	            shortMessage: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
	        });
	    }
	}
	rpc.ParseRpcError = ParseRpcError;
	Object.defineProperty(ParseRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32700
	});
	class InvalidRequestRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: InvalidRequestRpcError.code,
	            name: 'InvalidRequestRpcError',
	            shortMessage: 'JSON is not a valid request object.',
	        });
	    }
	}
	rpc.InvalidRequestRpcError = InvalidRequestRpcError;
	Object.defineProperty(InvalidRequestRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32600
	});
	class MethodNotFoundRpcError extends RpcError {
	    constructor(cause, { method } = {}) {
	        super(cause, {
	            code: MethodNotFoundRpcError.code,
	            name: 'MethodNotFoundRpcError',
	            shortMessage: `The method${method ? ` "${method}"` : ''} does not exist / is not available.`,
	        });
	    }
	}
	rpc.MethodNotFoundRpcError = MethodNotFoundRpcError;
	Object.defineProperty(MethodNotFoundRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32601
	});
	class InvalidParamsRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: InvalidParamsRpcError.code,
	            name: 'InvalidParamsRpcError',
	            shortMessage: [
	                'Invalid parameters were provided to the RPC method.',
	                'Double check you have provided the correct parameters.',
	            ].join('\n'),
	        });
	    }
	}
	rpc.InvalidParamsRpcError = InvalidParamsRpcError;
	Object.defineProperty(InvalidParamsRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32602
	});
	class InternalRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: InternalRpcError.code,
	            name: 'InternalRpcError',
	            shortMessage: 'An internal error was received.',
	        });
	    }
	}
	rpc.InternalRpcError = InternalRpcError;
	Object.defineProperty(InternalRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32603
	});
	class InvalidInputRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: InvalidInputRpcError.code,
	            name: 'InvalidInputRpcError',
	            shortMessage: [
	                'Missing or invalid parameters.',
	                'Double check you have provided the correct parameters.',
	            ].join('\n'),
	        });
	    }
	}
	rpc.InvalidInputRpcError = InvalidInputRpcError;
	Object.defineProperty(InvalidInputRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32000
	});
	class ResourceNotFoundRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: ResourceNotFoundRpcError.code,
	            name: 'ResourceNotFoundRpcError',
	            shortMessage: 'Requested resource not found.',
	        });
	        Object.defineProperty(this, "name", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: 'ResourceNotFoundRpcError'
	        });
	    }
	}
	rpc.ResourceNotFoundRpcError = ResourceNotFoundRpcError;
	Object.defineProperty(ResourceNotFoundRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32001
	});
	class ResourceUnavailableRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: ResourceUnavailableRpcError.code,
	            name: 'ResourceUnavailableRpcError',
	            shortMessage: 'Requested resource not available.',
	        });
	    }
	}
	rpc.ResourceUnavailableRpcError = ResourceUnavailableRpcError;
	Object.defineProperty(ResourceUnavailableRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32002
	});
	class TransactionRejectedRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: TransactionRejectedRpcError.code,
	            name: 'TransactionRejectedRpcError',
	            shortMessage: 'Transaction creation failed.',
	        });
	    }
	}
	rpc.TransactionRejectedRpcError = TransactionRejectedRpcError;
	Object.defineProperty(TransactionRejectedRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32003
	});
	class MethodNotSupportedRpcError extends RpcError {
	    constructor(cause, { method } = {}) {
	        super(cause, {
	            code: MethodNotSupportedRpcError.code,
	            name: 'MethodNotSupportedRpcError',
	            shortMessage: `Method${method ? ` "${method}"` : ''} is not implemented.`,
	        });
	    }
	}
	rpc.MethodNotSupportedRpcError = MethodNotSupportedRpcError;
	Object.defineProperty(MethodNotSupportedRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32004
	});
	class LimitExceededRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: LimitExceededRpcError.code,
	            name: 'LimitExceededRpcError',
	            shortMessage: 'Request exceeds defined limit.',
	        });
	    }
	}
	rpc.LimitExceededRpcError = LimitExceededRpcError;
	Object.defineProperty(LimitExceededRpcError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32005
	});
	class JsonRpcVersionUnsupportedError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            code: JsonRpcVersionUnsupportedError.code,
	            name: 'JsonRpcVersionUnsupportedError',
	            shortMessage: 'Version of JSON-RPC protocol is not supported.',
	        });
	    }
	}
	rpc.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError;
	Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: -32006
	});
	class UserRejectedRequestError extends ProviderRpcError$1 {
	    constructor(cause) {
	        super(cause, {
	            code: UserRejectedRequestError.code,
	            name: 'UserRejectedRequestError',
	            shortMessage: 'User rejected the request.',
	        });
	    }
	}
	rpc.UserRejectedRequestError = UserRejectedRequestError;
	Object.defineProperty(UserRejectedRequestError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 4001
	});
	class UnauthorizedProviderError extends ProviderRpcError$1 {
	    constructor(cause) {
	        super(cause, {
	            code: UnauthorizedProviderError.code,
	            name: 'UnauthorizedProviderError',
	            shortMessage: 'The requested method and/or account has not been authorized by the user.',
	        });
	    }
	}
	rpc.UnauthorizedProviderError = UnauthorizedProviderError;
	Object.defineProperty(UnauthorizedProviderError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 4100
	});
	class UnsupportedProviderMethodError extends ProviderRpcError$1 {
	    constructor(cause, { method } = {}) {
	        super(cause, {
	            code: UnsupportedProviderMethodError.code,
	            name: 'UnsupportedProviderMethodError',
	            shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ''}.`,
	        });
	    }
	}
	rpc.UnsupportedProviderMethodError = UnsupportedProviderMethodError;
	Object.defineProperty(UnsupportedProviderMethodError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 4200
	});
	class ProviderDisconnectedError extends ProviderRpcError$1 {
	    constructor(cause) {
	        super(cause, {
	            code: ProviderDisconnectedError.code,
	            name: 'ProviderDisconnectedError',
	            shortMessage: 'The Provider is disconnected from all chains.',
	        });
	    }
	}
	rpc.ProviderDisconnectedError = ProviderDisconnectedError;
	Object.defineProperty(ProviderDisconnectedError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 4900
	});
	class ChainDisconnectedError extends ProviderRpcError$1 {
	    constructor(cause) {
	        super(cause, {
	            code: ChainDisconnectedError.code,
	            name: 'ChainDisconnectedError',
	            shortMessage: 'The Provider is not connected to the requested chain.',
	        });
	    }
	}
	rpc.ChainDisconnectedError = ChainDisconnectedError;
	Object.defineProperty(ChainDisconnectedError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 4901
	});
	class SwitchChainError extends ProviderRpcError$1 {
	    constructor(cause) {
	        super(cause, {
	            code: SwitchChainError.code,
	            name: 'SwitchChainError',
	            shortMessage: 'An error occurred when attempting to switch chain.',
	        });
	    }
	}
	rpc.SwitchChainError = SwitchChainError;
	Object.defineProperty(SwitchChainError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 4902
	});
	class UnknownRpcError extends RpcError {
	    constructor(cause) {
	        super(cause, {
	            name: 'UnknownRpcError',
	            shortMessage: 'An unknown RPC error occurred.',
	        });
	    }
	}
	rpc.UnknownRpcError = UnknownRpcError;

	Object.defineProperty(getContractError$1, "__esModule", { value: true });
	getContractError$1.getContractError = getContractError;
	const abi_js_1$c = requireAbi();
	const base_js_1$k = base$1;
	const contract_js_1$7 = contract$2;
	const rpc_js_1$d = rpc;
	const EXECUTION_REVERTED_ERROR_CODE = 3;
	function getContractError(err, { abi, address, args, docsPath, functionName, sender, }) {
	    const { code, data, message, shortMessage } = (err instanceof contract_js_1$7.RawContractError
	        ? err
	        : err instanceof base_js_1$k.BaseError
	            ? err.walk((err) => 'data' in err) || err.walk()
	            : {});
	    const cause = (() => {
	        if (err instanceof abi_js_1$c.AbiDecodingZeroDataError)
	            return new contract_js_1$7.ContractFunctionZeroDataError({ functionName });
	        if ([EXECUTION_REVERTED_ERROR_CODE, rpc_js_1$d.InternalRpcError.code].includes(code) &&
	            (data || message || shortMessage)) {
	            return new contract_js_1$7.ContractFunctionRevertedError({
	                abi,
	                data: typeof data === 'object' ? data.data : data,
	                functionName,
	                message: shortMessage ?? message,
	            });
	        }
	        return err;
	    })();
	    return new contract_js_1$7.ContractFunctionExecutionError(cause, {
	        abi,
	        args,
	        contractAddress: address,
	        docsPath,
	        functionName,
	        sender,
	    });
	}

	var estimateGas$3 = {};

	var recoverAuthorizationAddress$1 = {};

	var recoverAddress$1 = {};

	var publicKeyToAddress$1 = {};

	Object.defineProperty(publicKeyToAddress$1, "__esModule", { value: true });
	publicKeyToAddress$1.publicKeyToAddress = publicKeyToAddress;
	const getAddress_js_1$7 = requireGetAddress();
	const keccak256_js_1$a = keccak256$3;
	function publicKeyToAddress(publicKey) {
	    const address = (0, keccak256_js_1$a.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
	    return (0, getAddress_js_1$7.checksumAddress)(`0x${address}`);
	}

	var recoverPublicKey$1 = {};

	var secp256k1 = {};

	var modular = {};

	var utils$4 = {};

	Object.defineProperty(utils$4, "__esModule", { value: true });
	utils$4.validateObject = utils$4.createHmacDrbg = utils$4.bitMask = utils$4.bitSet = utils$4.bitGet = utils$4.bitLen = utils$4.utf8ToBytes = utils$4.equalBytes = utils$4.concatBytes = utils$4.ensureBytes = utils$4.numberToVarBytesBE = utils$4.numberToBytesLE = utils$4.numberToBytesBE = utils$4.bytesToNumberLE = utils$4.bytesToNumberBE = utils$4.hexToBytes = utils$4.hexToNumber = utils$4.numberToHexUnpadded = utils$4.bytesToHex = utils$4.abytes = utils$4.isBytes = void 0;
	/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	// 100 lines of code in the file are duplicated from noble-hashes (utils).
	// This is OK: `abstract` directory does not use noble-hashes.
	// User may opt-in into using different hashing library. This way, noble-hashes
	// won't be included into their bundle.
	const _0n$2 = BigInt(0);
	const _1n$2 = BigInt(1);
	const _2n$1 = BigInt(2);
	function isBytes$2(a) {
	    return (a instanceof Uint8Array ||
	        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
	}
	utils$4.isBytes = isBytes$2;
	function abytes(item) {
	    if (!isBytes$2(item))
	        throw new Error('Uint8Array expected');
	}
	utils$4.abytes = abytes;
	// Array where index 0xf0 (240) is mapped to string 'f0'
	const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
	/**
	 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
	 */
	function bytesToHex(bytes) {
	    abytes(bytes);
	    // pre-caching improves the speed 6x
	    let hex = '';
	    for (let i = 0; i < bytes.length; i++) {
	        hex += hexes[bytes[i]];
	    }
	    return hex;
	}
	utils$4.bytesToHex = bytesToHex;
	function numberToHexUnpadded(num) {
	    const hex = num.toString(16);
	    return hex.length & 1 ? `0${hex}` : hex;
	}
	utils$4.numberToHexUnpadded = numberToHexUnpadded;
	function hexToNumber(hex) {
	    if (typeof hex !== 'string')
	        throw new Error('hex string expected, got ' + typeof hex);
	    // Big Endian
	    return BigInt(hex === '' ? '0' : `0x${hex}`);
	}
	utils$4.hexToNumber = hexToNumber;
	// We use optimized technique to convert hex string to byte array
	const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
	function asciiToBase16(char) {
	    if (char >= asciis._0 && char <= asciis._9)
	        return char - asciis._0;
	    if (char >= asciis._A && char <= asciis._F)
	        return char - (asciis._A - 10);
	    if (char >= asciis._a && char <= asciis._f)
	        return char - (asciis._a - 10);
	    return;
	}
	/**
	 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
	 */
	function hexToBytes(hex) {
	    if (typeof hex !== 'string')
	        throw new Error('hex string expected, got ' + typeof hex);
	    const hl = hex.length;
	    const al = hl / 2;
	    if (hl % 2)
	        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
	    const array = new Uint8Array(al);
	    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
	        const n1 = asciiToBase16(hex.charCodeAt(hi));
	        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
	        if (n1 === undefined || n2 === undefined) {
	            const char = hex[hi] + hex[hi + 1];
	            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
	        }
	        array[ai] = n1 * 16 + n2;
	    }
	    return array;
	}
	utils$4.hexToBytes = hexToBytes;
	// BE: Big Endian, LE: Little Endian
	function bytesToNumberBE(bytes) {
	    return hexToNumber(bytesToHex(bytes));
	}
	utils$4.bytesToNumberBE = bytesToNumberBE;
	function bytesToNumberLE(bytes) {
	    abytes(bytes);
	    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
	}
	utils$4.bytesToNumberLE = bytesToNumberLE;
	function numberToBytesBE(n, len) {
	    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
	}
	utils$4.numberToBytesBE = numberToBytesBE;
	function numberToBytesLE(n, len) {
	    return numberToBytesBE(n, len).reverse();
	}
	utils$4.numberToBytesLE = numberToBytesLE;
	// Unpadded, rarely used
	function numberToVarBytesBE(n) {
	    return hexToBytes(numberToHexUnpadded(n));
	}
	utils$4.numberToVarBytesBE = numberToVarBytesBE;
	/**
	 * Takes hex string or Uint8Array, converts to Uint8Array.
	 * Validates output length.
	 * Will throw error for other types.
	 * @param title descriptive title for an error e.g. 'private key'
	 * @param hex hex string or Uint8Array
	 * @param expectedLength optional, will compare to result array's length
	 * @returns
	 */
	function ensureBytes(title, hex, expectedLength) {
	    let res;
	    if (typeof hex === 'string') {
	        try {
	            res = hexToBytes(hex);
	        }
	        catch (e) {
	            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
	        }
	    }
	    else if (isBytes$2(hex)) {
	        // Uint8Array.from() instead of hash.slice() because node.js Buffer
	        // is instance of Uint8Array, and its slice() creates **mutable** copy
	        res = Uint8Array.from(hex);
	    }
	    else {
	        throw new Error(`${title} must be hex string or Uint8Array`);
	    }
	    const len = res.length;
	    if (typeof expectedLength === 'number' && len !== expectedLength)
	        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
	    return res;
	}
	utils$4.ensureBytes = ensureBytes;
	/**
	 * Copies several Uint8Arrays into one.
	 */
	function concatBytes(...arrays) {
	    let sum = 0;
	    for (let i = 0; i < arrays.length; i++) {
	        const a = arrays[i];
	        abytes(a);
	        sum += a.length;
	    }
	    const res = new Uint8Array(sum);
	    for (let i = 0, pad = 0; i < arrays.length; i++) {
	        const a = arrays[i];
	        res.set(a, pad);
	        pad += a.length;
	    }
	    return res;
	}
	utils$4.concatBytes = concatBytes;
	// Compares 2 u8a-s in kinda constant time
	function equalBytes(a, b) {
	    if (a.length !== b.length)
	        return false;
	    let diff = 0;
	    for (let i = 0; i < a.length; i++)
	        diff |= a[i] ^ b[i];
	    return diff === 0;
	}
	utils$4.equalBytes = equalBytes;
	/**
	 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
	 */
	function utf8ToBytes(str) {
	    if (typeof str !== 'string')
	        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
	    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
	}
	utils$4.utf8ToBytes = utf8ToBytes;
	// Bit operations
	/**
	 * Calculates amount of bits in a bigint.
	 * Same as `n.toString(2).length`
	 */
	function bitLen(n) {
	    let len;
	    for (len = 0; n > _0n$2; n >>= _1n$2, len += 1)
	        ;
	    return len;
	}
	utils$4.bitLen = bitLen;
	/**
	 * Gets single bit at position.
	 * NOTE: first bit position is 0 (same as arrays)
	 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
	 */
	function bitGet(n, pos) {
	    return (n >> BigInt(pos)) & _1n$2;
	}
	utils$4.bitGet = bitGet;
	/**
	 * Sets single bit at position.
	 */
	function bitSet(n, pos, value) {
	    return n | ((value ? _1n$2 : _0n$2) << BigInt(pos));
	}
	utils$4.bitSet = bitSet;
	/**
	 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
	 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
	 */
	const bitMask = (n) => (_2n$1 << BigInt(n - 1)) - _1n$2;
	utils$4.bitMask = bitMask;
	// DRBG
	const u8n = (data) => new Uint8Array(data); // creates Uint8Array
	const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
	/**
	 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
	 * @returns function that will call DRBG until 2nd arg returns something meaningful
	 * @example
	 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
	 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
	 */
	function createHmacDrbg(hashLen, qByteLen, hmacFn) {
	    if (typeof hashLen !== 'number' || hashLen < 2)
	        throw new Error('hashLen must be a number');
	    if (typeof qByteLen !== 'number' || qByteLen < 2)
	        throw new Error('qByteLen must be a number');
	    if (typeof hmacFn !== 'function')
	        throw new Error('hmacFn must be a function');
	    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
	    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
	    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
	    let i = 0; // Iterations counter, will throw when over 1000
	    const reset = () => {
	        v.fill(1);
	        k.fill(0);
	        i = 0;
	    };
	    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
	    const reseed = (seed = u8n()) => {
	        // HMAC-DRBG reseed() function. Steps D-G
	        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
	        v = h(); // v = hmac(k || v)
	        if (seed.length === 0)
	            return;
	        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
	        v = h(); // v = hmac(k || v)
	    };
	    const gen = () => {
	        // HMAC-DRBG generate() function
	        if (i++ >= 1000)
	            throw new Error('drbg: tried 1000 values');
	        let len = 0;
	        const out = [];
	        while (len < qByteLen) {
	            v = h();
	            const sl = v.slice();
	            out.push(sl);
	            len += v.length;
	        }
	        return concatBytes(...out);
	    };
	    const genUntil = (seed, pred) => {
	        reset();
	        reseed(seed); // Steps D-G
	        let res = undefined; // Step H: grind until k is in [1..n-1]
	        while (!(res = pred(gen())))
	            reseed();
	        reset();
	        return res;
	    };
	    return genUntil;
	}
	utils$4.createHmacDrbg = createHmacDrbg;
	// Validating curves and fields
	const validatorFns = {
	    bigint: (val) => typeof val === 'bigint',
	    function: (val) => typeof val === 'function',
	    boolean: (val) => typeof val === 'boolean',
	    string: (val) => typeof val === 'string',
	    stringOrUint8Array: (val) => typeof val === 'string' || isBytes$2(val),
	    isSafeInteger: (val) => Number.isSafeInteger(val),
	    array: (val) => Array.isArray(val),
	    field: (val, object) => object.Fp.isValid(val),
	    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
	};
	// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
	function validateObject(object, validators, optValidators = {}) {
	    const checkField = (fieldName, type, isOptional) => {
	        const checkVal = validatorFns[type];
	        if (typeof checkVal !== 'function')
	            throw new Error(`Invalid validator "${type}", expected function`);
	        const val = object[fieldName];
	        if (isOptional && val === undefined)
	            return;
	        if (!checkVal(val, object)) {
	            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
	        }
	    };
	    for (const [fieldName, type] of Object.entries(validators))
	        checkField(fieldName, type, false);
	    for (const [fieldName, type] of Object.entries(optValidators))
	        checkField(fieldName, type, true);
	    return object;
	}
	utils$4.validateObject = validateObject;

	Object.defineProperty(modular, "__esModule", { value: true });
	modular.mapHashToField = modular.getMinHashLength = modular.getFieldBytesLength = modular.hashToPrivateScalar = modular.FpSqrtEven = modular.FpSqrtOdd = modular.Field = modular.nLength = modular.FpIsSquare = modular.FpDiv = modular.FpInvertBatch = modular.FpPow = modular.validateField = modular.isNegativeLE = modular.FpSqrt = modular.tonelliShanks = modular.invert = modular.pow2 = modular.pow = modular.mod = void 0;
	/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	// Utilities for modular arithmetics and finite fields
	const utils_js_1$h = utils$4;
	// prettier-ignore
	const _0n$1 = BigInt(0), _1n$1 = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
	// prettier-ignore
	const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
	// prettier-ignore
	BigInt(9); BigInt(16);
	// Calculates a modulo b
	function mod(a, b) {
	    const result = a % b;
	    return result >= _0n$1 ? result : b + result;
	}
	modular.mod = mod;
	/**
	 * Efficiently raise num to power and do modular division.
	 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
	 * @example
	 * pow(2n, 6n, 11n) // 64n % 11n == 9n
	 */
	// TODO: use field version && remove
	function pow(num, power, modulo) {
	    if (modulo <= _0n$1 || power < _0n$1)
	        throw new Error('Expected power/modulo > 0');
	    if (modulo === _1n$1)
	        return _0n$1;
	    let res = _1n$1;
	    while (power > _0n$1) {
	        if (power & _1n$1)
	            res = (res * num) % modulo;
	        num = (num * num) % modulo;
	        power >>= _1n$1;
	    }
	    return res;
	}
	modular.pow = pow;
	// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
	function pow2(x, power, modulo) {
	    let res = x;
	    while (power-- > _0n$1) {
	        res *= res;
	        res %= modulo;
	    }
	    return res;
	}
	modular.pow2 = pow2;
	// Inverses number over modulo
	function invert(number, modulo) {
	    if (number === _0n$1 || modulo <= _0n$1) {
	        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
	    }
	    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
	    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
	    let a = mod(number, modulo);
	    let b = modulo;
	    // prettier-ignore
	    let x = _0n$1, u = _1n$1;
	    while (a !== _0n$1) {
	        // JIT applies optimization if those two lines follow each other
	        const q = b / a;
	        const r = b % a;
	        const m = x - u * q;
	        // prettier-ignore
	        b = a, a = r, x = u, u = m;
	    }
	    const gcd = b;
	    if (gcd !== _1n$1)
	        throw new Error('invert: does not exist');
	    return mod(x, modulo);
	}
	modular.invert = invert;
	/**
	 * Tonelli-Shanks square root search algorithm.
	 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
	 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
	 * Will start an infinite loop if field order P is not prime.
	 * @param P field order
	 * @returns function that takes field Fp (created from P) and number n
	 */
	function tonelliShanks(P) {
	    // Legendre constant: used to calculate Legendre symbol (a | p),
	    // which denotes the value of a^((p-1)/2) (mod p).
	    // (a | p) ≡ 1    if a is a square (mod p)
	    // (a | p) ≡ -1   if a is not a square (mod p)
	    // (a | p) ≡ 0    if a ≡ 0 (mod p)
	    const legendreC = (P - _1n$1) / _2n;
	    let Q, S, Z;
	    // Step 1: By factoring out powers of 2 from p - 1,
	    // find q and s such that p - 1 = q*(2^s) with q odd
	    for (Q = P - _1n$1, S = 0; Q % _2n === _0n$1; Q /= _2n, S++)
	        ;
	    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq
	    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n$1; Z++)
	        ;
	    // Fast-path
	    if (S === 1) {
	        const p1div4 = (P + _1n$1) / _4n;
	        return function tonelliFast(Fp, n) {
	            const root = Fp.pow(n, p1div4);
	            if (!Fp.eql(Fp.sqr(root), n))
	                throw new Error('Cannot find square root');
	            return root;
	        };
	    }
	    // Slow-path
	    const Q1div2 = (Q + _1n$1) / _2n;
	    return function tonelliSlow(Fp, n) {
	        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1
	        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
	            throw new Error('Cannot find square root');
	        let r = S;
	        // TODO: will fail at Fp2/etc
	        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
	        let x = Fp.pow(n, Q1div2); // first guess at the square root
	        let b = Fp.pow(n, Q); // first guess at the fudge factor
	        while (!Fp.eql(b, Fp.ONE)) {
	            if (Fp.eql(b, Fp.ZERO))
	                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
	            // Find m such b^(2^m)==1
	            let m = 1;
	            for (let t2 = Fp.sqr(b); m < r; m++) {
	                if (Fp.eql(t2, Fp.ONE))
	                    break;
	                t2 = Fp.sqr(t2); // t2 *= t2
	            }
	            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
	            const ge = Fp.pow(g, _1n$1 << BigInt(r - m - 1)); // ge = 2^(r-m-1)
	            g = Fp.sqr(ge); // g = ge * ge
	            x = Fp.mul(x, ge); // x *= ge
	            b = Fp.mul(b, g); // b *= g
	            r = m;
	        }
	        return x;
	    };
	}
	modular.tonelliShanks = tonelliShanks;
	function FpSqrt(P) {
	    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
	    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
	    // P ≡ 3 (mod 4)
	    // √n = n^((P+1)/4)
	    if (P % _4n === _3n) {
	        // Not all roots possible!
	        // const ORDER =
	        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
	        // const NUM = 72057594037927816n;
	        const p1div4 = (P + _1n$1) / _4n;
	        return function sqrt3mod4(Fp, n) {
	            const root = Fp.pow(n, p1div4);
	            // Throw if root**2 != n
	            if (!Fp.eql(Fp.sqr(root), n))
	                throw new Error('Cannot find square root');
	            return root;
	        };
	    }
	    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
	    if (P % _8n === _5n) {
	        const c1 = (P - _5n) / _8n;
	        return function sqrt5mod8(Fp, n) {
	            const n2 = Fp.mul(n, _2n);
	            const v = Fp.pow(n2, c1);
	            const nv = Fp.mul(n, v);
	            const i = Fp.mul(Fp.mul(nv, _2n), v);
	            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
	            if (!Fp.eql(Fp.sqr(root), n))
	                throw new Error('Cannot find square root');
	            return root;
	        };
	    }
	    // Other cases: Tonelli-Shanks algorithm
	    return tonelliShanks(P);
	}
	modular.FpSqrt = FpSqrt;
	// Little-endian check for first LE bit (last BE bit);
	const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$1) === _1n$1;
	modular.isNegativeLE = isNegativeLE;
	// prettier-ignore
	const FIELD_FIELDS = [
	    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
	    'eql', 'add', 'sub', 'mul', 'pow', 'div',
	    'addN', 'subN', 'mulN', 'sqrN'
	];
	function validateField(field) {
	    const initial = {
	        ORDER: 'bigint',
	        MASK: 'bigint',
	        BYTES: 'isSafeInteger',
	        BITS: 'isSafeInteger',
	    };
	    const opts = FIELD_FIELDS.reduce((map, val) => {
	        map[val] = 'function';
	        return map;
	    }, initial);
	    return (0, utils_js_1$h.validateObject)(field, opts);
	}
	modular.validateField = validateField;
	// Generic field functions
	/**
	 * Same as `pow` but for Fp: non-constant-time.
	 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
	 */
	function FpPow(f, num, power) {
	    // Should have same speed as pow for bigints
	    // TODO: benchmark!
	    if (power < _0n$1)
	        throw new Error('Expected power > 0');
	    if (power === _0n$1)
	        return f.ONE;
	    if (power === _1n$1)
	        return num;
	    let p = f.ONE;
	    let d = num;
	    while (power > _0n$1) {
	        if (power & _1n$1)
	            p = f.mul(p, d);
	        d = f.sqr(d);
	        power >>= _1n$1;
	    }
	    return p;
	}
	modular.FpPow = FpPow;
	/**
	 * Efficiently invert an array of Field elements.
	 * `inv(0)` will return `undefined` here: make sure to throw an error.
	 */
	function FpInvertBatch(f, nums) {
	    const tmp = new Array(nums.length);
	    // Walk from first to last, multiply them by each other MOD p
	    const lastMultiplied = nums.reduce((acc, num, i) => {
	        if (f.is0(num))
	            return acc;
	        tmp[i] = acc;
	        return f.mul(acc, num);
	    }, f.ONE);
	    // Invert last element
	    const inverted = f.inv(lastMultiplied);
	    // Walk from last to first, multiply them by inverted each other MOD p
	    nums.reduceRight((acc, num, i) => {
	        if (f.is0(num))
	            return acc;
	        tmp[i] = f.mul(acc, tmp[i]);
	        return f.mul(acc, num);
	    }, inverted);
	    return tmp;
	}
	modular.FpInvertBatch = FpInvertBatch;
	function FpDiv(f, lhs, rhs) {
	    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
	}
	modular.FpDiv = FpDiv;
	// This function returns True whenever the value x is a square in the field F.
	function FpIsSquare(f) {
	    const legendreConst = (f.ORDER - _1n$1) / _2n; // Integer arithmetic
	    return (x) => {
	        const p = f.pow(x, legendreConst);
	        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
	    };
	}
	modular.FpIsSquare = FpIsSquare;
	// CURVE.n lengths
	function nLength(n, nBitLength) {
	    // Bit size, byte size of CURVE.n
	    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
	    const nByteLength = Math.ceil(_nBitLength / 8);
	    return { nBitLength: _nBitLength, nByteLength };
	}
	modular.nLength = nLength;
	/**
	 * Initializes a finite field over prime. **Non-primes are not supported.**
	 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
	 * Major performance optimizations:
	 * * a) denormalized operations like mulN instead of mul
	 * * b) same object shape: never add or remove keys
	 * * c) Object.freeze
	 * @param ORDER prime positive bigint
	 * @param bitLen how many bits the field consumes
	 * @param isLE (def: false) if encoding / decoding should be in little-endian
	 * @param redef optional faster redefinitions of sqrt and other methods
	 */
	function Field(ORDER, bitLen, isLE = false, redef = {}) {
	    if (ORDER <= _0n$1)
	        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
	    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
	    if (BYTES > 2048)
	        throw new Error('Field lengths over 2048 bytes are not supported');
	    const sqrtP = FpSqrt(ORDER);
	    const f = Object.freeze({
	        ORDER,
	        BITS,
	        BYTES,
	        MASK: (0, utils_js_1$h.bitMask)(BITS),
	        ZERO: _0n$1,
	        ONE: _1n$1,
	        create: (num) => mod(num, ORDER),
	        isValid: (num) => {
	            if (typeof num !== 'bigint')
	                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
	            return _0n$1 <= num && num < ORDER; // 0 is valid element, but it's not invertible
	        },
	        is0: (num) => num === _0n$1,
	        isOdd: (num) => (num & _1n$1) === _1n$1,
	        neg: (num) => mod(-num, ORDER),
	        eql: (lhs, rhs) => lhs === rhs,
	        sqr: (num) => mod(num * num, ORDER),
	        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
	        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
	        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
	        pow: (num, power) => FpPow(f, num, power),
	        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
	        // Same as above, but doesn't normalize
	        sqrN: (num) => num * num,
	        addN: (lhs, rhs) => lhs + rhs,
	        subN: (lhs, rhs) => lhs - rhs,
	        mulN: (lhs, rhs) => lhs * rhs,
	        inv: (num) => invert(num, ORDER),
	        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
	        invertBatch: (lst) => FpInvertBatch(f, lst),
	        // TODO: do we really need constant cmov?
	        // We don't have const-time bigints anyway, so probably will be not very useful
	        cmov: (a, b, c) => (c ? b : a),
	        toBytes: (num) => (isLE ? (0, utils_js_1$h.numberToBytesLE)(num, BYTES) : (0, utils_js_1$h.numberToBytesBE)(num, BYTES)),
	        fromBytes: (bytes) => {
	            if (bytes.length !== BYTES)
	                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
	            return isLE ? (0, utils_js_1$h.bytesToNumberLE)(bytes) : (0, utils_js_1$h.bytesToNumberBE)(bytes);
	        },
	    });
	    return Object.freeze(f);
	}
	modular.Field = Field;
	function FpSqrtOdd(Fp, elm) {
	    if (!Fp.isOdd)
	        throw new Error(`Field doesn't have isOdd`);
	    const root = Fp.sqrt(elm);
	    return Fp.isOdd(root) ? root : Fp.neg(root);
	}
	modular.FpSqrtOdd = FpSqrtOdd;
	function FpSqrtEven(Fp, elm) {
	    if (!Fp.isOdd)
	        throw new Error(`Field doesn't have isOdd`);
	    const root = Fp.sqrt(elm);
	    return Fp.isOdd(root) ? Fp.neg(root) : root;
	}
	modular.FpSqrtEven = FpSqrtEven;
	/**
	 * "Constant-time" private key generation utility.
	 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
	 * Which makes it slightly more biased, less secure.
	 * @deprecated use mapKeyToField instead
	 */
	function hashToPrivateScalar(hash, groupOrder, isLE = false) {
	    hash = (0, utils_js_1$h.ensureBytes)('privateHash', hash);
	    const hashLen = hash.length;
	    const minLen = nLength(groupOrder).nByteLength + 8;
	    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
	        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
	    const num = isLE ? (0, utils_js_1$h.bytesToNumberLE)(hash) : (0, utils_js_1$h.bytesToNumberBE)(hash);
	    return mod(num, groupOrder - _1n$1) + _1n$1;
	}
	modular.hashToPrivateScalar = hashToPrivateScalar;
	/**
	 * Returns total number of bytes consumed by the field element.
	 * For example, 32 bytes for usual 256-bit weierstrass curve.
	 * @param fieldOrder number of field elements, usually CURVE.n
	 * @returns byte length of field
	 */
	function getFieldBytesLength(fieldOrder) {
	    if (typeof fieldOrder !== 'bigint')
	        throw new Error('field order must be bigint');
	    const bitLength = fieldOrder.toString(2).length;
	    return Math.ceil(bitLength / 8);
	}
	modular.getFieldBytesLength = getFieldBytesLength;
	/**
	 * Returns minimal amount of bytes that can be safely reduced
	 * by field order.
	 * Should be 2^-128 for 128-bit curve such as P256.
	 * @param fieldOrder number of field elements, usually CURVE.n
	 * @returns byte length of target hash
	 */
	function getMinHashLength(fieldOrder) {
	    const length = getFieldBytesLength(fieldOrder);
	    return length + Math.ceil(length / 2);
	}
	modular.getMinHashLength = getMinHashLength;
	/**
	 * "Constant-time" private key generation utility.
	 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
	 * and convert them into private scalar, with the modulo bias being negligible.
	 * Needs at least 48 bytes of input for 32-byte private key.
	 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
	 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
	 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
	 * @param hash hash output from SHA3 or a similar function
	 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
	 * @param isLE interpret hash bytes as LE num
	 * @returns valid private scalar
	 */
	function mapHashToField(key, fieldOrder, isLE = false) {
	    const len = key.length;
	    const fieldLen = getFieldBytesLength(fieldOrder);
	    const minLen = getMinHashLength(fieldOrder);
	    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
	    if (len < 16 || len < minLen || len > 1024)
	        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
	    const num = isLE ? (0, utils_js_1$h.bytesToNumberBE)(key) : (0, utils_js_1$h.bytesToNumberLE)(key);
	    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
	    const reduced = mod(num, fieldOrder - _1n$1) + _1n$1;
	    return isLE ? (0, utils_js_1$h.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1$h.numberToBytesBE)(reduced, fieldLen);
	}
	modular.mapHashToField = mapHashToField;

	var weierstrass = {};

	var curve = {};

	Object.defineProperty(curve, "__esModule", { value: true });
	curve.validateBasic = curve.wNAF = void 0;
	/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	// Abelian group utilities
	const modular_js_1$1 = modular;
	const utils_js_1$g = utils$4;
	const _0n = BigInt(0);
	const _1n = BigInt(1);
	// Elliptic curve multiplication of Point by scalar. Fragile.
	// Scalars should always be less than curve order: this should be checked inside of a curve itself.
	// Creates precomputation tables for fast multiplication:
	// - private scalar is split by fixed size windows of W bits
	// - every window point is collected from window's table & added to accumulator
	// - since windows are different, same point inside tables won't be accessed more than once per calc
	// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
	// - +1 window is neccessary for wNAF
	// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
	// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
	// windows to be in different memory locations
	function wNAF(c, bits) {
	    const constTimeNegate = (condition, item) => {
	        const neg = item.negate();
	        return condition ? neg : item;
	    };
	    const opts = (W) => {
	        const windows = Math.ceil(bits / W) + 1; // +1, because
	        const windowSize = 2 ** (W - 1); // -1 because we skip zero
	        return { windows, windowSize };
	    };
	    return {
	        constTimeNegate,
	        // non-const time multiplication ladder
	        unsafeLadder(elm, n) {
	            let p = c.ZERO;
	            let d = elm;
	            while (n > _0n) {
	                if (n & _1n)
	                    p = p.add(d);
	                d = d.double();
	                n >>= _1n;
	            }
	            return p;
	        },
	        /**
	         * Creates a wNAF precomputation window. Used for caching.
	         * Default window size is set by `utils.precompute()` and is equal to 8.
	         * Number of precomputed points depends on the curve size:
	         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
	         * - 𝑊 is the window size
	         * - 𝑛 is the bitlength of the curve order.
	         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
	         * @returns precomputed point tables flattened to a single array
	         */
	        precomputeWindow(elm, W) {
	            const { windows, windowSize } = opts(W);
	            const points = [];
	            let p = elm;
	            let base = p;
	            for (let window = 0; window < windows; window++) {
	                base = p;
	                points.push(base);
	                // =1, because we skip zero
	                for (let i = 1; i < windowSize; i++) {
	                    base = base.add(p);
	                    points.push(base);
	                }
	                p = base.double();
	            }
	            return points;
	        },
	        /**
	         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
	         * @param W window size
	         * @param precomputes precomputed tables
	         * @param n scalar (we don't check here, but should be less than curve order)
	         * @returns real and fake (for const-time) points
	         */
	        wNAF(W, precomputes, n) {
	            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
	            // But need to carefully remove other checks before wNAF. ORDER == bits here
	            const { windows, windowSize } = opts(W);
	            let p = c.ZERO;
	            let f = c.BASE;
	            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
	            const maxNumber = 2 ** W;
	            const shiftBy = BigInt(W);
	            for (let window = 0; window < windows; window++) {
	                const offset = window * windowSize;
	                // Extract W bits.
	                let wbits = Number(n & mask);
	                // Shift number by W bits.
	                n >>= shiftBy;
	                // If the bits are bigger than max size, we'll split those.
	                // +224 => 256 - 32
	                if (wbits > windowSize) {
	                    wbits -= maxNumber;
	                    n += _1n;
	                }
	                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
	                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
	                // there is negate now: it is possible that negated element from low value
	                // would be the same as high element, which will create carry into next window.
	                // It's not obvious how this can fail, but still worth investigating later.
	                // Check if we're onto Zero point.
	                // Add random point inside current window to f.
	                const offset1 = offset;
	                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
	                const cond1 = window % 2 !== 0;
	                const cond2 = wbits < 0;
	                if (wbits === 0) {
	                    // The most important part for const-time getPublicKey
	                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
	                }
	                else {
	                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
	                }
	            }
	            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
	            // Even if the variable is still unused, there are some checks which will
	            // throw an exception, so compiler needs to prove they won't happen, which is hard.
	            // At this point there is a way to F be infinity-point even if p is not,
	            // which makes it less const-time: around 1 bigint multiply.
	            return { p, f };
	        },
	        wNAFCached(P, precomputesMap, n, transform) {
	            // @ts-ignore
	            const W = P._WINDOW_SIZE || 1;
	            // Calculate precomputes on a first run, reuse them after
	            let comp = precomputesMap.get(P);
	            if (!comp) {
	                comp = this.precomputeWindow(P, W);
	                if (W !== 1) {
	                    precomputesMap.set(P, transform(comp));
	                }
	            }
	            return this.wNAF(W, comp, n);
	        },
	    };
	}
	curve.wNAF = wNAF;
	function validateBasic(curve) {
	    (0, modular_js_1$1.validateField)(curve.Fp);
	    (0, utils_js_1$g.validateObject)(curve, {
	        n: 'bigint',
	        h: 'bigint',
	        Gx: 'field',
	        Gy: 'field',
	    }, {
	        nBitLength: 'isSafeInteger',
	        nByteLength: 'isSafeInteger',
	    });
	    // Set defaults
	    return Object.freeze({
	        ...(0, modular_js_1$1.nLength)(curve.n, curve.nBitLength),
	        ...curve,
	        ...{ p: curve.Fp.ORDER },
	    });
	}
	curve.validateBasic = validateBasic;

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
		/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
		// Short Weierstrass curve. The formula is: y² = x³ + ax + b
		const mod = modular;
		const ut = utils$4;
		const utils_js_1 = utils$4;
		const curve_js_1 = curve;
		function validatePointOpts(curve) {
		    const opts = (0, curve_js_1.validateBasic)(curve);
		    ut.validateObject(opts, {
		        a: 'field',
		        b: 'field',
		    }, {
		        allowedPrivateKeyLengths: 'array',
		        wrapPrivateKey: 'boolean',
		        isTorsionFree: 'function',
		        clearCofactor: 'function',
		        allowInfinityPoint: 'boolean',
		        fromBytes: 'function',
		        toBytes: 'function',
		    });
		    const { endo, Fp, a } = opts;
		    if (endo) {
		        if (!Fp.eql(a, Fp.ZERO)) {
		            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
		        }
		        if (typeof endo !== 'object' ||
		            typeof endo.beta !== 'bigint' ||
		            typeof endo.splitScalar !== 'function') {
		            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
		        }
		    }
		    return Object.freeze({ ...opts });
		}
		// ASN.1 DER encoding utilities
		const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
		exports.DER = {
		    // asn.1 DER encoding utils
		    Err: class DERErr extends Error {
		        constructor(m = '') {
		            super(m);
		        }
		    },
		    _parseInt(data) {
		        const { Err: E } = exports.DER;
		        if (data.length < 2 || data[0] !== 0x02)
		            throw new E('Invalid signature integer tag');
		        const len = data[1];
		        const res = data.subarray(2, len + 2);
		        if (!len || res.length !== len)
		            throw new E('Invalid signature integer: wrong length');
		        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
		        // since we always use positive integers here. It must always be empty:
		        // - add zero byte if exists
		        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
		        if (res[0] & 0b10000000)
		            throw new E('Invalid signature integer: negative');
		        if (res[0] === 0x00 && !(res[1] & 0b10000000))
		            throw new E('Invalid signature integer: unnecessary leading zero');
		        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
		    },
		    toSig(hex) {
		        // parse DER signature
		        const { Err: E } = exports.DER;
		        const data = typeof hex === 'string' ? h2b(hex) : hex;
		        ut.abytes(data);
		        let l = data.length;
		        if (l < 2 || data[0] != 0x30)
		            throw new E('Invalid signature tag');
		        if (data[1] !== l - 2)
		            throw new E('Invalid signature: incorrect length');
		        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
		        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
		        if (rBytesLeft.length)
		            throw new E('Invalid signature: left bytes after parsing');
		        return { r, s };
		    },
		    hexFromSig(sig) {
		        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
		        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
		        const h = (num) => {
		            const hex = num.toString(16);
		            return hex.length & 1 ? `0${hex}` : hex;
		        };
		        const s = slice(h(sig.s));
		        const r = slice(h(sig.r));
		        const shl = s.length / 2;
		        const rhl = r.length / 2;
		        const sl = h(shl);
		        const rl = h(rhl);
		        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
		    },
		};
		// Be friendly to bad ECMAScript parsers by not using bigint literals
		// prettier-ignore
		const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
		function weierstrassPoints(opts) {
		    const CURVE = validatePointOpts(opts);
		    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
		    const toBytes = CURVE.toBytes ||
		        ((_c, point, _isCompressed) => {
		            const a = point.toAffine();
		            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
		        });
		    const fromBytes = CURVE.fromBytes ||
		        ((bytes) => {
		            // const head = bytes[0];
		            const tail = bytes.subarray(1);
		            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
		            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
		            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
		            return { x, y };
		        });
		    /**
		     * y² = x³ + ax + b: Short weierstrass curve formula
		     * @returns y²
		     */
		    function weierstrassEquation(x) {
		        const { a, b } = CURVE;
		        const x2 = Fp.sqr(x); // x * x
		        const x3 = Fp.mul(x2, x); // x2 * x
		        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
		    }
		    // Validate whether the passed curve params are valid.
		    // We check if curve equation works for generator point.
		    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
		    // ProjectivePoint class has not been initialized yet.
		    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
		        throw new Error('bad generator point: equation left != right');
		    // Valid group elements reside in range 1..n-1
		    function isWithinCurveOrder(num) {
		        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
		    }
		    function assertGE(num) {
		        if (!isWithinCurveOrder(num))
		            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
		    }
		    // Validates if priv key is valid and converts it to bigint.
		    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
		    function normPrivateKeyToScalar(key) {
		        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
		        if (lengths && typeof key !== 'bigint') {
		            if (ut.isBytes(key))
		                key = ut.bytesToHex(key);
		            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
		            if (typeof key !== 'string' || !lengths.includes(key.length))
		                throw new Error('Invalid key');
		            key = key.padStart(nByteLength * 2, '0');
		        }
		        let num;
		        try {
		            num =
		                typeof key === 'bigint'
		                    ? key
		                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
		        }
		        catch (error) {
		            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
		        }
		        if (wrapPrivateKey)
		            num = mod.mod(num, n); // disabled by default, enabled for BLS
		        assertGE(num); // num in range [1..N-1]
		        return num;
		    }
		    const pointPrecomputes = new Map();
		    function assertPrjPoint(other) {
		        if (!(other instanceof Point))
		            throw new Error('ProjectivePoint expected');
		    }
		    /**
		     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)
		     * Default Point works in 2d / affine coordinates: (x, y)
		     * We're doing calculations in projective, because its operations don't require costly inversion.
		     */
		    class Point {
		        constructor(px, py, pz) {
		            this.px = px;
		            this.py = py;
		            this.pz = pz;
		            if (px == null || !Fp.isValid(px))
		                throw new Error('x required');
		            if (py == null || !Fp.isValid(py))
		                throw new Error('y required');
		            if (pz == null || !Fp.isValid(pz))
		                throw new Error('z required');
		        }
		        // Does not validate if the point is on-curve.
		        // Use fromHex instead, or call assertValidity() later.
		        static fromAffine(p) {
		            const { x, y } = p || {};
		            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
		                throw new Error('invalid affine point');
		            if (p instanceof Point)
		                throw new Error('projective point not allowed');
		            const is0 = (i) => Fp.eql(i, Fp.ZERO);
		            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
		            if (is0(x) && is0(y))
		                return Point.ZERO;
		            return new Point(x, y, Fp.ONE);
		        }
		        get x() {
		            return this.toAffine().x;
		        }
		        get y() {
		            return this.toAffine().y;
		        }
		        /**
		         * Takes a bunch of Projective Points but executes only one
		         * inversion on all of them. Inversion is very slow operation,
		         * so this improves performance massively.
		         * Optimization: converts a list of projective points to a list of identical points with Z=1.
		         */
		        static normalizeZ(points) {
		            const toInv = Fp.invertBatch(points.map((p) => p.pz));
		            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
		        }
		        /**
		         * Converts hash string or Uint8Array to Point.
		         * @param hex short/long ECDSA hex
		         */
		        static fromHex(hex) {
		            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
		            P.assertValidity();
		            return P;
		        }
		        // Multiplies generator point by privateKey.
		        static fromPrivateKey(privateKey) {
		            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
		        }
		        // "Private method", don't use it directly
		        _setWindowSize(windowSize) {
		            this._WINDOW_SIZE = windowSize;
		            pointPrecomputes.delete(this);
		        }
		        // A point on curve is valid if it conforms to equation.
		        assertValidity() {
		            if (this.is0()) {
		                // (0, 1, 0) aka ZERO is invalid in most contexts.
		                // In BLS, ZERO can be serialized, so we allow it.
		                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
		                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
		                    return;
		                throw new Error('bad point: ZERO');
		            }
		            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
		            const { x, y } = this.toAffine();
		            // Check if x, y are valid field elements
		            if (!Fp.isValid(x) || !Fp.isValid(y))
		                throw new Error('bad point: x or y not FE');
		            const left = Fp.sqr(y); // y²
		            const right = weierstrassEquation(x); // x³ + ax + b
		            if (!Fp.eql(left, right))
		                throw new Error('bad point: equation left != right');
		            if (!this.isTorsionFree())
		                throw new Error('bad point: not in prime-order subgroup');
		        }
		        hasEvenY() {
		            const { y } = this.toAffine();
		            if (Fp.isOdd)
		                return !Fp.isOdd(y);
		            throw new Error("Field doesn't support isOdd");
		        }
		        /**
		         * Compare one point to another.
		         */
		        equals(other) {
		            assertPrjPoint(other);
		            const { px: X1, py: Y1, pz: Z1 } = this;
		            const { px: X2, py: Y2, pz: Z2 } = other;
		            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
		            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
		            return U1 && U2;
		        }
		        /**
		         * Flips point to one corresponding to (x, -y) in Affine coordinates.
		         */
		        negate() {
		            return new Point(this.px, Fp.neg(this.py), this.pz);
		        }
		        // Renes-Costello-Batina exception-free doubling formula.
		        // There is 30% faster Jacobian formula, but it is not complete.
		        // https://eprint.iacr.org/2015/1060, algorithm 3
		        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
		        double() {
		            const { a, b } = CURVE;
		            const b3 = Fp.mul(b, _3n);
		            const { px: X1, py: Y1, pz: Z1 } = this;
		            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
		            let t0 = Fp.mul(X1, X1); // step 1
		            let t1 = Fp.mul(Y1, Y1);
		            let t2 = Fp.mul(Z1, Z1);
		            let t3 = Fp.mul(X1, Y1);
		            t3 = Fp.add(t3, t3); // step 5
		            Z3 = Fp.mul(X1, Z1);
		            Z3 = Fp.add(Z3, Z3);
		            X3 = Fp.mul(a, Z3);
		            Y3 = Fp.mul(b3, t2);
		            Y3 = Fp.add(X3, Y3); // step 10
		            X3 = Fp.sub(t1, Y3);
		            Y3 = Fp.add(t1, Y3);
		            Y3 = Fp.mul(X3, Y3);
		            X3 = Fp.mul(t3, X3);
		            Z3 = Fp.mul(b3, Z3); // step 15
		            t2 = Fp.mul(a, t2);
		            t3 = Fp.sub(t0, t2);
		            t3 = Fp.mul(a, t3);
		            t3 = Fp.add(t3, Z3);
		            Z3 = Fp.add(t0, t0); // step 20
		            t0 = Fp.add(Z3, t0);
		            t0 = Fp.add(t0, t2);
		            t0 = Fp.mul(t0, t3);
		            Y3 = Fp.add(Y3, t0);
		            t2 = Fp.mul(Y1, Z1); // step 25
		            t2 = Fp.add(t2, t2);
		            t0 = Fp.mul(t2, t3);
		            X3 = Fp.sub(X3, t0);
		            Z3 = Fp.mul(t2, t1);
		            Z3 = Fp.add(Z3, Z3); // step 30
		            Z3 = Fp.add(Z3, Z3);
		            return new Point(X3, Y3, Z3);
		        }
		        // Renes-Costello-Batina exception-free addition formula.
		        // There is 30% faster Jacobian formula, but it is not complete.
		        // https://eprint.iacr.org/2015/1060, algorithm 1
		        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
		        add(other) {
		            assertPrjPoint(other);
		            const { px: X1, py: Y1, pz: Z1 } = this;
		            const { px: X2, py: Y2, pz: Z2 } = other;
		            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
		            const a = CURVE.a;
		            const b3 = Fp.mul(CURVE.b, _3n);
		            let t0 = Fp.mul(X1, X2); // step 1
		            let t1 = Fp.mul(Y1, Y2);
		            let t2 = Fp.mul(Z1, Z2);
		            let t3 = Fp.add(X1, Y1);
		            let t4 = Fp.add(X2, Y2); // step 5
		            t3 = Fp.mul(t3, t4);
		            t4 = Fp.add(t0, t1);
		            t3 = Fp.sub(t3, t4);
		            t4 = Fp.add(X1, Z1);
		            let t5 = Fp.add(X2, Z2); // step 10
		            t4 = Fp.mul(t4, t5);
		            t5 = Fp.add(t0, t2);
		            t4 = Fp.sub(t4, t5);
		            t5 = Fp.add(Y1, Z1);
		            X3 = Fp.add(Y2, Z2); // step 15
		            t5 = Fp.mul(t5, X3);
		            X3 = Fp.add(t1, t2);
		            t5 = Fp.sub(t5, X3);
		            Z3 = Fp.mul(a, t4);
		            X3 = Fp.mul(b3, t2); // step 20
		            Z3 = Fp.add(X3, Z3);
		            X3 = Fp.sub(t1, Z3);
		            Z3 = Fp.add(t1, Z3);
		            Y3 = Fp.mul(X3, Z3);
		            t1 = Fp.add(t0, t0); // step 25
		            t1 = Fp.add(t1, t0);
		            t2 = Fp.mul(a, t2);
		            t4 = Fp.mul(b3, t4);
		            t1 = Fp.add(t1, t2);
		            t2 = Fp.sub(t0, t2); // step 30
		            t2 = Fp.mul(a, t2);
		            t4 = Fp.add(t4, t2);
		            t0 = Fp.mul(t1, t4);
		            Y3 = Fp.add(Y3, t0);
		            t0 = Fp.mul(t5, t4); // step 35
		            X3 = Fp.mul(t3, X3);
		            X3 = Fp.sub(X3, t0);
		            t0 = Fp.mul(t3, t1);
		            Z3 = Fp.mul(t5, Z3);
		            Z3 = Fp.add(Z3, t0); // step 40
		            return new Point(X3, Y3, Z3);
		        }
		        subtract(other) {
		            return this.add(other.negate());
		        }
		        is0() {
		            return this.equals(Point.ZERO);
		        }
		        wNAF(n) {
		            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
		                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
		                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
		            });
		        }
		        /**
		         * Non-constant-time multiplication. Uses double-and-add algorithm.
		         * It's faster, but should only be used when you don't care about
		         * an exposed private key e.g. sig verification, which works over *public* keys.
		         */
		        multiplyUnsafe(n) {
		            const I = Point.ZERO;
		            if (n === _0n)
		                return I;
		            assertGE(n); // Will throw on 0
		            if (n === _1n)
		                return this;
		            const { endo } = CURVE;
		            if (!endo)
		                return wnaf.unsafeLadder(this, n);
		            // Apply endomorphism
		            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
		            let k1p = I;
		            let k2p = I;
		            let d = this;
		            while (k1 > _0n || k2 > _0n) {
		                if (k1 & _1n)
		                    k1p = k1p.add(d);
		                if (k2 & _1n)
		                    k2p = k2p.add(d);
		                d = d.double();
		                k1 >>= _1n;
		                k2 >>= _1n;
		            }
		            if (k1neg)
		                k1p = k1p.negate();
		            if (k2neg)
		                k2p = k2p.negate();
		            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
		            return k1p.add(k2p);
		        }
		        /**
		         * Constant time multiplication.
		         * Uses wNAF method. Windowed method may be 10% faster,
		         * but takes 2x longer to generate and consumes 2x memory.
		         * Uses precomputes when available.
		         * Uses endomorphism for Koblitz curves.
		         * @param scalar by which the point would be multiplied
		         * @returns New point
		         */
		        multiply(scalar) {
		            assertGE(scalar);
		            let n = scalar;
		            let point, fake; // Fake point is used to const-time mult
		            const { endo } = CURVE;
		            if (endo) {
		                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
		                let { p: k1p, f: f1p } = this.wNAF(k1);
		                let { p: k2p, f: f2p } = this.wNAF(k2);
		                k1p = wnaf.constTimeNegate(k1neg, k1p);
		                k2p = wnaf.constTimeNegate(k2neg, k2p);
		                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
		                point = k1p.add(k2p);
		                fake = f1p.add(f2p);
		            }
		            else {
		                const { p, f } = this.wNAF(n);
		                point = p;
		                fake = f;
		            }
		            // Normalize `z` for both points, but return only real one
		            return Point.normalizeZ([point, fake])[0];
		        }
		        /**
		         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
		         * Not using Strauss-Shamir trick: precomputation tables are faster.
		         * The trick could be useful if both P and Q are not G (not in our case).
		         * @returns non-zero affine point
		         */
		        multiplyAndAddUnsafe(Q, a, b) {
		            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
		            const mul = (P, a // Select faster multiply() method
		            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
		            const sum = mul(this, a).add(mul(Q, b));
		            return sum.is0() ? undefined : sum;
		        }
		        // Converts Projective point to affine (x, y) coordinates.
		        // Can accept precomputed Z^-1 - for example, from invertBatch.
		        // (x, y, z) ∋ (x=x/z, y=y/z)
		        toAffine(iz) {
		            const { px: x, py: y, pz: z } = this;
		            const is0 = this.is0();
		            // If invZ was 0, we return zero point. However we still want to execute
		            // all operations, so we replace invZ with a random number, 1.
		            if (iz == null)
		                iz = is0 ? Fp.ONE : Fp.inv(z);
		            const ax = Fp.mul(x, iz);
		            const ay = Fp.mul(y, iz);
		            const zz = Fp.mul(z, iz);
		            if (is0)
		                return { x: Fp.ZERO, y: Fp.ZERO };
		            if (!Fp.eql(zz, Fp.ONE))
		                throw new Error('invZ was invalid');
		            return { x: ax, y: ay };
		        }
		        isTorsionFree() {
		            const { h: cofactor, isTorsionFree } = CURVE;
		            if (cofactor === _1n)
		                return true; // No subgroups, always torsion-free
		            if (isTorsionFree)
		                return isTorsionFree(Point, this);
		            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
		        }
		        clearCofactor() {
		            const { h: cofactor, clearCofactor } = CURVE;
		            if (cofactor === _1n)
		                return this; // Fast-path
		            if (clearCofactor)
		                return clearCofactor(Point, this);
		            return this.multiplyUnsafe(CURVE.h);
		        }
		        toRawBytes(isCompressed = true) {
		            this.assertValidity();
		            return toBytes(Point, this, isCompressed);
		        }
		        toHex(isCompressed = true) {
		            return ut.bytesToHex(this.toRawBytes(isCompressed));
		        }
		    }
		    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
		    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
		    const _bits = CURVE.nBitLength;
		    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
		    // Validate if generator point is on curve
		    return {
		        CURVE,
		        ProjectivePoint: Point,
		        normPrivateKeyToScalar,
		        weierstrassEquation,
		        isWithinCurveOrder,
		    };
		}
		exports.weierstrassPoints = weierstrassPoints;
		function validateOpts(curve) {
		    const opts = (0, curve_js_1.validateBasic)(curve);
		    ut.validateObject(opts, {
		        hash: 'hash',
		        hmac: 'function',
		        randomBytes: 'function',
		    }, {
		        bits2int: 'function',
		        bits2int_modN: 'function',
		        lowS: 'boolean',
		    });
		    return Object.freeze({ lowS: true, ...opts });
		}
		function weierstrass(curveDef) {
		    const CURVE = validateOpts(curveDef);
		    const { Fp, n: CURVE_ORDER } = CURVE;
		    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
		    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
		    function isValidFieldElement(num) {
		        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
		    }
		    function modN(a) {
		        return mod.mod(a, CURVE_ORDER);
		    }
		    function invN(a) {
		        return mod.invert(a, CURVE_ORDER);
		    }
		    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
		        ...CURVE,
		        toBytes(_c, point, isCompressed) {
		            const a = point.toAffine();
		            const x = Fp.toBytes(a.x);
		            const cat = ut.concatBytes;
		            if (isCompressed) {
		                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
		            }
		            else {
		                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
		            }
		        },
		        fromBytes(bytes) {
		            const len = bytes.length;
		            const head = bytes[0];
		            const tail = bytes.subarray(1);
		            // this.assertValidity() is done inside of fromHex
		            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
		                const x = ut.bytesToNumberBE(tail);
		                if (!isValidFieldElement(x))
		                    throw new Error('Point is not on curve');
		                const y2 = weierstrassEquation(x); // y² = x³ + ax + b
		                let y;
		                try {
		                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
		                }
		                catch (sqrtError) {
		                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
		                    throw new Error('Point is not on curve' + suffix);
		                }
		                const isYOdd = (y & _1n) === _1n;
		                // ECDSA
		                const isHeadOdd = (head & 1) === 1;
		                if (isHeadOdd !== isYOdd)
		                    y = Fp.neg(y);
		                return { x, y };
		            }
		            else if (len === uncompressedLen && head === 0x04) {
		                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
		                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
		                return { x, y };
		            }
		            else {
		                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
		            }
		        },
		    });
		    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
		    function isBiggerThanHalfOrder(number) {
		        const HALF = CURVE_ORDER >> _1n;
		        return number > HALF;
		    }
		    function normalizeS(s) {
		        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
		    }
		    // slice bytes num
		    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
		    /**
		     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
		     */
		    class Signature {
		        constructor(r, s, recovery) {
		            this.r = r;
		            this.s = s;
		            this.recovery = recovery;
		            this.assertValidity();
		        }
		        // pair (bytes of r, bytes of s)
		        static fromCompact(hex) {
		            const l = CURVE.nByteLength;
		            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
		            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
		        }
		        // DER encoded ECDSA signature
		        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
		        static fromDER(hex) {
		            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
		            return new Signature(r, s);
		        }
		        assertValidity() {
		            // can use assertGE here
		            if (!isWithinCurveOrder(this.r))
		                throw new Error('r must be 0 < r < CURVE.n');
		            if (!isWithinCurveOrder(this.s))
		                throw new Error('s must be 0 < s < CURVE.n');
		        }
		        addRecoveryBit(recovery) {
		            return new Signature(this.r, this.s, recovery);
		        }
		        recoverPublicKey(msgHash) {
		            const { r, s, recovery: rec } = this;
		            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
		            if (rec == null || ![0, 1, 2, 3].includes(rec))
		                throw new Error('recovery id invalid');
		            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
		            if (radj >= Fp.ORDER)
		                throw new Error('recovery id 2 or 3 invalid');
		            const prefix = (rec & 1) === 0 ? '02' : '03';
		            const R = Point.fromHex(prefix + numToNByteStr(radj));
		            const ir = invN(radj); // r^-1
		            const u1 = modN(-h * ir); // -hr^-1
		            const u2 = modN(s * ir); // sr^-1
		            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
		            if (!Q)
		                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
		            Q.assertValidity();
		            return Q;
		        }
		        // Signatures should be low-s, to prevent malleability.
		        hasHighS() {
		            return isBiggerThanHalfOrder(this.s);
		        }
		        normalizeS() {
		            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
		        }
		        // DER-encoded
		        toDERRawBytes() {
		            return ut.hexToBytes(this.toDERHex());
		        }
		        toDERHex() {
		            return exports.DER.hexFromSig({ r: this.r, s: this.s });
		        }
		        // padded bytes of r, then padded bytes of s
		        toCompactRawBytes() {
		            return ut.hexToBytes(this.toCompactHex());
		        }
		        toCompactHex() {
		            return numToNByteStr(this.r) + numToNByteStr(this.s);
		        }
		    }
		    const utils = {
		        isValidPrivateKey(privateKey) {
		            try {
		                normPrivateKeyToScalar(privateKey);
		                return true;
		            }
		            catch (error) {
		                return false;
		            }
		        },
		        normPrivateKeyToScalar: normPrivateKeyToScalar,
		        /**
		         * Produces cryptographically secure private key from random of size
		         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
		         */
		        randomPrivateKey: () => {
		            const length = mod.getMinHashLength(CURVE.n);
		            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
		        },
		        /**
		         * Creates precompute table for an arbitrary EC point. Makes point "cached".
		         * Allows to massively speed-up `point.multiply(scalar)`.
		         * @returns cached point
		         * @example
		         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
		         * fast.multiply(privKey); // much faster ECDH now
		         */
		        precompute(windowSize = 8, point = Point.BASE) {
		            point._setWindowSize(windowSize);
		            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
		            return point;
		        },
		    };
		    /**
		     * Computes public key for a private key. Checks for validity of the private key.
		     * @param privateKey private key
		     * @param isCompressed whether to return compact (default), or full key
		     * @returns Public key, full when isCompressed=false; short when isCompressed=true
		     */
		    function getPublicKey(privateKey, isCompressed = true) {
		        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
		    }
		    /**
		     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
		     */
		    function isProbPub(item) {
		        const arr = ut.isBytes(item);
		        const str = typeof item === 'string';
		        const len = (arr || str) && item.length;
		        if (arr)
		            return len === compressedLen || len === uncompressedLen;
		        if (str)
		            return len === 2 * compressedLen || len === 2 * uncompressedLen;
		        if (item instanceof Point)
		            return true;
		        return false;
		    }
		    /**
		     * ECDH (Elliptic Curve Diffie Hellman).
		     * Computes shared public key from private key and public key.
		     * Checks: 1) private key validity 2) shared key is on-curve.
		     * Does NOT hash the result.
		     * @param privateA private key
		     * @param publicB different public key
		     * @param isCompressed whether to return compact (default), or full key
		     * @returns shared public key
		     */
		    function getSharedSecret(privateA, publicB, isCompressed = true) {
		        if (isProbPub(privateA))
		            throw new Error('first arg must be private key');
		        if (!isProbPub(publicB))
		            throw new Error('second arg must be public key');
		        const b = Point.fromHex(publicB); // check for being on-curve
		        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
		    }
		    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
		    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
		    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
		    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
		    const bits2int = CURVE.bits2int ||
		        function (bytes) {
		            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
		            // for some cases, since bytes.length * 8 is not actual bitLength.
		            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
		            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
		            return delta > 0 ? num >> BigInt(delta) : num;
		        };
		    const bits2int_modN = CURVE.bits2int_modN ||
		        function (bytes) {
		            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
		        };
		    // NOTE: pads output with zero as per spec
		    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
		    /**
		     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
		     */
		    function int2octets(num) {
		        if (typeof num !== 'bigint')
		            throw new Error('bigint expected');
		        if (!(_0n <= num && num < ORDER_MASK))
		            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
		        // works with order, can have different size than numToField!
		        return ut.numberToBytesBE(num, CURVE.nByteLength);
		    }
		    // Steps A, D of RFC6979 3.2
		    // Creates RFC6979 seed; converts msg/privKey to numbers.
		    // Used only in sign, not in verify.
		    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
		    // Also it can be bigger for P224 + SHA256
		    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
		        if (['recovered', 'canonical'].some((k) => k in opts))
		            throw new Error('sign() legacy options not supported');
		        const { hash, randomBytes } = CURVE;
		        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
		        if (lowS == null)
		            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
		        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
		        if (prehash)
		            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
		        // We can't later call bits2octets, since nested bits2int is broken for curves
		        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
		        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
		        const h1int = bits2int_modN(msgHash);
		        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
		        const seedArgs = [int2octets(d), int2octets(h1int)];
		        // extraEntropy. RFC6979 3.6: additional k' (optional).
		        if (ent != null && ent !== false) {
		            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
		            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
		            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
		        }
		        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
		        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
		        // Converts signature params into point w r/s, checks result for validity.
		        function k2sig(kBytes) {
		            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
		            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
		            if (!isWithinCurveOrder(k))
		                return; // Important: all mod() calls here must be done over N
		            const ik = invN(k); // k^-1 mod n
		            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
		            const r = modN(q.x); // r = q.x mod n
		            if (r === _0n)
		                return;
		            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
		            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
		            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
		            const s = modN(ik * modN(m + r * d)); // Not using blinding here
		            if (s === _0n)
		                return;
		            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
		            let normS = s;
		            if (lowS && isBiggerThanHalfOrder(s)) {
		                normS = normalizeS(s); // if lowS was passed, ensure s is always
		                recovery ^= 1; // // in the bottom half of N
		            }
		            return new Signature(r, normS, recovery); // use normS, not s
		        }
		        return { seed, k2sig };
		    }
		    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
		    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
		    /**
		     * Signs message hash with a private key.
		     * ```
		     * sign(m, d, k) where
		     *   (x, y) = G × k
		     *   r = x mod n
		     *   s = (m + dr)/k mod n
		     * ```
		     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
		     * @param privKey private key
		     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
		     * @returns signature with recovery param
		     */
		    function sign(msgHash, privKey, opts = defaultSigOpts) {
		        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
		        const C = CURVE;
		        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
		        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
		    }
		    // Enable precomputes. Slows down first publicKey computation by 20ms.
		    Point.BASE._setWindowSize(8);
		    // utils.precompute(8, ProjectivePoint.BASE)
		    /**
		     * Verifies a signature against message hash and public key.
		     * Rejects lowS signatures by default: to override,
		     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
		     *
		     * ```
		     * verify(r, s, h, P) where
		     *   U1 = hs^-1 mod n
		     *   U2 = rs^-1 mod n
		     *   R = U1⋅G - U2⋅P
		     *   mod(R.x, n) == r
		     * ```
		     */
		    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
		        const sg = signature;
		        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
		        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
		        if ('strict' in opts)
		            throw new Error('options.strict was renamed to lowS');
		        const { lowS, prehash } = opts;
		        let _sig = undefined;
		        let P;
		        try {
		            if (typeof sg === 'string' || ut.isBytes(sg)) {
		                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
		                // Since DER can also be 2*nByteLength bytes, we check for it first.
		                try {
		                    _sig = Signature.fromDER(sg);
		                }
		                catch (derError) {
		                    if (!(derError instanceof exports.DER.Err))
		                        throw derError;
		                    _sig = Signature.fromCompact(sg);
		                }
		            }
		            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
		                const { r, s } = sg;
		                _sig = new Signature(r, s);
		            }
		            else {
		                throw new Error('PARSE');
		            }
		            P = Point.fromHex(publicKey);
		        }
		        catch (error) {
		            if (error.message === 'PARSE')
		                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
		            return false;
		        }
		        if (lowS && _sig.hasHighS())
		            return false;
		        if (prehash)
		            msgHash = CURVE.hash(msgHash);
		        const { r, s } = _sig;
		        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
		        const is = invN(s); // s^-1
		        const u1 = modN(h * is); // u1 = hs^-1 mod n
		        const u2 = modN(r * is); // u2 = rs^-1 mod n
		        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P
		        if (!R)
		            return false;
		        const v = modN(R.x);
		        return v === r;
		    }
		    return {
		        CURVE,
		        getPublicKey,
		        getSharedSecret,
		        sign,
		        verify,
		        ProjectivePoint: Point,
		        Signature,
		        utils,
		    };
		}
		exports.weierstrass = weierstrass;
		/**
		 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
		 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
		 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
		 * b = False and y = sqrt(Z * (u / v)) otherwise.
		 * @param Fp
		 * @param Z
		 * @returns
		 */
		function SWUFpSqrtRatio(Fp, Z) {
		    // Generic implementation
		    const q = Fp.ORDER;
		    let l = _0n;
		    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
		        l += _1n;
		    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
		    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
		    // 2n ** c1 == 2n << (c1-1)
		    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
		    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
		    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
		    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
		    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
		    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
		    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
		    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
		    let sqrtRatio = (u, v) => {
		        let tv1 = c6; // 1. tv1 = c6
		        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
		        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
		        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
		        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
		        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
		        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
		        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
		        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
		        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
		        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
		        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
		        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
		        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
		        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
		        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
		        // 17. for i in (c1, c1 - 1, ..., 2):
		        for (let i = c1; i > _1n; i--) {
		            let tv5 = i - _2n; // 18.    tv5 = i - 2
		            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
		            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
		            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
		            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
		            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
		            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
		            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
		            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
		        }
		        return { isValid: isQR, value: tv3 };
		    };
		    if (Fp.ORDER % _4n === _3n) {
		        // sqrt_ratio_3mod4(u, v)
		        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
		        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
		        sqrtRatio = (u, v) => {
		            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
		            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
		            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
		            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
		            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
		            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
		            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
		            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
		            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
		            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
		        };
		    }
		    // No curves uses that
		    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
		    return sqrtRatio;
		}
		exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
		/**
		 * Simplified Shallue-van de Woestijne-Ulas Method
		 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
		 */
		function mapToCurveSimpleSWU(Fp, opts) {
		    mod.validateField(Fp);
		    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
		        throw new Error('mapToCurveSimpleSWU: invalid opts');
		    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
		    if (!Fp.isOdd)
		        throw new Error('Fp.isOdd is not implemented!');
		    // Input: u, an element of F.
		    // Output: (x, y), a point on E.
		    return (u) => {
		        // prettier-ignore
		        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
		        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
		        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
		        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
		        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
		        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
		        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
		        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
		        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
		        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
		        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
		        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
		        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
		        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
		        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
		        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
		        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
		        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
		        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
		        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
		        y = Fp.mul(y, value); // 20.   y = y * y1
		        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
		        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
		        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
		        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
		        x = Fp.div(x, tv4); // 25.   x = x / tv4
		        return { x, y };
		    };
		}
		exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
		
	} (weierstrass));

	var hashToCurve = {};

	Object.defineProperty(hashToCurve, "__esModule", { value: true });
	hashToCurve.createHasher = hashToCurve.isogenyMap = hashToCurve.hash_to_field = hashToCurve.expand_message_xof = hashToCurve.expand_message_xmd = void 0;
	const modular_js_1 = modular;
	const utils_js_1$f = utils$4;
	// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
	const os2ip = utils_js_1$f.bytesToNumberBE;
	// Integer to Octet Stream (numberToBytesBE)
	function i2osp(value, length) {
	    if (value < 0 || value >= 1 << (8 * length)) {
	        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
	    }
	    const res = Array.from({ length }).fill(0);
	    for (let i = length - 1; i >= 0; i--) {
	        res[i] = value & 0xff;
	        value >>>= 8;
	    }
	    return new Uint8Array(res);
	}
	function strxor(a, b) {
	    const arr = new Uint8Array(a.length);
	    for (let i = 0; i < a.length; i++) {
	        arr[i] = a[i] ^ b[i];
	    }
	    return arr;
	}
	function anum(item) {
	    if (!Number.isSafeInteger(item))
	        throw new Error('number expected');
	}
	// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
	// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
	function expand_message_xmd(msg, DST, lenInBytes, H) {
	    (0, utils_js_1$f.abytes)(msg);
	    (0, utils_js_1$f.abytes)(DST);
	    anum(lenInBytes);
	    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
	    if (DST.length > 255)
	        DST = H((0, utils_js_1$f.concatBytes)((0, utils_js_1$f.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
	    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
	    const ell = Math.ceil(lenInBytes / b_in_bytes);
	    if (ell > 255)
	        throw new Error('Invalid xmd length');
	    const DST_prime = (0, utils_js_1$f.concatBytes)(DST, i2osp(DST.length, 1));
	    const Z_pad = i2osp(0, r_in_bytes);
	    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
	    const b = new Array(ell);
	    const b_0 = H((0, utils_js_1$f.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
	    b[0] = H((0, utils_js_1$f.concatBytes)(b_0, i2osp(1, 1), DST_prime));
	    for (let i = 1; i <= ell; i++) {
	        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
	        b[i] = H((0, utils_js_1$f.concatBytes)(...args));
	    }
	    const pseudo_random_bytes = (0, utils_js_1$f.concatBytes)(...b);
	    return pseudo_random_bytes.slice(0, lenInBytes);
	}
	hashToCurve.expand_message_xmd = expand_message_xmd;
	// Produces a uniformly random byte string using an extendable-output function (XOF) H.
	// 1. The collision resistance of H MUST be at least k bits.
	// 2. H MUST be an XOF that has been proved indifferentiable from
	//    a random oracle under a reasonable cryptographic assumption.
	// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
	function expand_message_xof(msg, DST, lenInBytes, k, H) {
	    (0, utils_js_1$f.abytes)(msg);
	    (0, utils_js_1$f.abytes)(DST);
	    anum(lenInBytes);
	    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
	    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
	    if (DST.length > 255) {
	        const dkLen = Math.ceil((2 * k) / 8);
	        DST = H.create({ dkLen }).update((0, utils_js_1$f.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
	    }
	    if (lenInBytes > 65535 || DST.length > 255)
	        throw new Error('expand_message_xof: invalid lenInBytes');
	    return (H.create({ dkLen: lenInBytes })
	        .update(msg)
	        .update(i2osp(lenInBytes, 2))
	        // 2. DST_prime = DST || I2OSP(len(DST), 1)
	        .update(DST)
	        .update(i2osp(DST.length, 1))
	        .digest());
	}
	hashToCurve.expand_message_xof = expand_message_xof;
	/**
	 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
	 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
	 * @param msg a byte string containing the message to hash
	 * @param count the number of elements of F to output
	 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
	 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
	 */
	function hash_to_field(msg, count, options) {
	    (0, utils_js_1$f.validateObject)(options, {
	        DST: 'stringOrUint8Array',
	        p: 'bigint',
	        m: 'isSafeInteger',
	        k: 'isSafeInteger',
	        hash: 'hash',
	    });
	    const { p, k, m, hash, expand, DST: _DST } = options;
	    (0, utils_js_1$f.abytes)(msg);
	    anum(count);
	    const DST = typeof _DST === 'string' ? (0, utils_js_1$f.utf8ToBytes)(_DST) : _DST;
	    const log2p = p.toString(2).length;
	    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
	    const len_in_bytes = count * m * L;
	    let prb; // pseudo_random_bytes
	    if (expand === 'xmd') {
	        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
	    }
	    else if (expand === 'xof') {
	        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
	    }
	    else if (expand === '_internal_pass') {
	        // for internal tests only
	        prb = msg;
	    }
	    else {
	        throw new Error('expand must be "xmd" or "xof"');
	    }
	    const u = new Array(count);
	    for (let i = 0; i < count; i++) {
	        const e = new Array(m);
	        for (let j = 0; j < m; j++) {
	            const elm_offset = L * (j + i * m);
	            const tv = prb.subarray(elm_offset, elm_offset + L);
	            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
	        }
	        u[i] = e;
	    }
	    return u;
	}
	hashToCurve.hash_to_field = hash_to_field;
	function isogenyMap(field, map) {
	    // Make same order as in spec
	    const COEFF = map.map((i) => Array.from(i).reverse());
	    return (x, y) => {
	        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
	        x = field.div(xNum, xDen); // xNum / xDen
	        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
	        return { x, y };
	    };
	}
	hashToCurve.isogenyMap = isogenyMap;
	function createHasher(Point, mapToCurve, def) {
	    if (typeof mapToCurve !== 'function')
	        throw new Error('mapToCurve() must be defined');
	    return {
	        // Encodes byte string to elliptic curve.
	        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
	        hashToCurve(msg, options) {
	            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
	            const u0 = Point.fromAffine(mapToCurve(u[0]));
	            const u1 = Point.fromAffine(mapToCurve(u[1]));
	            const P = u0.add(u1).clearCofactor();
	            P.assertValidity();
	            return P;
	        },
	        // Encodes byte string to elliptic curve.
	        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
	        encodeToCurve(msg, options) {
	            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
	            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
	            P.assertValidity();
	            return P;
	        },
	    };
	}
	hashToCurve.createHasher = createHasher;

	var _shortw_utils = {};

	var hmac = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.hmac = exports.HMAC = void 0;
		const _assert_js_1 = _assert;
		const utils_js_1 = utils$8;
		// HMAC (RFC 2104)
		class HMAC extends utils_js_1.Hash {
		    constructor(hash, _key) {
		        super();
		        this.finished = false;
		        this.destroyed = false;
		        (0, _assert_js_1.hash)(hash);
		        const key = (0, utils_js_1.toBytes)(_key);
		        this.iHash = hash.create();
		        if (typeof this.iHash.update !== 'function')
		            throw new Error('Expected instance of class which extends utils.Hash');
		        this.blockLen = this.iHash.blockLen;
		        this.outputLen = this.iHash.outputLen;
		        const blockLen = this.blockLen;
		        const pad = new Uint8Array(blockLen);
		        // blockLen can be bigger than outputLen
		        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
		        for (let i = 0; i < pad.length; i++)
		            pad[i] ^= 0x36;
		        this.iHash.update(pad);
		        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
		        this.oHash = hash.create();
		        // Undo internal XOR && apply outer XOR
		        for (let i = 0; i < pad.length; i++)
		            pad[i] ^= 0x36 ^ 0x5c;
		        this.oHash.update(pad);
		        pad.fill(0);
		    }
		    update(buf) {
		        (0, _assert_js_1.exists)(this);
		        this.iHash.update(buf);
		        return this;
		    }
		    digestInto(out) {
		        (0, _assert_js_1.exists)(this);
		        (0, _assert_js_1.bytes)(out, this.outputLen);
		        this.finished = true;
		        this.iHash.digestInto(out);
		        this.oHash.update(out);
		        this.oHash.digestInto(out);
		        this.destroy();
		    }
		    digest() {
		        const out = new Uint8Array(this.oHash.outputLen);
		        this.digestInto(out);
		        return out;
		    }
		    _cloneInto(to) {
		        // Create new instance without calling constructor since key already in state and we don't know it.
		        to || (to = Object.create(Object.getPrototypeOf(this), {}));
		        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
		        to = to;
		        to.finished = finished;
		        to.destroyed = destroyed;
		        to.blockLen = blockLen;
		        to.outputLen = outputLen;
		        to.oHash = oHash._cloneInto(to.oHash);
		        to.iHash = iHash._cloneInto(to.iHash);
		        return to;
		    }
		    destroy() {
		        this.destroyed = true;
		        this.oHash.destroy();
		        this.iHash.destroy();
		    }
		}
		exports.HMAC = HMAC;
		/**
		 * HMAC: RFC2104 message authentication code.
		 * @param hash - function that would be used e.g. sha256
		 * @param key - message key
		 * @param message - message data
		 */
		const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
		exports.hmac = hmac;
		exports.hmac.create = (hash, key) => new HMAC(hash, key);
		
	} (hmac));

	Object.defineProperty(_shortw_utils, "__esModule", { value: true });
	_shortw_utils.createCurve = _shortw_utils.getHash = void 0;
	/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	const hmac_1 = hmac;
	const utils_1$3 = utils$8;
	const weierstrass_js_1 = weierstrass;
	// connects noble-curves to noble-hashes
	function getHash(hash) {
	    return {
	        hash,
	        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1$3.concatBytes)(...msgs)),
	        randomBytes: utils_1$3.randomBytes,
	    };
	}
	_shortw_utils.getHash = getHash;
	function createCurve(curveDef, defHash) {
	    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
	    return Object.freeze({ ...create(defHash), create });
	}
	_shortw_utils.createCurve = createCurve;

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
		/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
		const sha256_1 = sha256$3;
		const utils_1 = utils$8;
		const modular_js_1 = modular;
		const weierstrass_js_1 = weierstrass;
		const utils_js_1 = utils$4;
		const hash_to_curve_js_1 = hashToCurve;
		const _shortw_utils_js_1 = _shortw_utils;
		const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
		const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
		const _1n = BigInt(1);
		const _2n = BigInt(2);
		const divNearest = (a, b) => (a + b / _2n) / b;
		/**
		 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
		 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
		 */
		function sqrtMod(y) {
		    const P = secp256k1P;
		    // prettier-ignore
		    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
		    // prettier-ignore
		    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
		    const b2 = (y * y * y) % P; // x^3, 11
		    const b3 = (b2 * b2 * y) % P; // x^7
		    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;
		    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;
		    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;
		    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;
		    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;
		    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;
		    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;
		    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;
		    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;
		    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;
		    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;
		    const root = (0, modular_js_1.pow2)(t2, _2n, P);
		    if (!Fp.eql(Fp.sqr(root), y))
		        throw new Error('Cannot find square root');
		    return root;
		}
		const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
		exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
		    a: BigInt(0), // equation params: a, b
		    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
		    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
		    n: secp256k1N, // Curve order, total count of valid points in the field
		    // Base point (x, y) aka generator point
		    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
		    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
		    h: BigInt(1), // Cofactor
		    lowS: true, // Allow only low-S signatures by default in sign() and verify()
		    /**
		     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
		     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
		     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
		     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
		     */
		    endo: {
		        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
		        splitScalar: (k) => {
		            const n = secp256k1N;
		            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
		            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
		            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
		            const b2 = a1;
		            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
		            const c1 = divNearest(b2 * k, n);
		            const c2 = divNearest(-b1 * k, n);
		            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
		            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
		            const k1neg = k1 > POW_2_128;
		            const k2neg = k2 > POW_2_128;
		            if (k1neg)
		                k1 = n - k1;
		            if (k2neg)
		                k2 = n - k2;
		            if (k1 > POW_2_128 || k2 > POW_2_128) {
		                throw new Error('splitScalar: Endomorphism failed, k=' + k);
		            }
		            return { k1neg, k1, k2neg, k2 };
		        },
		    },
		}, sha256_1.sha256);
		// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
		// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
		const _0n = BigInt(0);
		const fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;
		const ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;
		/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
		const TAGGED_HASH_PREFIXES = {};
		function taggedHash(tag, ...messages) {
		    let tagP = TAGGED_HASH_PREFIXES[tag];
		    if (tagP === undefined) {
		        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
		        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
		        TAGGED_HASH_PREFIXES[tag] = tagP;
		    }
		    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
		}
		// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
		const pointToBytes = (point) => point.toRawBytes(true).slice(1);
		const numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
		const modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
		const modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
		const Point = exports.secp256k1.ProjectivePoint;
		const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
		// Calculate point, scalar and bytes
		function schnorrGetExtPubKey(priv) {
		    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
		    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside
		    const scalar = p.hasEvenY() ? d_ : modN(-d_);
		    return { scalar: scalar, bytes: pointToBytes(p) };
		}
		/**
		 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
		 * @returns valid point checked for being on-curve
		 */
		function lift_x(x) {
		    if (!fe(x))
		        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.
		    const xx = modP(x * x);
		    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
		    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
		    if (y % _2n !== _0n)
		        y = modP(-y); // Return the unique point P such that x(P) = x and
		    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
		    p.assertValidity();
		    return p;
		}
		/**
		 * Create tagged hash, convert it to bigint, reduce modulo-n.
		 */
		function challenge(...args) {
		    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));
		}
		/**
		 * Schnorr public key is just `x` coordinate of Point as per BIP340.
		 */
		function schnorrGetPublicKey(privateKey) {
		    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
		}
		/**
		 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
		 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
		 */
		function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
		    const m = (0, utils_js_1.ensureBytes)('message', message);
		    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
		    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
		    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
		    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
		    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
		    if (k_ === _0n)
		        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
		    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.
		    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
		    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
		    sig.set(rx, 0);
		    sig.set(numTo32b(modN(k + e * d)), 32);
		    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
		    if (!schnorrVerify(sig, m, px))
		        throw new Error('sign: Invalid signature produced');
		    return sig;
		}
		/**
		 * Verifies Schnorr signature.
		 * Will swallow errors & return false except for initial type validation of arguments.
		 */
		function schnorrVerify(signature, message, publicKey) {
		    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
		    const m = (0, utils_js_1.ensureBytes)('message', message);
		    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
		    try {
		        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
		        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
		        if (!fe(r))
		            return false;
		        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
		        if (!ge(s))
		            return false;
		        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
		        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P
		        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
		            return false; // -eP == (n-e)P
		        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
		    }
		    catch (error) {
		        return false;
		    }
		}
		exports.schnorr = (() => ({
		    getPublicKey: schnorrGetPublicKey,
		    sign: schnorrSign,
		    verify: schnorrVerify,
		    utils: {
		        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
		        lift_x,
		        pointToBytes,
		        numberToBytesBE: utils_js_1.numberToBytesBE,
		        bytesToNumberBE: utils_js_1.bytesToNumberBE,
		        taggedHash,
		        mod: modular_js_1.mod,
		    },
		}))();
		const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
		    // xNum
		    [
		        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
		        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
		        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
		        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
		    ],
		    // xDen
		    [
		        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
		        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
		        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
		    ],
		    // yNum
		    [
		        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
		        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
		        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
		        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
		    ],
		    // yDen
		    [
		        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
		        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
		        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
		        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
		    ],
		].map((i) => i.map((j) => BigInt(j)))))();
		const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
		    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
		    B: BigInt('1771'),
		    Z: Fp.create(BigInt('-11')),
		}))();
		const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
		    const { x, y } = mapSWU(Fp.create(scalars[0]));
		    return isoMap(x, y);
		}, {
		    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
		    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
		    p: Fp.ORDER,
		    m: 1,
		    k: 128,
		    expand: 'xmd',
		    hash: sha256_1.sha256,
		}))();
		exports.hashToCurve = (() => htf.hashToCurve)();
		exports.encodeToCurve = (() => htf.encodeToCurve)();
		
	} (secp256k1));

	Object.defineProperty(recoverPublicKey$1, "__esModule", { value: true });
	recoverPublicKey$1.recoverPublicKey = recoverPublicKey;
	const isHex_js_1$7 = isHex$1;
	const fromHex_js_1$b = requireFromHex();
	const toHex_js_1$N = requireToHex();
	async function recoverPublicKey({ hash, signature, }) {
	    const hashHex = (0, isHex_js_1$7.isHex)(hash) ? hash : (0, toHex_js_1$N.toHex)(hash);
	    const { secp256k1: secp256k1$1 } = await Promise.resolve().then(() => secp256k1);
	    const signature_ = (() => {
	        if (typeof signature === 'object' && 'r' in signature && 's' in signature) {
	            const { r, s, v, yParity } = signature;
	            const yParityOrV = Number(yParity ?? v);
	            const recoveryBit = toRecoveryBit(yParityOrV);
	            return new secp256k1$1.Signature((0, fromHex_js_1$b.hexToBigInt)(r), (0, fromHex_js_1$b.hexToBigInt)(s)).addRecoveryBit(recoveryBit);
	        }
	        const signatureHex = (0, isHex_js_1$7.isHex)(signature) ? signature : (0, toHex_js_1$N.toHex)(signature);
	        const yParityOrV = (0, fromHex_js_1$b.hexToNumber)(`0x${signatureHex.slice(130)}`);
	        const recoveryBit = toRecoveryBit(yParityOrV);
	        return secp256k1$1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
	    })();
	    const publicKey = signature_
	        .recoverPublicKey(hashHex.substring(2))
	        .toHex(false);
	    return `0x${publicKey}`;
	}
	function toRecoveryBit(yParityOrV) {
	    if (yParityOrV === 0 || yParityOrV === 1)
	        return yParityOrV;
	    if (yParityOrV === 27)
	        return 0;
	    if (yParityOrV === 28)
	        return 1;
	    throw new Error('Invalid yParityOrV value');
	}

	Object.defineProperty(recoverAddress$1, "__esModule", { value: true });
	recoverAddress$1.recoverAddress = recoverAddress;
	const publicKeyToAddress_js_1 = publicKeyToAddress$1;
	const recoverPublicKey_js_1 = recoverPublicKey$1;
	async function recoverAddress({ hash, signature, }) {
	    return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash: hash, signature }));
	}

	var hashAuthorization$1 = {};

	var toRlp$1 = {};

	Object.defineProperty(toRlp$1, "__esModule", { value: true });
	toRlp$1.toRlp = toRlp;
	toRlp$1.bytesToRlp = bytesToRlp;
	toRlp$1.hexToRlp = hexToRlp;
	const base_js_1$j = base$1;
	const cursor_js_1$4 = cursor$1;
	const toBytes_js_1$i = requireToBytes();
	const toHex_js_1$M = requireToHex();
	function toRlp(bytes, to = 'hex') {
	    const encodable = getEncodable(bytes);
	    const cursor = (0, cursor_js_1$4.createCursor)(new Uint8Array(encodable.length));
	    encodable.encode(cursor);
	    if (to === 'hex')
	        return (0, toHex_js_1$M.bytesToHex)(cursor.bytes);
	    return cursor.bytes;
	}
	function bytesToRlp(bytes, to = 'bytes') {
	    return toRlp(bytes, to);
	}
	function hexToRlp(hex, to = 'hex') {
	    return toRlp(hex, to);
	}
	function getEncodable(bytes) {
	    if (Array.isArray(bytes))
	        return getEncodableList(bytes.map((x) => getEncodable(x)));
	    return getEncodableBytes(bytes);
	}
	function getEncodableList(list) {
	    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
	    const sizeOfBodyLength = getSizeOfLength(bodyLength);
	    const length = (() => {
	        if (bodyLength <= 55)
	            return 1 + bodyLength;
	        return 1 + sizeOfBodyLength + bodyLength;
	    })();
	    return {
	        length,
	        encode(cursor) {
	            if (bodyLength <= 55) {
	                cursor.pushByte(0xc0 + bodyLength);
	            }
	            else {
	                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);
	                if (sizeOfBodyLength === 1)
	                    cursor.pushUint8(bodyLength);
	                else if (sizeOfBodyLength === 2)
	                    cursor.pushUint16(bodyLength);
	                else if (sizeOfBodyLength === 3)
	                    cursor.pushUint24(bodyLength);
	                else
	                    cursor.pushUint32(bodyLength);
	            }
	            for (const { encode } of list) {
	                encode(cursor);
	            }
	        },
	    };
	}
	function getEncodableBytes(bytesOrHex) {
	    const bytes = typeof bytesOrHex === 'string' ? (0, toBytes_js_1$i.hexToBytes)(bytesOrHex) : bytesOrHex;
	    const sizeOfBytesLength = getSizeOfLength(bytes.length);
	    const length = (() => {
	        if (bytes.length === 1 && bytes[0] < 0x80)
	            return 1;
	        if (bytes.length <= 55)
	            return 1 + bytes.length;
	        return 1 + sizeOfBytesLength + bytes.length;
	    })();
	    return {
	        length,
	        encode(cursor) {
	            if (bytes.length === 1 && bytes[0] < 0x80) {
	                cursor.pushBytes(bytes);
	            }
	            else if (bytes.length <= 55) {
	                cursor.pushByte(0x80 + bytes.length);
	                cursor.pushBytes(bytes);
	            }
	            else {
	                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);
	                if (sizeOfBytesLength === 1)
	                    cursor.pushUint8(bytes.length);
	                else if (sizeOfBytesLength === 2)
	                    cursor.pushUint16(bytes.length);
	                else if (sizeOfBytesLength === 3)
	                    cursor.pushUint24(bytes.length);
	                else
	                    cursor.pushUint32(bytes.length);
	                cursor.pushBytes(bytes);
	            }
	        },
	    };
	}
	function getSizeOfLength(length) {
	    if (length < 2 ** 8)
	        return 1;
	    if (length < 2 ** 16)
	        return 2;
	    if (length < 2 ** 24)
	        return 3;
	    if (length < 2 ** 32)
	        return 4;
	    throw new base_js_1$j.BaseError('Length is too large.');
	}

	Object.defineProperty(hashAuthorization$1, "__esModule", { value: true });
	hashAuthorization$1.hashAuthorization = hashAuthorization;
	const concat_js_1$7 = concat$1;
	const toBytes_js_1$h = requireToBytes();
	const toHex_js_1$L = requireToHex();
	const toRlp_js_1$1 = toRlp$1;
	const keccak256_js_1$9 = keccak256$3;
	function hashAuthorization(parameters) {
	    const { chainId, contractAddress, nonce, to } = parameters;
	    const hash = (0, keccak256_js_1$9.keccak256)((0, concat_js_1$7.concatHex)([
	        '0x05',
	        (0, toRlp_js_1$1.toRlp)([(0, toHex_js_1$L.numberToHex)(chainId), contractAddress, (0, toHex_js_1$L.numberToHex)(nonce)]),
	    ]));
	    if (to === 'bytes')
	        return (0, toBytes_js_1$h.hexToBytes)(hash);
	    return hash;
	}

	Object.defineProperty(recoverAuthorizationAddress$1, "__esModule", { value: true });
	recoverAuthorizationAddress$1.recoverAuthorizationAddress = recoverAuthorizationAddress;
	const recoverAddress_js_1$5 = recoverAddress$1;
	const hashAuthorization_js_1 = hashAuthorization$1;
	async function recoverAuthorizationAddress(parameters) {
	    const { authorization, signature } = parameters;
	    return (0, recoverAddress_js_1$5.recoverAddress)({
	        hash: (0, hashAuthorization_js_1.hashAuthorization)(authorization),
	        signature: (signature ?? authorization),
	    });
	}

	var getEstimateGasError$1 = {};

	var estimateGas$2 = {};

	Object.defineProperty(estimateGas$2, "__esModule", { value: true });
	estimateGas$2.EstimateGasExecutionError = void 0;
	const formatEther_js_1 = formatEther$1;
	const formatGwei_js_1$2 = formatGwei$1;
	const base_js_1$i = base$1;
	const transaction_js_1$a = transaction$1;
	class EstimateGasExecutionError extends base_js_1$i.BaseError {
	    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
	        const prettyArgs = (0, transaction_js_1$a.prettyPrint)({
	            from: account?.address,
	            to,
	            value: typeof value !== 'undefined' &&
	                `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
	            data,
	            gas,
	            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1$2.formatGwei)(gasPrice)} gwei`,
	            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
	                `${(0, formatGwei_js_1$2.formatGwei)(maxFeePerGas)} gwei`,
	            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
	                `${(0, formatGwei_js_1$2.formatGwei)(maxPriorityFeePerGas)} gwei`,
	            nonce,
	        });
	        super(cause.shortMessage, {
	            cause,
	            docsPath,
	            metaMessages: [
	                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
	                'Estimate Gas Arguments:',
	                prettyArgs,
	            ].filter(Boolean),
	            name: 'EstimateGasExecutionError',
	        });
	        Object.defineProperty(this, "cause", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.cause = cause;
	    }
	}
	estimateGas$2.EstimateGasExecutionError = EstimateGasExecutionError;

	var node = {};

	Object.defineProperty(node, "__esModule", { value: true });
	node.UnknownNodeError = node.TipAboveFeeCapError = node.TransactionTypeNotSupportedError = node.IntrinsicGasTooLowError = node.IntrinsicGasTooHighError = node.InsufficientFundsError = node.NonceMaxValueError = node.NonceTooLowError = node.NonceTooHighError = node.FeeCapTooLowError = node.FeeCapTooHighError = node.ExecutionRevertedError = void 0;
	const formatGwei_js_1$1 = formatGwei$1;
	const base_js_1$h = base$1;
	class ExecutionRevertedError extends base_js_1$h.BaseError {
	    constructor({ cause, message, } = {}) {
	        const reason = message
	            ?.replace('execution reverted: ', '')
	            ?.replace('execution reverted', '');
	        super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
	            cause,
	            name: 'ExecutionRevertedError',
	        });
	    }
	}
	node.ExecutionRevertedError = ExecutionRevertedError;
	Object.defineProperty(ExecutionRevertedError, "code", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 3
	});
	Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /execution reverted/
	});
	class FeeCapTooHighError extends base_js_1$h.BaseError {
	    constructor({ cause, maxFeePerGas, } = {}) {
	        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
	            cause,
	            name: 'FeeCapTooHighError',
	        });
	    }
	}
	node.FeeCapTooHighError = FeeCapTooHighError;
	Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
	});
	class FeeCapTooLowError extends base_js_1$h.BaseError {
	    constructor({ cause, maxFeePerGas, } = {}) {
	        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
	            cause,
	            name: 'FeeCapTooLowError',
	        });
	    }
	}
	node.FeeCapTooLowError = FeeCapTooLowError;
	Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
	});
	class NonceTooHighError extends base_js_1$h.BaseError {
	    constructor({ cause, nonce, } = {}) {
	        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, { cause, name: 'NonceTooHighError' });
	    }
	}
	node.NonceTooHighError = NonceTooHighError;
	Object.defineProperty(NonceTooHighError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /nonce too high/
	});
	class NonceTooLowError extends base_js_1$h.BaseError {
	    constructor({ cause, nonce, } = {}) {
	        super([
	            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`,
	            'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',
	        ].join('\n'), { cause, name: 'NonceTooLowError' });
	    }
	}
	node.NonceTooLowError = NonceTooLowError;
	Object.defineProperty(NonceTooLowError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /nonce too low|transaction already imported|already known/
	});
	class NonceMaxValueError extends base_js_1$h.BaseError {
	    constructor({ cause, nonce, } = {}) {
	        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, { cause, name: 'NonceMaxValueError' });
	    }
	}
	node.NonceMaxValueError = NonceMaxValueError;
	Object.defineProperty(NonceMaxValueError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /nonce has max value/
	});
	class InsufficientFundsError extends base_js_1$h.BaseError {
	    constructor({ cause } = {}) {
	        super([
	            'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',
	        ].join('\n'), {
	            cause,
	            metaMessages: [
	                'This error could arise when the account does not have enough funds to:',
	                ' - pay for the total gas fee,',
	                ' - pay for the value to send.',
	                ' ',
	                'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
	                ' - `gas` is the amount of gas needed for transaction to execute,',
	                ' - `gas fee` is the gas fee,',
	                ' - `value` is the amount of ether to send to the recipient.',
	            ],
	            name: 'InsufficientFundsError',
	        });
	    }
	}
	node.InsufficientFundsError = InsufficientFundsError;
	Object.defineProperty(InsufficientFundsError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /insufficient funds|exceeds transaction sender account balance/
	});
	class IntrinsicGasTooHighError extends base_js_1$h.BaseError {
	    constructor({ cause, gas, } = {}) {
	        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
	            cause,
	            name: 'IntrinsicGasTooHighError',
	        });
	    }
	}
	node.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
	Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /intrinsic gas too high|gas limit reached/
	});
	class IntrinsicGasTooLowError extends base_js_1$h.BaseError {
	    constructor({ cause, gas, } = {}) {
	        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
	            cause,
	            name: 'IntrinsicGasTooLowError',
	        });
	    }
	}
	node.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
	Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /intrinsic gas too low/
	});
	class TransactionTypeNotSupportedError extends base_js_1$h.BaseError {
	    constructor({ cause }) {
	        super('The transaction type is not supported for this chain.', {
	            cause,
	            name: 'TransactionTypeNotSupportedError',
	        });
	    }
	}
	node.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
	Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /transaction type not valid/
	});
	class TipAboveFeeCapError extends base_js_1$h.BaseError {
	    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas, } = {}) {
	        super([
	            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas
                ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxPriorityFeePerGas)} gwei`
                : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxFeePerGas)} gwei` : ''}).`,
	        ].join('\n'), {
	            cause,
	            name: 'TipAboveFeeCapError',
	        });
	    }
	}
	node.TipAboveFeeCapError = TipAboveFeeCapError;
	Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
	});
	class UnknownNodeError extends base_js_1$h.BaseError {
	    constructor({ cause }) {
	        super(`An error occurred while executing: ${cause?.shortMessage}`, {
	            cause,
	            name: 'UnknownNodeError',
	        });
	    }
	}
	node.UnknownNodeError = UnknownNodeError;

	var getNodeError$1 = {};

	Object.defineProperty(getNodeError$1, "__esModule", { value: true });
	getNodeError$1.containsNodeError = containsNodeError;
	getNodeError$1.getNodeError = getNodeError;
	const base_js_1$g = base$1;
	const node_js_1$5 = node;
	const request_js_1$5 = request;
	const rpc_js_1$c = rpc;
	function containsNodeError(err) {
	    return (err instanceof rpc_js_1$c.TransactionRejectedRpcError ||
	        err instanceof rpc_js_1$c.InvalidInputRpcError ||
	        (err instanceof request_js_1$5.RpcRequestError && err.code === node_js_1$5.ExecutionRevertedError.code));
	}
	function getNodeError(err, args) {
	    const message = (err.details || '').toLowerCase();
	    const executionRevertedError = err instanceof base_js_1$g.BaseError
	        ? err.walk((e) => e.code === node_js_1$5.ExecutionRevertedError.code)
	        : err;
	    if (executionRevertedError instanceof base_js_1$g.BaseError)
	        return new node_js_1$5.ExecutionRevertedError({
	            cause: err,
	            message: executionRevertedError.details,
	        });
	    if (node_js_1$5.ExecutionRevertedError.nodeMessage.test(message))
	        return new node_js_1$5.ExecutionRevertedError({
	            cause: err,
	            message: err.details,
	        });
	    if (node_js_1$5.FeeCapTooHighError.nodeMessage.test(message))
	        return new node_js_1$5.FeeCapTooHighError({
	            cause: err,
	            maxFeePerGas: args?.maxFeePerGas,
	        });
	    if (node_js_1$5.FeeCapTooLowError.nodeMessage.test(message))
	        return new node_js_1$5.FeeCapTooLowError({
	            cause: err,
	            maxFeePerGas: args?.maxFeePerGas,
	        });
	    if (node_js_1$5.NonceTooHighError.nodeMessage.test(message))
	        return new node_js_1$5.NonceTooHighError({ cause: err, nonce: args?.nonce });
	    if (node_js_1$5.NonceTooLowError.nodeMessage.test(message))
	        return new node_js_1$5.NonceTooLowError({ cause: err, nonce: args?.nonce });
	    if (node_js_1$5.NonceMaxValueError.nodeMessage.test(message))
	        return new node_js_1$5.NonceMaxValueError({ cause: err, nonce: args?.nonce });
	    if (node_js_1$5.InsufficientFundsError.nodeMessage.test(message))
	        return new node_js_1$5.InsufficientFundsError({ cause: err });
	    if (node_js_1$5.IntrinsicGasTooHighError.nodeMessage.test(message))
	        return new node_js_1$5.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
	    if (node_js_1$5.IntrinsicGasTooLowError.nodeMessage.test(message))
	        return new node_js_1$5.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
	    if (node_js_1$5.TransactionTypeNotSupportedError.nodeMessage.test(message))
	        return new node_js_1$5.TransactionTypeNotSupportedError({ cause: err });
	    if (node_js_1$5.TipAboveFeeCapError.nodeMessage.test(message))
	        return new node_js_1$5.TipAboveFeeCapError({
	            cause: err,
	            maxFeePerGas: args?.maxFeePerGas,
	            maxPriorityFeePerGas: args?.maxPriorityFeePerGas,
	        });
	    return new node_js_1$5.UnknownNodeError({
	        cause: err,
	    });
	}

	Object.defineProperty(getEstimateGasError$1, "__esModule", { value: true });
	getEstimateGasError$1.getEstimateGasError = getEstimateGasError;
	const estimateGas_js_1$2 = estimateGas$2;
	const node_js_1$4 = node;
	const getNodeError_js_1$2 = getNodeError$1;
	function getEstimateGasError(err, { docsPath, ...args }) {
	    const cause = (() => {
	        const cause = (0, getNodeError_js_1$2.getNodeError)(err, args);
	        if (cause instanceof node_js_1$4.UnknownNodeError)
	            return err;
	        return cause;
	    })();
	    return new estimateGas_js_1$2.EstimateGasExecutionError(cause, {
	        docsPath,
	        ...args,
	    });
	}

	var extract$1 = {};

	Object.defineProperty(extract$1, "__esModule", { value: true });
	extract$1.extract = extract;
	function extract(value_, { format }) {
	    if (!format)
	        return {};
	    const value = {};
	    function extract_(formatted) {
	        const keys = Object.keys(formatted);
	        for (const key of keys) {
	            if (key in value_)
	                value[key] = value_[key];
	            if (formatted[key] &&
	                typeof formatted[key] === 'object' &&
	                !Array.isArray(formatted[key]))
	                extract_(formatted[key]);
	        }
	    }
	    const formatted = format(value_ || {});
	    extract_(formatted);
	    return value;
	}

	var transactionRequest = {};

	var formatter = {};

	Object.defineProperty(formatter, "__esModule", { value: true });
	formatter.defineFormatter = defineFormatter;
	function defineFormatter(type, format) {
	    return ({ exclude, format: overrides, }) => {
	        return {
	            exclude,
	            format: (args) => {
	                const formatted = format(args);
	                if (exclude) {
	                    for (const key of exclude) {
	                        delete formatted[key];
	                    }
	                }
	                return {
	                    ...formatted,
	                    ...overrides(args),
	                };
	            },
	            type,
	        };
	    };
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.defineTransactionRequest = exports.rpcTransactionType = void 0;
		exports.formatTransactionRequest = formatTransactionRequest;
		const toHex_js_1 = requireToHex();
		const formatter_js_1 = formatter;
		exports.rpcTransactionType = {
		    legacy: '0x0',
		    eip2930: '0x1',
		    eip1559: '0x2',
		    eip4844: '0x3',
		    eip7702: '0x4',
		};
		function formatTransactionRequest(request) {
		    const rpcRequest = {};
		    if (typeof request.authorizationList !== 'undefined')
		        rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);
		    if (typeof request.accessList !== 'undefined')
		        rpcRequest.accessList = request.accessList;
		    if (typeof request.blobVersionedHashes !== 'undefined')
		        rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
		    if (typeof request.blobs !== 'undefined') {
		        if (typeof request.blobs[0] !== 'string')
		            rpcRequest.blobs = request.blobs.map((x) => (0, toHex_js_1.bytesToHex)(x));
		        else
		            rpcRequest.blobs = request.blobs;
		    }
		    if (typeof request.data !== 'undefined')
		        rpcRequest.data = request.data;
		    if (typeof request.from !== 'undefined')
		        rpcRequest.from = request.from;
		    if (typeof request.gas !== 'undefined')
		        rpcRequest.gas = (0, toHex_js_1.numberToHex)(request.gas);
		    if (typeof request.gasPrice !== 'undefined')
		        rpcRequest.gasPrice = (0, toHex_js_1.numberToHex)(request.gasPrice);
		    if (typeof request.maxFeePerBlobGas !== 'undefined')
		        rpcRequest.maxFeePerBlobGas = (0, toHex_js_1.numberToHex)(request.maxFeePerBlobGas);
		    if (typeof request.maxFeePerGas !== 'undefined')
		        rpcRequest.maxFeePerGas = (0, toHex_js_1.numberToHex)(request.maxFeePerGas);
		    if (typeof request.maxPriorityFeePerGas !== 'undefined')
		        rpcRequest.maxPriorityFeePerGas = (0, toHex_js_1.numberToHex)(request.maxPriorityFeePerGas);
		    if (typeof request.nonce !== 'undefined')
		        rpcRequest.nonce = (0, toHex_js_1.numberToHex)(request.nonce);
		    if (typeof request.to !== 'undefined')
		        rpcRequest.to = request.to;
		    if (typeof request.type !== 'undefined')
		        rpcRequest.type = exports.rpcTransactionType[request.type];
		    if (typeof request.value !== 'undefined')
		        rpcRequest.value = (0, toHex_js_1.numberToHex)(request.value);
		    return rpcRequest;
		}
		exports.defineTransactionRequest = (0, formatter_js_1.defineFormatter)('transactionRequest', formatTransactionRequest);
		function formatAuthorizationList(authorizationList) {
		    return authorizationList.map((authorization) => ({
		        address: authorization.contractAddress,
		        r: authorization.r,
		        s: authorization.s,
		        chainId: (0, toHex_js_1.numberToHex)(authorization.chainId),
		        nonce: (0, toHex_js_1.numberToHex)(authorization.nonce),
		        ...(typeof authorization.yParity !== 'undefined'
		            ? { yParity: (0, toHex_js_1.numberToHex)(authorization.yParity) }
		            : {}),
		        ...(typeof authorization.v !== 'undefined' &&
		            typeof authorization.yParity === 'undefined'
		            ? { v: (0, toHex_js_1.numberToHex)(authorization.v) }
		            : {}),
		    }));
		}
		
	} (transactionRequest));

	var stateOverride = {};

	Object.defineProperty(stateOverride, "__esModule", { value: true });
	stateOverride.serializeStateMapping = serializeStateMapping;
	stateOverride.serializeAccountStateOverride = serializeAccountStateOverride;
	stateOverride.serializeStateOverride = serializeStateOverride;
	const address_js_1$7 = address$2;
	const data_js_1 = data;
	const stateOverride_js_1 = stateOverride$1;
	const isAddress_js_1$6 = requireIsAddress();
	const toHex_js_1$K = requireToHex();
	function serializeStateMapping(stateMapping) {
	    if (!stateMapping || stateMapping.length === 0)
	        return undefined;
	    return stateMapping.reduce((acc, { slot, value }) => {
	        if (slot.length !== 66)
	            throw new data_js_1.InvalidBytesLengthError({
	                size: slot.length,
	                targetSize: 66,
	                type: 'hex',
	            });
	        if (value.length !== 66)
	            throw new data_js_1.InvalidBytesLengthError({
	                size: value.length,
	                targetSize: 66,
	                type: 'hex',
	            });
	        acc[slot] = value;
	        return acc;
	    }, {});
	}
	function serializeAccountStateOverride(parameters) {
	    const { balance, nonce, state, stateDiff, code } = parameters;
	    const rpcAccountStateOverride = {};
	    if (code !== undefined)
	        rpcAccountStateOverride.code = code;
	    if (balance !== undefined)
	        rpcAccountStateOverride.balance = (0, toHex_js_1$K.numberToHex)(balance);
	    if (nonce !== undefined)
	        rpcAccountStateOverride.nonce = (0, toHex_js_1$K.numberToHex)(nonce);
	    if (state !== undefined)
	        rpcAccountStateOverride.state = serializeStateMapping(state);
	    if (stateDiff !== undefined) {
	        if (rpcAccountStateOverride.state)
	            throw new stateOverride_js_1.StateAssignmentConflictError();
	        rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
	    }
	    return rpcAccountStateOverride;
	}
	function serializeStateOverride(parameters) {
	    if (!parameters)
	        return undefined;
	    const rpcStateOverride = {};
	    for (const { address, ...accountState } of parameters) {
	        if (!(0, isAddress_js_1$6.isAddress)(address, { strict: false }))
	            throw new address_js_1$7.InvalidAddressError({ address });
	        if (rpcStateOverride[address])
	            throw new stateOverride_js_1.AccountStateConflictError({ address: address });
	        rpcStateOverride[address] = serializeAccountStateOverride(accountState);
	    }
	    return rpcStateOverride;
	}

	var assertRequest$1 = {};

	Object.defineProperty(assertRequest$1, "__esModule", { value: true });
	assertRequest$1.assertRequest = assertRequest;
	const parseAccount_js_1$8 = parseAccount$1;
	const address_js_1$6 = address$2;
	const node_js_1$3 = node;
	const transaction_js_1$9 = transaction$1;
	const isAddress_js_1$5 = requireIsAddress();
	function assertRequest(args) {
	    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to, } = args;
	    const account = account_ ? (0, parseAccount_js_1$8.parseAccount)(account_) : undefined;
	    if (account && !(0, isAddress_js_1$5.isAddress)(account.address))
	        throw new address_js_1$6.InvalidAddressError({ address: account.address });
	    if (to && !(0, isAddress_js_1$5.isAddress)(to))
	        throw new address_js_1$6.InvalidAddressError({ address: to });
	    if (typeof gasPrice !== 'undefined' &&
	        (typeof maxFeePerGas !== 'undefined' ||
	            typeof maxPriorityFeePerGas !== 'undefined'))
	        throw new transaction_js_1$9.FeeConflictError();
	    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
	        throw new node_js_1$3.FeeCapTooHighError({ maxFeePerGas });
	    if (maxPriorityFeePerGas &&
	        maxFeePerGas &&
	        maxPriorityFeePerGas > maxFeePerGas)
	        throw new node_js_1$3.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
	}

	var prepareTransactionRequest = {};

	var estimateFeesPerGas$1 = {};

	var fee = {};

	Object.defineProperty(fee, "__esModule", { value: true });
	fee.MaxFeePerGasTooLowError = fee.Eip1559FeesNotSupportedError = fee.BaseFeeScalarError = void 0;
	const formatGwei_js_1 = formatGwei$1;
	const base_js_1$f = base$1;
	class BaseFeeScalarError extends base_js_1$f.BaseError {
	    constructor() {
	        super('`baseFeeMultiplier` must be greater than 1.', {
	            name: 'BaseFeeScalarError',
	        });
	    }
	}
	fee.BaseFeeScalarError = BaseFeeScalarError;
	class Eip1559FeesNotSupportedError extends base_js_1$f.BaseError {
	    constructor() {
	        super('Chain does not support EIP-1559 fees.', {
	            name: 'Eip1559FeesNotSupportedError',
	        });
	    }
	}
	fee.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
	class MaxFeePerGasTooLowError extends base_js_1$f.BaseError {
	    constructor({ maxPriorityFeePerGas }) {
	        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`, { name: 'MaxFeePerGasTooLowError' });
	    }
	}
	fee.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;

	var estimateMaxPriorityFeePerGas$1 = {};

	var getBlock$1 = {};

	var block$1 = {};

	Object.defineProperty(block$1, "__esModule", { value: true });
	block$1.BlockNotFoundError = void 0;
	const base_js_1$e = base$1;
	class BlockNotFoundError extends base_js_1$e.BaseError {
	    constructor({ blockHash, blockNumber, }) {
	        let identifier = 'Block';
	        if (blockHash)
	            identifier = `Block at hash "${blockHash}"`;
	        if (blockNumber)
	            identifier = `Block at number "${blockNumber}"`;
	        super(`${identifier} could not be found.`, { name: 'BlockNotFoundError' });
	    }
	}
	block$1.BlockNotFoundError = BlockNotFoundError;

	var block = {};

	var transaction = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.defineTransaction = exports.transactionType = void 0;
		exports.formatTransaction = formatTransaction;
		const fromHex_js_1 = requireFromHex();
		const formatter_js_1 = formatter;
		exports.transactionType = {
		    '0x0': 'legacy',
		    '0x1': 'eip2930',
		    '0x2': 'eip1559',
		    '0x3': 'eip4844',
		    '0x4': 'eip7702',
		};
		function formatTransaction(transaction) {
		    const transaction_ = {
		        ...transaction,
		        blockHash: transaction.blockHash ? transaction.blockHash : null,
		        blockNumber: transaction.blockNumber
		            ? BigInt(transaction.blockNumber)
		            : null,
		        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : undefined,
		        gas: transaction.gas ? BigInt(transaction.gas) : undefined,
		        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
		        maxFeePerBlobGas: transaction.maxFeePerBlobGas
		            ? BigInt(transaction.maxFeePerBlobGas)
		            : undefined,
		        maxFeePerGas: transaction.maxFeePerGas
		            ? BigInt(transaction.maxFeePerGas)
		            : undefined,
		        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
		            ? BigInt(transaction.maxPriorityFeePerGas)
		            : undefined,
		        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : undefined,
		        to: transaction.to ? transaction.to : null,
		        transactionIndex: transaction.transactionIndex
		            ? Number(transaction.transactionIndex)
		            : null,
		        type: transaction.type
		            ? exports.transactionType[transaction.type]
		            : undefined,
		        typeHex: transaction.type ? transaction.type : undefined,
		        value: transaction.value ? BigInt(transaction.value) : undefined,
		        v: transaction.v ? BigInt(transaction.v) : undefined,
		    };
		    if (transaction.authorizationList)
		        transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
		    transaction_.yParity = (() => {
		        if (transaction.yParity)
		            return Number(transaction.yParity);
		        if (typeof transaction_.v === 'bigint') {
		            if (transaction_.v === 0n || transaction_.v === 27n)
		                return 0;
		            if (transaction_.v === 1n || transaction_.v === 28n)
		                return 1;
		            if (transaction_.v >= 35n)
		                return transaction_.v % 2n === 0n ? 1 : 0;
		        }
		        return undefined;
		    })();
		    if (transaction_.type === 'legacy') {
		        delete transaction_.accessList;
		        delete transaction_.maxFeePerBlobGas;
		        delete transaction_.maxFeePerGas;
		        delete transaction_.maxPriorityFeePerGas;
		        delete transaction_.yParity;
		    }
		    if (transaction_.type === 'eip2930') {
		        delete transaction_.maxFeePerBlobGas;
		        delete transaction_.maxFeePerGas;
		        delete transaction_.maxPriorityFeePerGas;
		    }
		    if (transaction_.type === 'eip1559') {
		        delete transaction_.maxFeePerBlobGas;
		    }
		    return transaction_;
		}
		exports.defineTransaction = (0, formatter_js_1.defineFormatter)('transaction', formatTransaction);
		function formatAuthorizationList(authorizationList) {
		    return authorizationList.map((authorization) => ({
		        contractAddress: authorization.address,
		        r: authorization.r,
		        s: authorization.s,
		        chainId: Number(authorization.chainId),
		        nonce: Number(authorization.nonce),
		        ...(typeof authorization.yParity !== 'undefined'
		            ? { yParity: Number(authorization.yParity) }
		            : {}),
		        ...(typeof authorization.v !== 'undefined' &&
		            typeof authorization.yParity === 'undefined'
		            ? { v: Number(authorization.v) }
		            : {}),
		    }));
		}
		
	} (transaction));

	Object.defineProperty(block, "__esModule", { value: true });
	block.defineBlock = void 0;
	block.formatBlock = formatBlock;
	const formatter_js_1 = formatter;
	const transaction_js_1$8 = transaction;
	function formatBlock(block) {
	    const transactions = block.transactions?.map((transaction) => {
	        if (typeof transaction === 'string')
	            return transaction;
	        return (0, transaction_js_1$8.formatTransaction)(transaction);
	    });
	    return {
	        ...block,
	        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
	        blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
	        difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
	        excessBlobGas: block.excessBlobGas
	            ? BigInt(block.excessBlobGas)
	            : undefined,
	        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
	        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
	        hash: block.hash ? block.hash : null,
	        logsBloom: block.logsBloom ? block.logsBloom : null,
	        nonce: block.nonce ? block.nonce : null,
	        number: block.number ? BigInt(block.number) : null,
	        size: block.size ? BigInt(block.size) : undefined,
	        timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
	        transactions,
	        totalDifficulty: block.totalDifficulty
	            ? BigInt(block.totalDifficulty)
	            : null,
	    };
	}
	block.defineBlock = (0, formatter_js_1.defineFormatter)('block', formatBlock);

	Object.defineProperty(getBlock$1, "__esModule", { value: true });
	getBlock$1.getBlock = getBlock;
	const block_js_1$2 = block$1;
	const toHex_js_1$J = requireToHex();
	const block_js_2 = block;
	async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_, } = {}) {
	    const blockTag = blockTag_ ?? 'latest';
	    const includeTransactions = includeTransactions_ ?? false;
	    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1$J.numberToHex)(blockNumber) : undefined;
	    let block = null;
	    if (blockHash) {
	        block = await client.request({
	            method: 'eth_getBlockByHash',
	            params: [blockHash, includeTransactions],
	        }, { dedupe: true });
	    }
	    else {
	        block = await client.request({
	            method: 'eth_getBlockByNumber',
	            params: [blockNumberHex || blockTag, includeTransactions],
	        }, { dedupe: Boolean(blockNumberHex) });
	    }
	    if (!block)
	        throw new block_js_1$2.BlockNotFoundError({ blockHash, blockNumber });
	    const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
	    return format(block);
	}

	var getGasPrice$3 = {};

	Object.defineProperty(getGasPrice$3, "__esModule", { value: true });
	getGasPrice$3.getGasPrice = getGasPrice$2;
	async function getGasPrice$2(client) {
	    const gasPrice = await client.request({
	        method: 'eth_gasPrice',
	    });
	    return BigInt(gasPrice);
	}

	Object.defineProperty(estimateMaxPriorityFeePerGas$1, "__esModule", { value: true });
	estimateMaxPriorityFeePerGas$1.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
	estimateMaxPriorityFeePerGas$1.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas;
	const fee_js_1$1 = fee;
	const fromHex_js_1$a = requireFromHex();
	const getAction_js_1$o = getAction$1;
	const getBlock_js_1$4 = getBlock$1;
	const getGasPrice_js_1$2 = getGasPrice$3;
	async function estimateMaxPriorityFeePerGas(client, args) {
	    return internal_estimateMaxPriorityFeePerGas(client, args);
	}
	async function internal_estimateMaxPriorityFeePerGas(client, args) {
	    const { block: block_, chain = client.chain, request } = args || {};
	    try {
	        const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
	        if (typeof maxPriorityFeePerGas === 'function') {
	            const block = block_ || (await (0, getAction_js_1$o.getAction)(client, getBlock_js_1$4.getBlock, 'getBlock')({}));
	            const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
	                block,
	                client,
	                request,
	            });
	            if (maxPriorityFeePerGas_ === null)
	                throw new Error();
	            return maxPriorityFeePerGas_;
	        }
	        if (typeof maxPriorityFeePerGas !== 'undefined')
	            return maxPriorityFeePerGas;
	        const maxPriorityFeePerGasHex = await client.request({
	            method: 'eth_maxPriorityFeePerGas',
	        });
	        return (0, fromHex_js_1$a.hexToBigInt)(maxPriorityFeePerGasHex);
	    }
	    catch {
	        const [block, gasPrice] = await Promise.all([
	            block_
	                ? Promise.resolve(block_)
	                : (0, getAction_js_1$o.getAction)(client, getBlock_js_1$4.getBlock, 'getBlock')({}),
	            (0, getAction_js_1$o.getAction)(client, getGasPrice_js_1$2.getGasPrice, 'getGasPrice')({}),
	        ]);
	        if (typeof block.baseFeePerGas !== 'bigint')
	            throw new fee_js_1$1.Eip1559FeesNotSupportedError();
	        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
	        if (maxPriorityFeePerGas < 0n)
	            return 0n;
	        return maxPriorityFeePerGas;
	    }
	}

	Object.defineProperty(estimateFeesPerGas$1, "__esModule", { value: true });
	estimateFeesPerGas$1.estimateFeesPerGas = estimateFeesPerGas;
	estimateFeesPerGas$1.internal_estimateFeesPerGas = internal_estimateFeesPerGas;
	const fee_js_1 = fee;
	const getAction_js_1$n = getAction$1;
	const estimateMaxPriorityFeePerGas_js_1$1 = estimateMaxPriorityFeePerGas$1;
	const getBlock_js_1$3 = getBlock$1;
	const getGasPrice_js_1$1 = getGasPrice$3;
	async function estimateFeesPerGas(client, args) {
	    return internal_estimateFeesPerGas(client, args);
	}
	async function internal_estimateFeesPerGas(client, args) {
	    const { block: block_, chain = client.chain, request, type = 'eip1559', } = args || {};
	    const baseFeeMultiplier = await (async () => {
	        if (typeof chain?.fees?.baseFeeMultiplier === 'function')
	            return chain.fees.baseFeeMultiplier({
	                block: block_,
	                client,
	                request,
	            });
	        return chain?.fees?.baseFeeMultiplier ?? 1.2;
	    })();
	    if (baseFeeMultiplier < 1)
	        throw new fee_js_1.BaseFeeScalarError();
	    const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0;
	    const denominator = 10 ** decimals;
	    const multiply = (base) => (base * BigInt(Math.ceil(baseFeeMultiplier * denominator))) /
	        BigInt(denominator);
	    const block = block_
	        ? block_
	        : await (0, getAction_js_1$n.getAction)(client, getBlock_js_1$3.getBlock, 'getBlock')({});
	    if (typeof chain?.fees?.estimateFeesPerGas === 'function') {
	        const fees = (await chain.fees.estimateFeesPerGas({
	            block: block_,
	            client,
	            multiply,
	            request,
	            type,
	        }));
	        if (fees !== null)
	            return fees;
	    }
	    if (type === 'eip1559') {
	        if (typeof block.baseFeePerGas !== 'bigint')
	            throw new fee_js_1.Eip1559FeesNotSupportedError();
	        const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === 'bigint'
	            ? request.maxPriorityFeePerGas
	            : await (0, estimateMaxPriorityFeePerGas_js_1$1.internal_estimateMaxPriorityFeePerGas)(client, {
	                block: block,
	                chain,
	                request,
	            });
	        const baseFeePerGas = multiply(block.baseFeePerGas);
	        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
	        return {
	            maxFeePerGas,
	            maxPriorityFeePerGas,
	        };
	    }
	    const gasPrice = request?.gasPrice ??
	        multiply(await (0, getAction_js_1$n.getAction)(client, getGasPrice_js_1$1.getGasPrice, 'getGasPrice')({}));
	    return {
	        gasPrice,
	    };
	}

	var getTransactionCount$1 = {};

	Object.defineProperty(getTransactionCount$1, "__esModule", { value: true });
	getTransactionCount$1.getTransactionCount = getTransactionCount;
	const fromHex_js_1$9 = requireFromHex();
	const toHex_js_1$I = requireToHex();
	async function getTransactionCount(client, { address, blockTag = 'latest', blockNumber }) {
	    const count = await client.request({
	        method: 'eth_getTransactionCount',
	        params: [address, blockNumber ? (0, toHex_js_1$I.numberToHex)(blockNumber) : blockTag],
	    }, { dedupe: Boolean(blockNumber) });
	    return (0, fromHex_js_1$9.hexToNumber)(count);
	}

	var blobsToCommitments$1 = {};

	Object.defineProperty(blobsToCommitments$1, "__esModule", { value: true });
	blobsToCommitments$1.blobsToCommitments = blobsToCommitments;
	const toBytes_js_1$g = requireToBytes();
	const toHex_js_1$H = requireToHex();
	function blobsToCommitments(parameters) {
	    const { kzg } = parameters;
	    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
	    const blobs = (typeof parameters.blobs[0] === 'string'
	        ? parameters.blobs.map((x) => (0, toBytes_js_1$g.hexToBytes)(x))
	        : parameters.blobs);
	    const commitments = [];
	    for (const blob of blobs)
	        commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
	    return (to === 'bytes'
	        ? commitments
	        : commitments.map((x) => (0, toHex_js_1$H.bytesToHex)(x)));
	}

	var blobsToProofs$1 = {};

	Object.defineProperty(blobsToProofs$1, "__esModule", { value: true });
	blobsToProofs$1.blobsToProofs = blobsToProofs;
	const toBytes_js_1$f = requireToBytes();
	const toHex_js_1$G = requireToHex();
	function blobsToProofs(parameters) {
	    const { kzg } = parameters;
	    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
	    const blobs = (typeof parameters.blobs[0] === 'string'
	        ? parameters.blobs.map((x) => (0, toBytes_js_1$f.hexToBytes)(x))
	        : parameters.blobs);
	    const commitments = (typeof parameters.commitments[0] === 'string'
	        ? parameters.commitments.map((x) => (0, toBytes_js_1$f.hexToBytes)(x))
	        : parameters.commitments);
	    const proofs = [];
	    for (let i = 0; i < blobs.length; i++) {
	        const blob = blobs[i];
	        const commitment = commitments[i];
	        proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
	    }
	    return (to === 'bytes'
	        ? proofs
	        : proofs.map((x) => (0, toHex_js_1$G.bytesToHex)(x)));
	}

	var commitmentsToVersionedHashes$1 = {};

	var commitmentToVersionedHash$1 = {};

	var sha256$1 = {};

	Object.defineProperty(sha256$1, "__esModule", { value: true });
	sha256$1.sha256 = sha256;
	const sha256_1 = sha256$3;
	const isHex_js_1$6 = isHex$1;
	const toBytes_js_1$e = requireToBytes();
	const toHex_js_1$F = requireToHex();
	function sha256(value, to_) {
	    const to = to_ || 'hex';
	    const bytes = (0, sha256_1.sha256)((0, isHex_js_1$6.isHex)(value, { strict: false }) ? (0, toBytes_js_1$e.toBytes)(value) : value);
	    if (to === 'bytes')
	        return bytes;
	    return (0, toHex_js_1$F.toHex)(bytes);
	}

	Object.defineProperty(commitmentToVersionedHash$1, "__esModule", { value: true });
	commitmentToVersionedHash$1.commitmentToVersionedHash = commitmentToVersionedHash;
	const toHex_js_1$E = requireToHex();
	const sha256_js_1 = sha256$1;
	function commitmentToVersionedHash(parameters) {
	    const { commitment, version = 1 } = parameters;
	    const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes');
	    const versionedHash = (0, sha256_js_1.sha256)(commitment, 'bytes');
	    versionedHash.set([version], 0);
	    return (to === 'bytes' ? versionedHash : (0, toHex_js_1$E.bytesToHex)(versionedHash));
	}

	Object.defineProperty(commitmentsToVersionedHashes$1, "__esModule", { value: true });
	commitmentsToVersionedHashes$1.commitmentsToVersionedHashes = commitmentsToVersionedHashes;
	const commitmentToVersionedHash_js_1$1 = commitmentToVersionedHash$1;
	function commitmentsToVersionedHashes(parameters) {
	    const { commitments, version } = parameters;
	    const to = parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes');
	    const hashes = [];
	    for (const commitment of commitments) {
	        hashes.push((0, commitmentToVersionedHash_js_1$1.commitmentToVersionedHash)({
	            commitment,
	            to,
	            version,
	        }));
	    }
	    return hashes;
	}

	var toBlobSidecars$1 = {};

	var toBlobs$1 = {};

	var blob$1 = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.maxBytesPerTransaction = exports.bytesPerBlob = exports.fieldElementsPerBlob = exports.bytesPerFieldElement = void 0;
		const blobsPerTransaction = 6;
		exports.bytesPerFieldElement = 32;
		exports.fieldElementsPerBlob = 4096;
		exports.bytesPerBlob = exports.bytesPerFieldElement * exports.fieldElementsPerBlob;
		exports.maxBytesPerTransaction = exports.bytesPerBlob * blobsPerTransaction -
		    1 -
		    1 * exports.fieldElementsPerBlob * blobsPerTransaction;
		
	} (blob$1));

	var blob = {};

	var kzg = {};

	Object.defineProperty(kzg, "__esModule", { value: true });
	kzg.versionedHashVersionKzg = void 0;
	kzg.versionedHashVersionKzg = 1;

	Object.defineProperty(blob, "__esModule", { value: true });
	blob.InvalidVersionedHashVersionError = blob.InvalidVersionedHashSizeError = blob.EmptyBlobError = blob.BlobSizeTooLargeError = void 0;
	const kzg_js_1$1 = kzg;
	const base_js_1$d = base$1;
	class BlobSizeTooLargeError extends base_js_1$d.BaseError {
	    constructor({ maxSize, size }) {
	        super('Blob size is too large.', {
	            metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],
	            name: 'BlobSizeTooLargeError',
	        });
	    }
	}
	blob.BlobSizeTooLargeError = BlobSizeTooLargeError;
	class EmptyBlobError extends base_js_1$d.BaseError {
	    constructor() {
	        super('Blob data must not be empty.', { name: 'EmptyBlobError' });
	    }
	}
	blob.EmptyBlobError = EmptyBlobError;
	class InvalidVersionedHashSizeError extends base_js_1$d.BaseError {
	    constructor({ hash, size, }) {
	        super(`Versioned hash "${hash}" size is invalid.`, {
	            metaMessages: ['Expected: 32', `Received: ${size}`],
	            name: 'InvalidVersionedHashSizeError',
	        });
	    }
	}
	blob.InvalidVersionedHashSizeError = InvalidVersionedHashSizeError;
	class InvalidVersionedHashVersionError extends base_js_1$d.BaseError {
	    constructor({ hash, version, }) {
	        super(`Versioned hash "${hash}" version is invalid.`, {
	            metaMessages: [
	                `Expected: ${kzg_js_1$1.versionedHashVersionKzg}`,
	                `Received: ${version}`,
	            ],
	            name: 'InvalidVersionedHashVersionError',
	        });
	    }
	}
	blob.InvalidVersionedHashVersionError = InvalidVersionedHashVersionError;

	Object.defineProperty(toBlobs$1, "__esModule", { value: true });
	toBlobs$1.toBlobs = toBlobs;
	const blob_js_1$1 = blob$1;
	const blob_js_2 = blob;
	const cursor_js_1$3 = cursor$1;
	const size_js_1$4 = size$2;
	const toBytes_js_1$d = requireToBytes();
	const toHex_js_1$D = requireToHex();
	function toBlobs(parameters) {
	    const to = parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes');
	    const data = (typeof parameters.data === 'string'
	        ? (0, toBytes_js_1$d.hexToBytes)(parameters.data)
	        : parameters.data);
	    const size_ = (0, size_js_1$4.size)(data);
	    if (!size_)
	        throw new blob_js_2.EmptyBlobError();
	    if (size_ > blob_js_1$1.maxBytesPerTransaction)
	        throw new blob_js_2.BlobSizeTooLargeError({
	            maxSize: blob_js_1$1.maxBytesPerTransaction,
	            size: size_,
	        });
	    const blobs = [];
	    let active = true;
	    let position = 0;
	    while (active) {
	        const blob = (0, cursor_js_1$3.createCursor)(new Uint8Array(blob_js_1$1.bytesPerBlob));
	        let size = 0;
	        while (size < blob_js_1$1.fieldElementsPerBlob) {
	            const bytes = data.slice(position, position + (blob_js_1$1.bytesPerFieldElement - 1));
	            blob.pushByte(0x00);
	            blob.pushBytes(bytes);
	            if (bytes.length < 31) {
	                blob.pushByte(0x80);
	                active = false;
	                break;
	            }
	            size++;
	            position += 31;
	        }
	        blobs.push(blob);
	    }
	    return (to === 'bytes'
	        ? blobs.map((x) => x.bytes)
	        : blobs.map((x) => (0, toHex_js_1$D.bytesToHex)(x.bytes)));
	}

	Object.defineProperty(toBlobSidecars$1, "__esModule", { value: true });
	toBlobSidecars$1.toBlobSidecars = toBlobSidecars;
	const blobsToCommitments_js_1 = blobsToCommitments$1;
	const blobsToProofs_js_1 = blobsToProofs$1;
	const toBlobs_js_1 = toBlobs$1;
	function toBlobSidecars(parameters) {
	    const { data, kzg, to } = parameters;
	    const blobs = parameters.blobs ?? (0, toBlobs_js_1.toBlobs)({ data: data, to });
	    const commitments = parameters.commitments ?? (0, blobsToCommitments_js_1.blobsToCommitments)({ blobs, kzg: kzg, to });
	    const proofs = parameters.proofs ?? (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg: kzg, to });
	    const sidecars = [];
	    for (let i = 0; i < blobs.length; i++)
	        sidecars.push({
	            blob: blobs[i],
	            commitment: commitments[i],
	            proof: proofs[i],
	        });
	    return sidecars;
	}

	var getTransactionType$1 = {};

	Object.defineProperty(getTransactionType$1, "__esModule", { value: true });
	getTransactionType$1.getTransactionType = getTransactionType;
	const transaction_js_1$7 = transaction$1;
	function getTransactionType(transaction) {
	    if (transaction.type)
	        return transaction.type;
	    if (typeof transaction.authorizationList !== 'undefined')
	        return 'eip7702';
	    if (typeof transaction.blobs !== 'undefined' ||
	        typeof transaction.blobVersionedHashes !== 'undefined' ||
	        typeof transaction.maxFeePerBlobGas !== 'undefined' ||
	        typeof transaction.sidecars !== 'undefined')
	        return 'eip4844';
	    if (typeof transaction.maxFeePerGas !== 'undefined' ||
	        typeof transaction.maxPriorityFeePerGas !== 'undefined') {
	        return 'eip1559';
	    }
	    if (typeof transaction.gasPrice !== 'undefined') {
	        if (typeof transaction.accessList !== 'undefined')
	            return 'eip2930';
	        return 'legacy';
	    }
	    throw new transaction_js_1$7.InvalidSerializableTransactionError({ transaction });
	}

	var getChainId$1 = {};

	Object.defineProperty(getChainId$1, "__esModule", { value: true });
	getChainId$1.getChainId = getChainId;
	const fromHex_js_1$8 = requireFromHex();
	async function getChainId(client) {
	    const chainIdHex = await client.request({
	        method: 'eth_chainId',
	    }, { dedupe: true });
	    return (0, fromHex_js_1$8.hexToNumber)(chainIdHex);
	}

	var hasRequiredPrepareTransactionRequest;

	function requirePrepareTransactionRequest () {
		if (hasRequiredPrepareTransactionRequest) return prepareTransactionRequest;
		hasRequiredPrepareTransactionRequest = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.defaultParameters = void 0;
			exports.prepareTransactionRequest = prepareTransactionRequest;
			const parseAccount_js_1 = parseAccount$1;
			const estimateFeesPerGas_js_1 = estimateFeesPerGas$1;
			const estimateGas_js_1 = requireEstimateGas();
			const getBlock_js_1 = getBlock$1;
			const getTransactionCount_js_1 = getTransactionCount$1;
			const fee_js_1 = fee;
			const blobsToCommitments_js_1 = blobsToCommitments$1;
			const blobsToProofs_js_1 = blobsToProofs$1;
			const commitmentsToVersionedHashes_js_1 = commitmentsToVersionedHashes$1;
			const toBlobSidecars_js_1 = toBlobSidecars$1;
			const getAction_js_1 = getAction$1;
			const assertRequest_js_1 = assertRequest$1;
			const getTransactionType_js_1 = getTransactionType$1;
			const getChainId_js_1 = getChainId$1;
			exports.defaultParameters = [
			    'blobVersionedHashes',
			    'chainId',
			    'fees',
			    'gas',
			    'nonce',
			    'type',
			];
			async function prepareTransactionRequest(client, args) {
			    const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = exports.defaultParameters, type, } = args;
			    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
			    const request = { ...args, ...(account ? { from: account?.address } : {}) };
			    let block;
			    async function getBlock() {
			        if (block)
			            return block;
			        block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({ blockTag: 'latest' });
			        return block;
			    }
			    let chainId;
			    async function getChainId() {
			        if (chainId)
			            return chainId;
			        if (chain)
			            return chain.id;
			        if (typeof args.chainId !== 'undefined')
			            return args.chainId;
			        const chainId_ = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});
			        chainId = chainId_;
			        return chainId;
			    }
			    if ((parameters.includes('blobVersionedHashes') ||
			        parameters.includes('sidecars')) &&
			        blobs &&
			        kzg) {
			        const commitments = (0, blobsToCommitments_js_1.blobsToCommitments)({ blobs, kzg });
			        if (parameters.includes('blobVersionedHashes')) {
			            const versionedHashes = (0, commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes)({
			                commitments,
			                to: 'hex',
			            });
			            request.blobVersionedHashes = versionedHashes;
			        }
			        if (parameters.includes('sidecars')) {
			            const proofs = (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg });
			            const sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({
			                blobs,
			                commitments,
			                proofs,
			                to: 'hex',
			            });
			            request.sidecars = sidecars;
			        }
			    }
			    if (parameters.includes('chainId'))
			        request.chainId = await getChainId();
			    if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {
			        if (nonceManager) {
			            const chainId = await getChainId();
			            request.nonce = await nonceManager.consume({
			                address: account.address,
			                chainId,
			                client,
			            });
			        }
			        else {
			            request.nonce = await (0, getAction_js_1.getAction)(client, getTransactionCount_js_1.getTransactionCount, 'getTransactionCount')({
			                address: account.address,
			                blockTag: 'pending',
			            });
			        }
			    }
			    if ((parameters.includes('fees') || parameters.includes('type')) &&
			        typeof type === 'undefined') {
			        try {
			            request.type = (0, getTransactionType_js_1.getTransactionType)(request);
			        }
			        catch {
			            const block = await getBlock();
			            request.type =
			                typeof block?.baseFeePerGas === 'bigint' ? 'eip1559' : 'legacy';
			        }
			    }
			    if (parameters.includes('fees')) {
			        if (request.type !== 'legacy' && request.type !== 'eip2930') {
			            if (typeof request.maxFeePerGas === 'undefined' ||
			                typeof request.maxPriorityFeePerGas === 'undefined') {
			                const block = await getBlock();
			                const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
			                    block: block,
			                    chain,
			                    request: request,
			                });
			                if (typeof args.maxPriorityFeePerGas === 'undefined' &&
			                    args.maxFeePerGas &&
			                    args.maxFeePerGas < maxPriorityFeePerGas)
			                    throw new fee_js_1.MaxFeePerGasTooLowError({
			                        maxPriorityFeePerGas,
			                    });
			                request.maxPriorityFeePerGas = maxPriorityFeePerGas;
			                request.maxFeePerGas = maxFeePerGas;
			            }
			        }
			        else {
			            if (typeof args.maxFeePerGas !== 'undefined' ||
			                typeof args.maxPriorityFeePerGas !== 'undefined')
			                throw new fee_js_1.Eip1559FeesNotSupportedError();
			            const block = await getBlock();
			            const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
			                block: block,
			                chain,
			                request: request,
			                type: 'legacy',
			            });
			            request.gasPrice = gasPrice_;
			        }
			    }
			    if (parameters.includes('gas') && typeof gas === 'undefined')
			        request.gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, 'estimateGas')({
			            ...request,
			            account: account
			                ? { address: account.address, type: 'json-rpc' }
			                : undefined,
			        });
			    (0, assertRequest_js_1.assertRequest)(request);
			    delete request.parameters;
			    return request;
			}
			
		} (prepareTransactionRequest));
		return prepareTransactionRequest;
	}

	var getBalance$1 = {};

	Object.defineProperty(getBalance$1, "__esModule", { value: true });
	getBalance$1.getBalance = getBalance;
	const toHex_js_1$C = requireToHex();
	async function getBalance(client, { address, blockNumber, blockTag = 'latest' }) {
	    const blockNumberHex = blockNumber ? (0, toHex_js_1$C.numberToHex)(blockNumber) : undefined;
	    const balance = await client.request({
	        method: 'eth_getBalance',
	        params: [address, blockNumberHex || blockTag],
	    });
	    return BigInt(balance);
	}

	var hasRequiredEstimateGas;

	function requireEstimateGas () {
		if (hasRequiredEstimateGas) return estimateGas$3;
		hasRequiredEstimateGas = 1;
		Object.defineProperty(estimateGas$3, "__esModule", { value: true });
		estimateGas$3.estimateGas = estimateGas;
		const parseAccount_js_1 = parseAccount$1;
		const base_js_1 = base$1;
		const recoverAuthorizationAddress_js_1 = recoverAuthorizationAddress$1;
		const toHex_js_1 = requireToHex();
		const getEstimateGasError_js_1 = getEstimateGasError$1;
		const extract_js_1 = extract$1;
		const transactionRequest_js_1 = transactionRequest;
		const stateOverride_js_1 = stateOverride;
		const assertRequest_js_1 = assertRequest$1;
		const prepareTransactionRequest_js_1 = requirePrepareTransactionRequest();
		const getBalance_js_1 = getBalance$1;
		async function estimateGas(client, args) {
		    const account_ = args.account ?? client.account;
		    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
		    try {
		        const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = (await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, {
		            ...args,
		            parameters: account?.type === 'local' ? undefined : ['blobVersionedHashes'],
		        }));
		        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
		        const block = blockNumberHex || blockTag;
		        const rpcStateOverride = (0, stateOverride_js_1.serializeStateOverride)(stateOverride);
		        const to = await (async () => {
		            if (rest.to)
		                return rest.to;
		            if (authorizationList && authorizationList.length > 0)
		                return await (0, recoverAuthorizationAddress_js_1.recoverAuthorizationAddress)({
		                    authorization: authorizationList[0],
		                }).catch(() => {
		                    throw new base_js_1.BaseError('`to` is required. Could not infer from `authorizationList`');
		                });
		            return undefined;
		        })();
		        (0, assertRequest_js_1.assertRequest)(args);
		        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
		        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
		        const request = format({
		            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
		            from: account?.address,
		            accessList,
		            authorizationList,
		            blobs,
		            blobVersionedHashes,
		            data,
		            gas,
		            gasPrice,
		            maxFeePerBlobGas,
		            maxFeePerGas,
		            maxPriorityFeePerGas,
		            nonce,
		            to,
		            value,
		        });
		        function estimateGas_rpc(parameters) {
		            const { block, request, rpcStateOverride } = parameters;
		            return client.request({
		                method: 'eth_estimateGas',
		                params: rpcStateOverride
		                    ? [request, block ?? 'latest', rpcStateOverride]
		                    : block
		                        ? [request, block]
		                        : [request],
		            });
		        }
		        let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
		        if (authorizationList) {
		            const value = await (0, getBalance_js_1.getBalance)(client, { address: request.from });
		            const estimates = await Promise.all(authorizationList.map(async (authorization) => {
		                const { contractAddress } = authorization;
		                const estimate = await estimateGas_rpc({
		                    block,
		                    request: {
		                        authorizationList: undefined,
		                        data,
		                        from: account?.address,
		                        to: contractAddress,
		                        value: (0, toHex_js_1.numberToHex)(value),
		                    },
		                    rpcStateOverride,
		                }).catch(() => 100000n);
		                return 2n * BigInt(estimate);
		            }));
		            estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
		        }
		        return estimate;
		    }
		    catch (err) {
		        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
		            ...args,
		            account,
		            chain: client.chain,
		        });
		    }
		}
		
		return estimateGas$3;
	}

	Object.defineProperty(estimateContractGas$1, "__esModule", { value: true });
	estimateContractGas$1.estimateContractGas = estimateContractGas;
	const parseAccount_js_1$7 = parseAccount$1;
	const encodeFunctionData_js_1$6 = encodeFunctionData$1;
	const getContractError_js_1$4 = getContractError$1;
	const getAction_js_1$m = getAction$1;
	const estimateGas_js_1$1 = requireEstimateGas();
	async function estimateContractGas(client, parameters) {
	    const { abi, address, args, functionName, ...request } = parameters;
	    const data = (0, encodeFunctionData_js_1$6.encodeFunctionData)({
	        abi,
	        args,
	        functionName,
	    });
	    try {
	        const gas = await (0, getAction_js_1$m.getAction)(client, estimateGas_js_1$1.estimateGas, 'estimateGas')({
	            data,
	            to: address,
	            ...request,
	        });
	        return gas;
	    }
	    catch (error) {
	        const account = request.account ? (0, parseAccount_js_1$7.parseAccount)(request.account) : undefined;
	        throw (0, getContractError_js_1$4.getContractError)(error, {
	            abi,
	            address,
	            args,
	            docsPath: '/docs/contract/estimateContractGas',
	            functionName,
	            sender: account?.address,
	        });
	    }
	}

	var getContractEvents$2 = {};

	var getLogs$1 = {};

	var parseEventLogs$2 = {};

	var isAddressEqual$1 = {};

	Object.defineProperty(isAddressEqual$1, "__esModule", { value: true });
	isAddressEqual$1.isAddressEqual = isAddressEqual;
	const address_js_1$5 = address$2;
	const isAddress_js_1$4 = requireIsAddress();
	function isAddressEqual(a, b) {
	    if (!(0, isAddress_js_1$4.isAddress)(a, { strict: false }))
	        throw new address_js_1$5.InvalidAddressError({ address: a });
	    if (!(0, isAddress_js_1$4.isAddress)(b, { strict: false }))
	        throw new address_js_1$5.InvalidAddressError({ address: b });
	    return a.toLowerCase() === b.toLowerCase();
	}

	var decodeEventLog$1 = {};

	Object.defineProperty(decodeEventLog$1, "__esModule", { value: true });
	decodeEventLog$1.decodeEventLog = decodeEventLog;
	const abi_js_1$b = requireAbi();
	const size_js_1$3 = size$2;
	const toEventSelector_js_1 = toEventSelector;
	const cursor_js_1$2 = cursor;
	const decodeAbiParameters_js_1$4 = decodeAbiParameters$1;
	const formatAbiItem_js_1$2 = requireFormatAbiItem();
	const docsPath$5 = '/docs/contract/decodeEventLog';
	function decodeEventLog(parameters) {
	    const { abi, data, strict: strict_, topics, } = parameters;
	    const strict = strict_ ?? true;
	    const [signature, ...argTopics] = topics;
	    if (!signature)
	        throw new abi_js_1$b.AbiEventSignatureEmptyTopicsError({ docsPath: docsPath$5 });
	    const abiItem = abi.find((x) => x.type === 'event' &&
	        signature === (0, toEventSelector_js_1.toEventSelector)((0, formatAbiItem_js_1$2.formatAbiItem)(x)));
	    if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')
	        throw new abi_js_1$b.AbiEventSignatureNotFoundError(signature, { docsPath: docsPath$5 });
	    const { name, inputs } = abiItem;
	    const isUnnamed = inputs?.some((x) => !('name' in x && x.name));
	    let args = isUnnamed ? [] : {};
	    const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed);
	    for (let i = 0; i < indexedInputs.length; i++) {
	        const param = indexedInputs[i];
	        const topic = argTopics[i];
	        if (!topic)
	            throw new abi_js_1$b.DecodeLogTopicsMismatch({
	                abiItem,
	                param: param,
	            });
	        args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });
	    }
	    const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));
	    if (nonIndexedInputs.length > 0) {
	        if (data && data !== '0x') {
	            try {
	                const decodedData = (0, decodeAbiParameters_js_1$4.decodeAbiParameters)(nonIndexedInputs, data);
	                if (decodedData) {
	                    if (isUnnamed)
	                        args = [...args, ...decodedData];
	                    else {
	                        for (let i = 0; i < nonIndexedInputs.length; i++) {
	                            args[nonIndexedInputs[i].name] = decodedData[i];
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                if (strict) {
	                    if (err instanceof abi_js_1$b.AbiDecodingDataSizeTooSmallError ||
	                        err instanceof cursor_js_1$2.PositionOutOfBoundsError)
	                        throw new abi_js_1$b.DecodeLogDataMismatch({
	                            abiItem,
	                            data: data,
	                            params: nonIndexedInputs,
	                            size: (0, size_js_1$3.size)(data),
	                        });
	                    throw err;
	                }
	            }
	        }
	        else if (strict) {
	            throw new abi_js_1$b.DecodeLogDataMismatch({
	                abiItem,
	                data: '0x',
	                params: nonIndexedInputs,
	                size: 0,
	            });
	        }
	    }
	    return {
	        eventName: name,
	        args: Object.values(args).length > 0 ? args : undefined,
	    };
	}
	function decodeTopic({ param, value }) {
	    if (param.type === 'string' ||
	        param.type === 'bytes' ||
	        param.type === 'tuple' ||
	        param.type.match(/^(.*)\[(\d+)?\]$/))
	        return value;
	    const decodedArg = (0, decodeAbiParameters_js_1$4.decodeAbiParameters)([param], value) || [];
	    return decodedArg[0];
	}

	Object.defineProperty(parseEventLogs$2, "__esModule", { value: true });
	parseEventLogs$2.parseEventLogs = parseEventLogs$1;
	const abi_js_1$a = requireAbi();
	const isAddressEqual_js_1$5 = isAddressEqual$1;
	const toBytes_js_1$c = requireToBytes();
	const keccak256_js_1$8 = keccak256$3;
	const decodeEventLog_js_1$2 = decodeEventLog$1;
	const getAbiItem_js_1$4 = getAbiItem$1;
	function parseEventLogs$1(parameters) {
	    const { abi, args, logs, strict = true } = parameters;
	    const eventName = (() => {
	        if (!parameters.eventName)
	            return undefined;
	        if (Array.isArray(parameters.eventName))
	            return parameters.eventName;
	        return [parameters.eventName];
	    })();
	    return logs
	        .map((log) => {
	        try {
	            const abiItem = (0, getAbiItem_js_1$4.getAbiItem)({
	                abi: abi,
	                name: log.topics[0],
	            });
	            if (!abiItem)
	                return null;
	            const event = (0, decodeEventLog_js_1$2.decodeEventLog)({
	                ...log,
	                abi: [abiItem],
	                strict,
	            });
	            if (eventName && !eventName.includes(event.eventName))
	                return null;
	            if (!includesArgs({
	                args: event.args,
	                inputs: abiItem.inputs,
	                matchArgs: args,
	            }))
	                return null;
	            return { ...event, ...log };
	        }
	        catch (err) {
	            let eventName;
	            let isUnnamed;
	            if (err instanceof abi_js_1$a.AbiEventSignatureNotFoundError)
	                return null;
	            if (err instanceof abi_js_1$a.DecodeLogDataMismatch ||
	                err instanceof abi_js_1$a.DecodeLogTopicsMismatch) {
	                if (strict)
	                    return null;
	                eventName = err.abiItem.name;
	                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
	            }
	            return { ...log, args: isUnnamed ? [] : {}, eventName };
	        }
	    })
	        .filter(Boolean);
	}
	function includesArgs(parameters) {
	    const { args, inputs, matchArgs } = parameters;
	    if (!matchArgs)
	        return true;
	    if (!args)
	        return false;
	    function isEqual(input, value, arg) {
	        try {
	            if (input.type === 'address')
	                return (0, isAddressEqual_js_1$5.isAddressEqual)(value, arg);
	            if (input.type === 'string' || input.type === 'bytes')
	                return (0, keccak256_js_1$8.keccak256)((0, toBytes_js_1$c.toBytes)(value)) === arg;
	            return value === arg;
	        }
	        catch {
	            return false;
	        }
	    }
	    if (Array.isArray(args) && Array.isArray(matchArgs)) {
	        return matchArgs.every((value, index) => {
	            if (!value)
	                return true;
	            const input = inputs[index];
	            if (!input)
	                return false;
	            const value_ = Array.isArray(value) ? value : [value];
	            return value_.some((value) => isEqual(input, value, args[index]));
	        });
	    }
	    if (typeof args === 'object' &&
	        !Array.isArray(args) &&
	        typeof matchArgs === 'object' &&
	        !Array.isArray(matchArgs))
	        return Object.entries(matchArgs).every(([key, value]) => {
	            if (!value)
	                return true;
	            const input = inputs.find((input) => input.name === key);
	            if (!input)
	                return false;
	            const value_ = Array.isArray(value) ? value : [value];
	            return value_.some((value) => isEqual(input, value, args[key]));
	        });
	    return false;
	}

	var log = {};

	Object.defineProperty(log, "__esModule", { value: true });
	log.formatLog = formatLog;
	function formatLog(log, { args, eventName, } = {}) {
	    return {
	        ...log,
	        blockHash: log.blockHash ? log.blockHash : null,
	        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
	        logIndex: log.logIndex ? Number(log.logIndex) : null,
	        transactionHash: log.transactionHash ? log.transactionHash : null,
	        transactionIndex: log.transactionIndex
	            ? Number(log.transactionIndex)
	            : null,
	        ...(eventName ? { args, eventName } : {}),
	    };
	}

	Object.defineProperty(getLogs$1, "__esModule", { value: true });
	getLogs$1.getLogs = getLogs;
	const encodeEventTopics_js_1$3 = encodeEventTopics$1;
	const parseEventLogs_js_1$2 = parseEventLogs$2;
	const toHex_js_1$B = requireToHex();
	const log_js_1$4 = log;
	async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_, } = {}) {
	    const strict = strict_ ?? false;
	    const events = events_ ?? (event ? [event] : undefined);
	    let topics = [];
	    if (events) {
	        const encoded = events.flatMap((event) => (0, encodeEventTopics_js_1$3.encodeEventTopics)({
	            abi: [event],
	            eventName: event.name,
	            args: events_ ? undefined : args,
	        }));
	        topics = [encoded];
	        if (event)
	            topics = topics[0];
	    }
	    let logs;
	    if (blockHash) {
	        logs = await client.request({
	            method: 'eth_getLogs',
	            params: [{ address, topics, blockHash }],
	        });
	    }
	    else {
	        logs = await client.request({
	            method: 'eth_getLogs',
	            params: [
	                {
	                    address,
	                    topics,
	                    fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1$B.numberToHex)(fromBlock) : fromBlock,
	                    toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1$B.numberToHex)(toBlock) : toBlock,
	                },
	            ],
	        });
	    }
	    const formattedLogs = logs.map((log) => (0, log_js_1$4.formatLog)(log));
	    if (!events)
	        return formattedLogs;
	    return (0, parseEventLogs_js_1$2.parseEventLogs)({
	        abi: events,
	        args: args,
	        logs: formattedLogs,
	        strict,
	    });
	}

	Object.defineProperty(getContractEvents$2, "__esModule", { value: true });
	getContractEvents$2.getContractEvents = getContractEvents$1;
	const getAbiItem_js_1$3 = getAbiItem$1;
	const getAction_js_1$l = getAction$1;
	const getLogs_js_1$2 = getLogs$1;
	async function getContractEvents$1(client, parameters) {
	    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict, } = parameters;
	    const event = eventName
	        ? (0, getAbiItem_js_1$3.getAbiItem)({ abi, name: eventName })
	        : undefined;
	    const events = !event
	        ? abi.filter((x) => x.type === 'event')
	        : undefined;
	    return (0, getAction_js_1$l.getAction)(client, getLogs_js_1$2.getLogs, 'getLogs')({
	        address,
	        args,
	        blockHash,
	        event,
	        events,
	        fromBlock,
	        toBlock,
	        strict,
	    });
	}

	var readContract$3 = {};

	var decodeFunctionResult$1 = {};

	Object.defineProperty(decodeFunctionResult$1, "__esModule", { value: true });
	decodeFunctionResult$1.decodeFunctionResult = decodeFunctionResult;
	const abi_js_1$9 = requireAbi();
	const decodeAbiParameters_js_1$3 = decodeAbiParameters$1;
	const getAbiItem_js_1$2 = getAbiItem$1;
	const docsPath$4 = '/docs/contract/decodeFunctionResult';
	function decodeFunctionResult(parameters) {
	    const { abi, args, functionName, data } = parameters;
	    let abiItem = abi[0];
	    if (functionName) {
	        const item = (0, getAbiItem_js_1$2.getAbiItem)({ abi, args, name: functionName });
	        if (!item)
	            throw new abi_js_1$9.AbiFunctionNotFoundError(functionName, { docsPath: docsPath$4 });
	        abiItem = item;
	    }
	    if (abiItem.type !== 'function')
	        throw new abi_js_1$9.AbiFunctionNotFoundError(undefined, { docsPath: docsPath$4 });
	    if (!abiItem.outputs)
	        throw new abi_js_1$9.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$4 });
	    const values = (0, decodeAbiParameters_js_1$3.decodeAbiParameters)(abiItem.outputs, data);
	    if (values && values.length > 1)
	        return values;
	    if (values && values.length === 1)
	        return values[0];
	    return undefined;
	}

	var call = {};

	var abis = {};

	Object.defineProperty(abis, "__esModule", { value: true });
	abis.erc4626Abi = abis.erc721Abi = abis.erc20Abi_bytes32 = abis.erc20Abi = abis.universalSignatureValidatorAbi = abis.smartAccountAbi = abis.addressResolverAbi = abis.textResolverAbi = abis.universalResolverReverseAbi = abis.universalResolverResolveAbi = abis.multicall3Abi = void 0;
	abis.multicall3Abi = [
	    {
	        inputs: [
	            {
	                components: [
	                    {
	                        name: 'target',
	                        type: 'address',
	                    },
	                    {
	                        name: 'allowFailure',
	                        type: 'bool',
	                    },
	                    {
	                        name: 'callData',
	                        type: 'bytes',
	                    },
	                ],
	                name: 'calls',
	                type: 'tuple[]',
	            },
	        ],
	        name: 'aggregate3',
	        outputs: [
	            {
	                components: [
	                    {
	                        name: 'success',
	                        type: 'bool',
	                    },
	                    {
	                        name: 'returnData',
	                        type: 'bytes',
	                    },
	                ],
	                name: 'returnData',
	                type: 'tuple[]',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	];
	const universalResolverErrors = [
	    {
	        inputs: [],
	        name: 'ResolverNotFound',
	        type: 'error',
	    },
	    {
	        inputs: [],
	        name: 'ResolverWildcardNotSupported',
	        type: 'error',
	    },
	    {
	        inputs: [],
	        name: 'ResolverNotContract',
	        type: 'error',
	    },
	    {
	        inputs: [
	            {
	                name: 'returnData',
	                type: 'bytes',
	            },
	        ],
	        name: 'ResolverError',
	        type: 'error',
	    },
	    {
	        inputs: [
	            {
	                components: [
	                    {
	                        name: 'status',
	                        type: 'uint16',
	                    },
	                    {
	                        name: 'message',
	                        type: 'string',
	                    },
	                ],
	                name: 'errors',
	                type: 'tuple[]',
	            },
	        ],
	        name: 'HttpError',
	        type: 'error',
	    },
	];
	abis.universalResolverResolveAbi = [
	    ...universalResolverErrors,
	    {
	        name: 'resolve',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [
	            { name: 'name', type: 'bytes' },
	            { name: 'data', type: 'bytes' },
	        ],
	        outputs: [
	            { name: '', type: 'bytes' },
	            { name: 'address', type: 'address' },
	        ],
	    },
	    {
	        name: 'resolve',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [
	            { name: 'name', type: 'bytes' },
	            { name: 'data', type: 'bytes' },
	            { name: 'gateways', type: 'string[]' },
	        ],
	        outputs: [
	            { name: '', type: 'bytes' },
	            { name: 'address', type: 'address' },
	        ],
	    },
	];
	abis.universalResolverReverseAbi = [
	    ...universalResolverErrors,
	    {
	        name: 'reverse',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [{ type: 'bytes', name: 'reverseName' }],
	        outputs: [
	            { type: 'string', name: 'resolvedName' },
	            { type: 'address', name: 'resolvedAddress' },
	            { type: 'address', name: 'reverseResolver' },
	            { type: 'address', name: 'resolver' },
	        ],
	    },
	    {
	        name: 'reverse',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [
	            { type: 'bytes', name: 'reverseName' },
	            { type: 'string[]', name: 'gateways' },
	        ],
	        outputs: [
	            { type: 'string', name: 'resolvedName' },
	            { type: 'address', name: 'resolvedAddress' },
	            { type: 'address', name: 'reverseResolver' },
	            { type: 'address', name: 'resolver' },
	        ],
	    },
	];
	abis.textResolverAbi = [
	    {
	        name: 'text',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [
	            { name: 'name', type: 'bytes32' },
	            { name: 'key', type: 'string' },
	        ],
	        outputs: [{ name: '', type: 'string' }],
	    },
	];
	abis.addressResolverAbi = [
	    {
	        name: 'addr',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [{ name: 'name', type: 'bytes32' }],
	        outputs: [{ name: '', type: 'address' }],
	    },
	    {
	        name: 'addr',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [
	            { name: 'name', type: 'bytes32' },
	            { name: 'coinType', type: 'uint256' },
	        ],
	        outputs: [{ name: '', type: 'bytes' }],
	    },
	];
	abis.smartAccountAbi = [
	    {
	        name: 'isValidSignature',
	        type: 'function',
	        stateMutability: 'view',
	        inputs: [
	            { name: 'hash', type: 'bytes32' },
	            { name: 'signature', type: 'bytes' },
	        ],
	        outputs: [{ name: '', type: 'bytes4' }],
	    },
	];
	abis.universalSignatureValidatorAbi = [
	    {
	        inputs: [
	            {
	                name: '_signer',
	                type: 'address',
	            },
	            {
	                name: '_hash',
	                type: 'bytes32',
	            },
	            {
	                name: '_signature',
	                type: 'bytes',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'constructor',
	    },
	];
	abis.erc20Abi = [
	    {
	        type: 'event',
	        name: 'Approval',
	        inputs: [
	            {
	                indexed: true,
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'value',
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'event',
	        name: 'Transfer',
	        inputs: [
	            {
	                indexed: true,
	                name: 'from',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'to',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'value',
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'allowance',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                name: 'spender',
	                type: 'address',
	            },
	        ],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'approve',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'balanceOf',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'account',
	                type: 'address',
	            },
	        ],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'decimals',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'uint8',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'name',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'string',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'symbol',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'string',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'totalSupply',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'transfer',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'recipient',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'transferFrom',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'sender',
	                type: 'address',
	            },
	            {
	                name: 'recipient',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	    },
	];
	abis.erc20Abi_bytes32 = [
	    {
	        type: 'event',
	        name: 'Approval',
	        inputs: [
	            {
	                indexed: true,
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'value',
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'event',
	        name: 'Transfer',
	        inputs: [
	            {
	                indexed: true,
	                name: 'from',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'to',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'value',
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'allowance',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                name: 'spender',
	                type: 'address',
	            },
	        ],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'approve',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'balanceOf',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'account',
	                type: 'address',
	            },
	        ],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'decimals',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'uint8',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'name',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'bytes32',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'symbol',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'bytes32',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'totalSupply',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'transfer',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'recipient',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'transferFrom',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'sender',
	                type: 'address',
	            },
	            {
	                name: 'recipient',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	    },
	];
	abis.erc721Abi = [
	    {
	        type: 'event',
	        name: 'Approval',
	        inputs: [
	            {
	                indexed: true,
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'event',
	        name: 'ApprovalForAll',
	        inputs: [
	            {
	                indexed: true,
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'operator',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'approved',
	                type: 'bool',
	            },
	        ],
	    },
	    {
	        type: 'event',
	        name: 'Transfer',
	        inputs: [
	            {
	                indexed: true,
	                name: 'from',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'to',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'approve',
	        stateMutability: 'payable',
	        inputs: [
	            {
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	        outputs: [],
	    },
	    {
	        type: 'function',
	        name: 'balanceOf',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'account',
	                type: 'address',
	            },
	        ],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'getApproved',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'address',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'isApprovedForAll',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                name: 'operator',
	                type: 'address',
	            },
	        ],
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'name',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'string',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'ownerOf',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'safeTransferFrom',
	        stateMutability: 'payable',
	        inputs: [
	            {
	                name: 'from',
	                type: 'address',
	            },
	            {
	                name: 'to',
	                type: 'address',
	            },
	            {
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	        outputs: [],
	    },
	    {
	        type: 'function',
	        name: 'safeTransferFrom',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'from',
	                type: 'address',
	            },
	            {
	                name: 'to',
	                type: 'address',
	            },
	            {
	                name: 'id',
	                type: 'uint256',
	            },
	            {
	                name: 'data',
	                type: 'bytes',
	            },
	        ],
	        outputs: [],
	    },
	    {
	        type: 'function',
	        name: 'setApprovalForAll',
	        stateMutability: 'nonpayable',
	        inputs: [
	            {
	                name: 'operator',
	                type: 'address',
	            },
	            {
	                name: 'approved',
	                type: 'bool',
	            },
	        ],
	        outputs: [],
	    },
	    {
	        type: 'function',
	        name: 'symbol',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'string',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'tokenByIndex',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'index',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'tokenByIndex',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                name: 'index',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'tokenURI',
	        stateMutability: 'view',
	        inputs: [
	            {
	                name: 'tokenId',
	                type: 'uint256',
	            },
	        ],
	        outputs: [
	            {
	                type: 'string',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'totalSupply',
	        stateMutability: 'view',
	        inputs: [],
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	    },
	    {
	        type: 'function',
	        name: 'transferFrom',
	        stateMutability: 'payable',
	        inputs: [
	            {
	                name: 'sender',
	                type: 'address',
	            },
	            {
	                name: 'recipient',
	                type: 'address',
	            },
	            {
	                name: 'tokeId',
	                type: 'uint256',
	            },
	        ],
	        outputs: [],
	    },
	];
	abis.erc4626Abi = [
	    {
	        anonymous: false,
	        inputs: [
	            {
	                indexed: true,
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'value',
	                type: 'uint256',
	            },
	        ],
	        name: 'Approval',
	        type: 'event',
	    },
	    {
	        anonymous: false,
	        inputs: [
	            {
	                indexed: true,
	                name: 'sender',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'receiver',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'assets',
	                type: 'uint256',
	            },
	            {
	                indexed: false,
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        name: 'Deposit',
	        type: 'event',
	    },
	    {
	        anonymous: false,
	        inputs: [
	            {
	                indexed: true,
	                name: 'from',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'to',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'value',
	                type: 'uint256',
	            },
	        ],
	        name: 'Transfer',
	        type: 'event',
	    },
	    {
	        anonymous: false,
	        inputs: [
	            {
	                indexed: true,
	                name: 'sender',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'receiver',
	                type: 'address',
	            },
	            {
	                indexed: true,
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                indexed: false,
	                name: 'assets',
	                type: 'uint256',
	            },
	            {
	                indexed: false,
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        name: 'Withdraw',
	        type: 'event',
	    },
	    {
	        inputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	            {
	                name: 'spender',
	                type: 'address',
	            },
	        ],
	        name: 'allowance',
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'spender',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        name: 'approve',
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'function',
	    },
	    {
	        inputs: [],
	        name: 'asset',
	        outputs: [
	            {
	                name: 'assetTokenAddress',
	                type: 'address',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'account',
	                type: 'address',
	            },
	        ],
	        name: 'balanceOf',
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        name: 'convertToAssets',
	        outputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        name: 'convertToShares',
	        outputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	            {
	                name: 'receiver',
	                type: 'address',
	            },
	        ],
	        name: 'deposit',
	        outputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'caller',
	                type: 'address',
	            },
	        ],
	        name: 'maxDeposit',
	        outputs: [
	            {
	                name: 'maxAssets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'caller',
	                type: 'address',
	            },
	        ],
	        name: 'maxMint',
	        outputs: [
	            {
	                name: 'maxShares',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	        ],
	        name: 'maxRedeem',
	        outputs: [
	            {
	                name: 'maxShares',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'owner',
	                type: 'address',
	            },
	        ],
	        name: 'maxWithdraw',
	        outputs: [
	            {
	                name: 'maxAssets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	            {
	                name: 'receiver',
	                type: 'address',
	            },
	        ],
	        name: 'mint',
	        outputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        name: 'previewDeposit',
	        outputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        name: 'previewMint',
	        outputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        name: 'previewRedeem',
	        outputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        name: 'previewWithdraw',
	        outputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	            {
	                name: 'receiver',
	                type: 'address',
	            },
	            {
	                name: 'owner',
	                type: 'address',
	            },
	        ],
	        name: 'redeem',
	        outputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'function',
	    },
	    {
	        inputs: [],
	        name: 'totalAssets',
	        outputs: [
	            {
	                name: 'totalManagedAssets',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [],
	        name: 'totalSupply',
	        outputs: [
	            {
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'to',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        name: 'transfer',
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'from',
	                type: 'address',
	            },
	            {
	                name: 'to',
	                type: 'address',
	            },
	            {
	                name: 'amount',
	                type: 'uint256',
	            },
	        ],
	        name: 'transferFrom',
	        outputs: [
	            {
	                type: 'bool',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'function',
	    },
	    {
	        inputs: [
	            {
	                name: 'assets',
	                type: 'uint256',
	            },
	            {
	                name: 'receiver',
	                type: 'address',
	            },
	            {
	                name: 'owner',
	                type: 'address',
	            },
	        ],
	        name: 'withdraw',
	        outputs: [
	            {
	                name: 'shares',
	                type: 'uint256',
	            },
	        ],
	        stateMutability: 'nonpayable',
	        type: 'function',
	    },
	];

	var contract$1 = {};

	Object.defineProperty(contract$1, "__esModule", { value: true });
	contract$1.aggregate3Signature = void 0;
	contract$1.aggregate3Signature = '0x82ad56cb';

	var contracts = {};

	Object.defineProperty(contracts, "__esModule", { value: true });
	contracts.universalSignatureValidatorByteCode = contracts.deploylessCallViaFactoryBytecode = contracts.deploylessCallViaBytecodeBytecode = void 0;
	contracts.deploylessCallViaBytecodeBytecode = '0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe';
	contracts.deploylessCallViaFactoryBytecode = '0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe';
	contracts.universalSignatureValidatorByteCode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';

	var chain = {};

	Object.defineProperty(chain, "__esModule", { value: true });
	chain.InvalidChainIdError = chain.ClientChainNotConfiguredError = chain.ChainNotFoundError = chain.ChainMismatchError = chain.ChainDoesNotSupportContract = void 0;
	const base_js_1$c = base$1;
	class ChainDoesNotSupportContract extends base_js_1$c.BaseError {
	    constructor({ blockNumber, chain, contract, }) {
	        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
	            metaMessages: [
	                'This could be due to any of the following:',
	                ...(blockNumber &&
	                    contract.blockCreated &&
	                    contract.blockCreated > blockNumber
	                    ? [
	                        `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,
	                    ]
	                    : [
	                        `- The chain does not have the contract "${contract.name}" configured.`,
	                    ]),
	            ],
	            name: 'ChainDoesNotSupportContract',
	        });
	    }
	}
	chain.ChainDoesNotSupportContract = ChainDoesNotSupportContract;
	class ChainMismatchError extends base_js_1$c.BaseError {
	    constructor({ chain, currentChainId, }) {
	        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {
	            metaMessages: [
	                `Current Chain ID:  ${currentChainId}`,
	                `Expected Chain ID: ${chain.id} – ${chain.name}`,
	            ],
	            name: 'ChainMismatchError',
	        });
	    }
	}
	chain.ChainMismatchError = ChainMismatchError;
	class ChainNotFoundError extends base_js_1$c.BaseError {
	    constructor() {
	        super([
	            'No chain was provided to the request.',
	            'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',
	        ].join('\n'), {
	            name: 'ChainNotFoundError',
	        });
	    }
	}
	chain.ChainNotFoundError = ChainNotFoundError;
	class ClientChainNotConfiguredError extends base_js_1$c.BaseError {
	    constructor() {
	        super('No chain was provided to the Client.', {
	            name: 'ClientChainNotConfiguredError',
	        });
	    }
	}
	chain.ClientChainNotConfiguredError = ClientChainNotConfiguredError;
	class InvalidChainIdError extends base_js_1$c.BaseError {
	    constructor({ chainId }) {
	        super(typeof chainId === 'number'
	            ? `Chain ID "${chainId}" is invalid.`
	            : 'Chain ID is invalid.', { name: 'InvalidChainIdError' });
	    }
	}
	chain.InvalidChainIdError = InvalidChainIdError;

	var encodeDeployData$1 = {};

	Object.defineProperty(encodeDeployData$1, "__esModule", { value: true });
	encodeDeployData$1.encodeDeployData = encodeDeployData;
	const abi_js_1$8 = requireAbi();
	const concat_js_1$6 = concat$1;
	const encodeAbiParameters_js_1$6 = encodeAbiParameters$3;
	const docsPath$3 = '/docs/contract/encodeDeployData';
	function encodeDeployData(parameters) {
	    const { abi, args, bytecode } = parameters;
	    if (!args || args.length === 0)
	        return bytecode;
	    const description = abi.find((x) => 'type' in x && x.type === 'constructor');
	    if (!description)
	        throw new abi_js_1$8.AbiConstructorNotFoundError({ docsPath: docsPath$3 });
	    if (!('inputs' in description))
	        throw new abi_js_1$8.AbiConstructorParamsNotFoundError({ docsPath: docsPath$3 });
	    if (!description.inputs || description.inputs.length === 0)
	        throw new abi_js_1$8.AbiConstructorParamsNotFoundError({ docsPath: docsPath$3 });
	    const data = (0, encodeAbiParameters_js_1$6.encodeAbiParameters)(description.inputs, args);
	    return (0, concat_js_1$6.concatHex)([bytecode, data]);
	}

	var getChainContractAddress$1 = {};

	Object.defineProperty(getChainContractAddress$1, "__esModule", { value: true });
	getChainContractAddress$1.getChainContractAddress = getChainContractAddress;
	const chain_js_1$2 = chain;
	function getChainContractAddress({ blockNumber, chain, contract: name, }) {
	    const contract = chain?.contracts?.[name];
	    if (!contract)
	        throw new chain_js_1$2.ChainDoesNotSupportContract({
	            chain,
	            contract: { name },
	        });
	    if (blockNumber &&
	        contract.blockCreated &&
	        contract.blockCreated > blockNumber)
	        throw new chain_js_1$2.ChainDoesNotSupportContract({
	            blockNumber,
	            chain,
	            contract: {
	                name,
	                blockCreated: contract.blockCreated,
	            },
	        });
	    return contract.address;
	}

	var getCallError$1 = {};

	Object.defineProperty(getCallError$1, "__esModule", { value: true });
	getCallError$1.getCallError = getCallError;
	const contract_js_1$6 = contract$2;
	const node_js_1$2 = node;
	const getNodeError_js_1$1 = getNodeError$1;
	function getCallError(err, { docsPath, ...args }) {
	    const cause = (() => {
	        const cause = (0, getNodeError_js_1$1.getNodeError)(err, args);
	        if (cause instanceof node_js_1$2.UnknownNodeError)
	            return err;
	        return cause;
	    })();
	    return new contract_js_1$6.CallExecutionError(cause, {
	        docsPath,
	        ...args,
	    });
	}

	var createBatchScheduler$1 = {};

	Object.defineProperty(createBatchScheduler$1, "__esModule", { value: true });
	createBatchScheduler$1.createBatchScheduler = createBatchScheduler;
	const schedulerCache = new Map();
	function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort, }) {
	    const exec = async () => {
	        const scheduler = getScheduler();
	        flush();
	        const args = scheduler.map(({ args }) => args);
	        if (args.length === 0)
	            return;
	        fn(args)
	            .then((data) => {
	            if (sort && Array.isArray(data))
	                data.sort(sort);
	            for (let i = 0; i < scheduler.length; i++) {
	                const { pendingPromise } = scheduler[i];
	                pendingPromise.resolve?.([data[i], data]);
	            }
	        })
	            .catch((err) => {
	            for (let i = 0; i < scheduler.length; i++) {
	                const { pendingPromise } = scheduler[i];
	                pendingPromise.reject?.(err);
	            }
	        });
	    };
	    const flush = () => schedulerCache.delete(id);
	    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
	    const getScheduler = () => schedulerCache.get(id) || [];
	    const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
	    return {
	        flush,
	        async schedule(args) {
	            const pendingPromise = {};
	            const promise = new Promise((resolve, reject) => {
	                pendingPromise.resolve = resolve;
	                pendingPromise.reject = reject;
	            });
	            const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
	            if (split)
	                exec();
	            const hasActiveScheduler = getScheduler().length > 0;
	            if (hasActiveScheduler) {
	                setScheduler({ args, pendingPromise });
	                return promise;
	            }
	            setScheduler({ args, pendingPromise });
	            setTimeout(exec, wait);
	            return promise;
	        },
	    };
	}

	var ccip$1 = {};

	var ccip = {};

	Object.defineProperty(ccip, "__esModule", { value: true });
	ccip.OffchainLookupSenderMismatchError = ccip.OffchainLookupResponseMalformedError = ccip.OffchainLookupError = void 0;
	const stringify_js_1$8 = stringify$1;
	const base_js_1$b = base$1;
	const utils_js_1$e = utils$5;
	class OffchainLookupError extends base_js_1$b.BaseError {
	    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {
	        super(cause.shortMessage ||
	            'An error occurred while fetching for an offchain result.', {
	            cause,
	            metaMessages: [
	                ...(cause.metaMessages || []),
	                cause.metaMessages?.length ? '' : [],
	                'Offchain Gateway Call:',
	                urls && [
	                    '  Gateway URL(s):',
	                    ...urls.map((url) => `    ${(0, utils_js_1$e.getUrl)(url)}`),
	                ],
	                `  Sender: ${sender}`,
	                `  Data: ${data}`,
	                `  Callback selector: ${callbackSelector}`,
	                `  Extra data: ${extraData}`,
	            ].flat(),
	            name: 'OffchainLookupError',
	        });
	    }
	}
	ccip.OffchainLookupError = OffchainLookupError;
	class OffchainLookupResponseMalformedError extends base_js_1$b.BaseError {
	    constructor({ result, url }) {
	        super('Offchain gateway response is malformed. Response data must be a hex value.', {
	            metaMessages: [
	                `Gateway URL: ${(0, utils_js_1$e.getUrl)(url)}`,
	                `Response: ${(0, stringify_js_1$8.stringify)(result)}`,
	            ],
	            name: 'OffchainLookupResponseMalformedError',
	        });
	    }
	}
	ccip.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError;
	class OffchainLookupSenderMismatchError extends base_js_1$b.BaseError {
	    constructor({ sender, to }) {
	        super('Reverted sender address does not match target contract address (`to`).', {
	            metaMessages: [
	                `Contract address: ${to}`,
	                `OffchainLookup sender address: ${sender}`,
	            ],
	            name: 'OffchainLookupSenderMismatchError',
	        });
	    }
	}
	ccip.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError;

	var hasRequiredCcip;

	function requireCcip () {
		if (hasRequiredCcip) return ccip$1;
		hasRequiredCcip = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;
			exports.offchainLookup = offchainLookup;
			exports.ccipRequest = ccipRequest;
			const call_js_1 = requireCall();
			const ccip_js_1 = ccip;
			const request_js_1 = request;
			const decodeErrorResult_js_1 = decodeErrorResult$1;
			const encodeAbiParameters_js_1 = encodeAbiParameters$3;
			const isAddressEqual_js_1 = isAddressEqual$1;
			const concat_js_1 = concat$1;
			const isHex_js_1 = isHex$1;
			const stringify_js_1 = stringify$1;
			exports.offchainLookupSignature = '0x556f1830';
			exports.offchainLookupAbiItem = {
			    name: 'OffchainLookup',
			    type: 'error',
			    inputs: [
			        {
			            name: 'sender',
			            type: 'address',
			        },
			        {
			            name: 'urls',
			            type: 'string[]',
			        },
			        {
			            name: 'callData',
			            type: 'bytes',
			        },
			        {
			            name: 'callbackFunction',
			            type: 'bytes4',
			        },
			        {
			            name: 'extraData',
			            type: 'bytes',
			        },
			    ],
			};
			async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {
			    const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
			        data,
			        abi: [exports.offchainLookupAbiItem],
			    });
			    const [sender, urls, callData, callbackSelector, extraData] = args;
			    const { ccipRead } = client;
			    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'
			        ? ccipRead.request
			        : ccipRequest;
			    try {
			        if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
			            throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
			        const result = await ccipRequest_({ data: callData, sender, urls });
			        const { data: data_ } = await (0, call_js_1.call)(client, {
			            blockNumber,
			            blockTag,
			            data: (0, concat_js_1.concat)([
			                callbackSelector,
			                (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),
			            ]),
			            to,
			        });
			        return data_;
			    }
			    catch (err) {
			        throw new ccip_js_1.OffchainLookupError({
			            callbackSelector,
			            cause: err,
			            data,
			            extraData,
			            sender,
			            urls,
			        });
			    }
			}
			async function ccipRequest({ data, sender, urls, }) {
			    let error = new Error('An unknown error occurred.');
			    for (let i = 0; i < urls.length; i++) {
			        const url = urls[i];
			        const method = url.includes('{data}') ? 'GET' : 'POST';
			        const body = method === 'POST' ? { data, sender } : undefined;
			        try {
			            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {
			                body: JSON.stringify(body),
			                method,
			            });
			            let result;
			            if (response.headers.get('Content-Type')?.startsWith('application/json')) {
			                result = (await response.json()).data;
			            }
			            else {
			                result = (await response.text());
			            }
			            if (!response.ok) {
			                error = new request_js_1.HttpRequestError({
			                    body,
			                    details: result?.error
			                        ? (0, stringify_js_1.stringify)(result.error)
			                        : response.statusText,
			                    headers: response.headers,
			                    status: response.status,
			                    url,
			                });
			                continue;
			            }
			            if (!(0, isHex_js_1.isHex)(result)) {
			                error = new ccip_js_1.OffchainLookupResponseMalformedError({
			                    result,
			                    url,
			                });
			                continue;
			            }
			            return result;
			        }
			        catch (err) {
			            error = new request_js_1.HttpRequestError({
			                body,
			                details: err.message,
			                url,
			            });
			        }
			    }
			    throw error;
			}
			
		} (ccip$1));
		return ccip$1;
	}

	var hasRequiredCall;

	function requireCall () {
		if (hasRequiredCall) return call;
		hasRequiredCall = 1;
		Object.defineProperty(call, "__esModule", { value: true });
		call.call = call$1;
		call.getRevertErrorData = getRevertErrorData;
		const abitype_1 = exports$1;
		const parseAccount_js_1 = parseAccount$1;
		const abis_js_1 = abis;
		const contract_js_1 = contract$1;
		const contracts_js_1 = contracts;
		const base_js_1 = base$1;
		const chain_js_1 = chain;
		const contract_js_2 = contract$2;
		const decodeFunctionResult_js_1 = decodeFunctionResult$1;
		const encodeDeployData_js_1 = encodeDeployData$1;
		const encodeFunctionData_js_1 = encodeFunctionData$1;
		const getChainContractAddress_js_1 = getChainContractAddress$1;
		const toHex_js_1 = requireToHex();
		const getCallError_js_1 = getCallError$1;
		const extract_js_1 = extract$1;
		const transactionRequest_js_1 = transactionRequest;
		const createBatchScheduler_js_1 = createBatchScheduler$1;
		const stateOverride_js_1 = stateOverride;
		const assertRequest_js_1 = assertRequest$1;
		async function call$1(client, args) {
		    const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = 'latest', accessList, blobs, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
		    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
		    if (code && (factory || factoryData))
		        throw new base_js_1.BaseError('Cannot provide both `code` & `factory`/`factoryData` as parameters.');
		    if (code && to)
		        throw new base_js_1.BaseError('Cannot provide both `code` & `to` as parameters.');
		    const deploylessCallViaBytecode = code && data_;
		    const deploylessCallViaFactory = factory && factoryData && to && data_;
		    const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
		    const data = (() => {
		        if (deploylessCallViaBytecode)
		            return toDeploylessCallViaBytecodeData({
		                code,
		                data: data_,
		            });
		        if (deploylessCallViaFactory)
		            return toDeploylessCallViaFactoryData({
		                data: data_,
		                factory,
		                factoryData,
		                to,
		            });
		        return data_;
		    })();
		    try {
		        (0, assertRequest_js_1.assertRequest)(args);
		        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
		        const block = blockNumberHex || blockTag;
		        const rpcStateOverride = (0, stateOverride_js_1.serializeStateOverride)(stateOverride);
		        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
		        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
		        const request = format({
		            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
		            from: account?.address,
		            accessList,
		            blobs,
		            data,
		            gas,
		            gasPrice,
		            maxFeePerBlobGas,
		            maxFeePerGas,
		            maxPriorityFeePerGas,
		            nonce,
		            to: deploylessCall ? undefined : to,
		            value,
		        });
		        if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {
		            try {
		                return await scheduleMulticall(client, {
		                    ...request,
		                    blockNumber,
		                    blockTag,
		                });
		            }
		            catch (err) {
		                if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) &&
		                    !(err instanceof chain_js_1.ChainDoesNotSupportContract))
		                    throw err;
		            }
		        }
		        const response = await client.request({
		            method: 'eth_call',
		            params: rpcStateOverride
		                ? [
		                    request,
		                    block,
		                    rpcStateOverride,
		                ]
		                : [request, block],
		        });
		        if (response === '0x')
		            return { data: undefined };
		        return { data: response };
		    }
		    catch (err) {
		        const data = getRevertErrorData(err);
		        const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(() => requireCcip());
		        if (client.ccipRead !== false &&
		            data?.slice(0, 10) === offchainLookupSignature &&
		            to)
		            return { data: await offchainLookup(client, { data, to }) };
		        if (deploylessCall && data?.slice(0, 10) === '0x101bb98d')
		            throw new contract_js_2.CounterfactualDeploymentFailedError({ factory });
		        throw (0, getCallError_js_1.getCallError)(err, {
		            ...args,
		            account,
		            chain: client.chain,
		        });
		    }
		}
		function shouldPerformMulticall({ request }) {
		    const { data, to, ...request_ } = request;
		    if (!data)
		        return false;
		    if (data.startsWith(contract_js_1.aggregate3Signature))
		        return false;
		    if (!to)
		        return false;
		    if (Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0)
		        return false;
		    return true;
		}
		async function scheduleMulticall(client, args) {
		    const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};
		    const { blockNumber, blockTag = 'latest', data, multicallAddress: multicallAddress_, to, } = args;
		    let multicallAddress = multicallAddress_;
		    if (!multicallAddress) {
		        if (!client.chain)
		            throw new chain_js_1.ClientChainNotConfiguredError();
		        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
		            blockNumber,
		            chain: client.chain,
		            contract: 'multicall3',
		        });
		    }
		    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
		    const block = blockNumberHex || blockTag;
		    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
		        id: `${client.uid}.${block}`,
		        wait,
		        shouldSplitBatch(args) {
		            const size = args.reduce((size, { data }) => size + (data.length - 2), 0);
		            return size > batchSize * 2;
		        },
		        fn: async (requests) => {
		            const calls = requests.map((request) => ({
		                allowFailure: true,
		                callData: request.data,
		                target: request.to,
		            }));
		            const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
		                abi: abis_js_1.multicall3Abi,
		                args: [calls],
		                functionName: 'aggregate3',
		            });
		            const data = await client.request({
		                method: 'eth_call',
		                params: [
		                    {
		                        data: calldata,
		                        to: multicallAddress,
		                    },
		                    block,
		                ],
		            });
		            return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
		                abi: abis_js_1.multicall3Abi,
		                args: [calls],
		                functionName: 'aggregate3',
		                data: data || '0x',
		            });
		        },
		    });
		    const [{ returnData, success }] = await schedule({ data, to });
		    if (!success)
		        throw new contract_js_2.RawContractError({ data: returnData });
		    if (returnData === '0x')
		        return { data: undefined };
		    return { data: returnData };
		}
		function toDeploylessCallViaBytecodeData(parameters) {
		    const { code, data } = parameters;
		    return (0, encodeDeployData_js_1.encodeDeployData)({
		        abi: (0, abitype_1.parseAbi)(['constructor(bytes, bytes)']),
		        bytecode: contracts_js_1.deploylessCallViaBytecodeBytecode,
		        args: [code, data],
		    });
		}
		function toDeploylessCallViaFactoryData(parameters) {
		    const { data, factory, factoryData, to } = parameters;
		    return (0, encodeDeployData_js_1.encodeDeployData)({
		        abi: (0, abitype_1.parseAbi)(['constructor(address, bytes, address, bytes)']),
		        bytecode: contracts_js_1.deploylessCallViaFactoryBytecode,
		        args: [to, data, factory, factoryData],
		    });
		}
		function getRevertErrorData(err) {
		    if (!(err instanceof base_js_1.BaseError))
		        return undefined;
		    const error = err.walk();
		    return typeof error?.data === 'object' ? error.data?.data : error.data;
		}
		
		return call;
	}

	Object.defineProperty(readContract$3, "__esModule", { value: true });
	readContract$3.readContract = readContract$2;
	const decodeFunctionResult_js_1$4 = decodeFunctionResult$1;
	const encodeFunctionData_js_1$5 = encodeFunctionData$1;
	const getContractError_js_1$3 = getContractError$1;
	const getAction_js_1$k = getAction$1;
	const call_js_1$3 = requireCall();
	async function readContract$2(client, parameters) {
	    const { abi, address, args, functionName, ...rest } = parameters;
	    const calldata = (0, encodeFunctionData_js_1$5.encodeFunctionData)({
	        abi,
	        args,
	        functionName,
	    });
	    try {
	        const { data } = await (0, getAction_js_1$k.getAction)(client, call_js_1$3.call, 'call')({
	            ...rest,
	            data: calldata,
	            to: address,
	        });
	        return (0, decodeFunctionResult_js_1$4.decodeFunctionResult)({
	            abi,
	            args,
	            functionName,
	            data: data || '0x',
	        });
	    }
	    catch (error) {
	        throw (0, getContractError_js_1$3.getContractError)(error, {
	            abi,
	            address,
	            args,
	            docsPath: '/docs/contract/readContract',
	            functionName,
	        });
	    }
	}

	var simulateContract$1 = {};

	Object.defineProperty(simulateContract$1, "__esModule", { value: true });
	simulateContract$1.simulateContract = simulateContract;
	const parseAccount_js_1$6 = parseAccount$1;
	const decodeFunctionResult_js_1$3 = decodeFunctionResult$1;
	const encodeFunctionData_js_1$4 = encodeFunctionData$1;
	const getContractError_js_1$2 = getContractError$1;
	const getAction_js_1$j = getAction$1;
	const call_js_1$2 = requireCall();
	async function simulateContract(client, parameters) {
	    const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
	    const account = callRequest.account
	        ? (0, parseAccount_js_1$6.parseAccount)(callRequest.account)
	        : client.account;
	    const calldata = (0, encodeFunctionData_js_1$4.encodeFunctionData)({ abi, args, functionName });
	    try {
	        const { data } = await (0, getAction_js_1$j.getAction)(client, call_js_1$2.call, 'call')({
	            batch: false,
	            data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
	            to: address,
	            ...callRequest,
	            account,
	        });
	        const result = (0, decodeFunctionResult_js_1$3.decodeFunctionResult)({
	            abi,
	            args,
	            functionName,
	            data: data || '0x',
	        });
	        const minimizedAbi = abi.filter((abiItem) => 'name' in abiItem && abiItem.name === parameters.functionName);
	        return {
	            result,
	            request: {
	                abi: minimizedAbi,
	                address,
	                args,
	                dataSuffix,
	                functionName,
	                ...callRequest,
	                account,
	            },
	        };
	    }
	    catch (error) {
	        throw (0, getContractError_js_1$2.getContractError)(error, {
	            abi,
	            address,
	            args,
	            docsPath: '/docs/contract/simulateContract',
	            functionName,
	            sender: account?.address,
	        });
	    }
	}

	var watchContractEvent$1 = {};

	var observe = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.cleanupCache = exports.listenersCache = void 0;
		exports.observe = observe;
		exports.listenersCache = new Map();
		exports.cleanupCache = new Map();
		let callbackCount = 0;
		function observe(observerId, callbacks, fn) {
		    const callbackId = ++callbackCount;
		    const getListeners = () => exports.listenersCache.get(observerId) || [];
		    const unsubscribe = () => {
		        const listeners = getListeners();
		        exports.listenersCache.set(observerId, listeners.filter((cb) => cb.id !== callbackId));
		    };
		    const unwatch = () => {
		        const cleanup = exports.cleanupCache.get(observerId);
		        if (getListeners().length === 1 && cleanup)
		            cleanup();
		        unsubscribe();
		    };
		    const listeners = getListeners();
		    exports.listenersCache.set(observerId, [
		        ...listeners,
		        { id: callbackId, fns: callbacks },
		    ]);
		    if (listeners && listeners.length > 0)
		        return unwatch;
		    const emit = {};
		    for (const key in callbacks) {
		        emit[key] = ((...args) => {
		            const listeners = getListeners();
		            if (listeners.length === 0)
		                return;
		            for (const listener of listeners)
		                listener.fns[key]?.(...args);
		        });
		    }
		    const cleanup = fn(emit);
		    if (typeof cleanup === 'function')
		        exports.cleanupCache.set(observerId, cleanup);
		    return unwatch;
		}
		
	} (observe));

	var poll$1 = {};

	var wait$1 = {};

	Object.defineProperty(wait$1, "__esModule", { value: true });
	wait$1.wait = wait;
	async function wait(time) {
	    return new Promise((res) => setTimeout(res, time));
	}

	Object.defineProperty(poll$1, "__esModule", { value: true });
	poll$1.poll = poll;
	const wait_js_1$2 = wait$1;
	function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
	    let active = true;
	    const unwatch = () => (active = false);
	    const watch = async () => {
	        let data = undefined;
	        if (emitOnBegin)
	            data = await fn({ unpoll: unwatch });
	        const initialWait = (await initialWaitTime?.(data)) ?? interval;
	        await (0, wait_js_1$2.wait)(initialWait);
	        const poll = async () => {
	            if (!active)
	                return;
	            await fn({ unpoll: unwatch });
	            await (0, wait_js_1$2.wait)(interval);
	            poll();
	        };
	        poll();
	    };
	    watch();
	    return unwatch;
	}

	var getBlockNumber$1 = {};

	var withCache = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.responseCache = exports.promiseCache = void 0;
		exports.getCache = getCache;
		exports.withCache = withCache;
		exports.promiseCache = new Map();
		exports.responseCache = new Map();
		function getCache(cacheKey) {
		    const buildCache = (cacheKey, cache) => ({
		        clear: () => cache.delete(cacheKey),
		        get: () => cache.get(cacheKey),
		        set: (data) => cache.set(cacheKey, data),
		    });
		    const promise = buildCache(cacheKey, exports.promiseCache);
		    const response = buildCache(cacheKey, exports.responseCache);
		    return {
		        clear: () => {
		            promise.clear();
		            response.clear();
		        },
		        promise,
		        response,
		    };
		}
		async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
		    const cache = getCache(cacheKey);
		    const response = cache.response.get();
		    if (response && cacheTime > 0) {
		        const age = new Date().getTime() - response.created.getTime();
		        if (age < cacheTime)
		            return response.data;
		    }
		    let promise = cache.promise.get();
		    if (!promise) {
		        promise = fn();
		        cache.promise.set(promise);
		    }
		    try {
		        const data = await promise;
		        cache.response.set({ created: new Date(), data });
		        return data;
		    }
		    finally {
		        cache.promise.clear();
		    }
		}
		
	} (withCache));

	Object.defineProperty(getBlockNumber$1, "__esModule", { value: true });
	getBlockNumber$1.getBlockNumberCache = getBlockNumberCache;
	getBlockNumber$1.getBlockNumber = getBlockNumber;
	const withCache_js_1 = withCache;
	const cacheKey = (id) => `blockNumber.${id}`;
	function getBlockNumberCache(id) {
	    return (0, withCache_js_1.getCache)(cacheKey(id));
	}
	async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
	    const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
	        method: 'eth_blockNumber',
	    }), { cacheKey: cacheKey(client.uid), cacheTime });
	    return BigInt(blockNumberHex);
	}

	var getFilterChanges$1 = {};

	Object.defineProperty(getFilterChanges$1, "__esModule", { value: true });
	getFilterChanges$1.getFilterChanges = getFilterChanges;
	const parseEventLogs_js_1$1 = parseEventLogs$2;
	const log_js_1$3 = log;
	async function getFilterChanges(_client, { filter, }) {
	    const strict = 'strict' in filter && filter.strict;
	    const logs = await filter.request({
	        method: 'eth_getFilterChanges',
	        params: [filter.id],
	    });
	    if (typeof logs[0] === 'string')
	        return logs;
	    const formattedLogs = logs.map((log) => (0, log_js_1$3.formatLog)(log));
	    if (!('abi' in filter) || !filter.abi)
	        return formattedLogs;
	    return (0, parseEventLogs_js_1$1.parseEventLogs)({
	        abi: filter.abi,
	        logs: formattedLogs,
	        strict,
	    });
	}

	var uninstallFilter$1 = {};

	Object.defineProperty(uninstallFilter$1, "__esModule", { value: true });
	uninstallFilter$1.uninstallFilter = uninstallFilter;
	async function uninstallFilter(_client, { filter }) {
	    return filter.request({
	        method: 'eth_uninstallFilter',
	        params: [filter.id],
	    });
	}

	Object.defineProperty(watchContractEvent$1, "__esModule", { value: true });
	watchContractEvent$1.watchContractEvent = watchContractEvent;
	const abi_js_1$7 = requireAbi();
	const rpc_js_1$b = rpc;
	const decodeEventLog_js_1$1 = decodeEventLog$1;
	const encodeEventTopics_js_1$2 = encodeEventTopics$1;
	const log_js_1$2 = log;
	const getAction_js_1$i = getAction$1;
	const observe_js_1$5 = observe;
	const poll_js_1$4 = poll$1;
	const stringify_js_1$7 = stringify$1;
	const createContractEventFilter_js_1$2 = createContractEventFilter$1;
	const getBlockNumber_js_1$4 = getBlockNumber$1;
	const getContractEvents_js_1$2 = getContractEvents$2;
	const getFilterChanges_js_1$3 = getFilterChanges$1;
	const uninstallFilter_js_1$3 = uninstallFilter$1;
	function watchContractEvent(client, parameters) {
	    const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, } = parameters;
	    const enablePolling = (() => {
	        if (typeof poll_ !== 'undefined')
	            return poll_;
	        if (typeof fromBlock === 'bigint')
	            return true;
	        if (client.transport.type === 'webSocket')
	            return false;
	        if (client.transport.type === 'fallback' &&
	            client.transport.transports[0].config.type === 'webSocket')
	            return false;
	        return true;
	    })();
	    const pollContractEvent = () => {
	        const strict = strict_ ?? false;
	        const observerId = (0, stringify_js_1$7.stringify)([
	            'watchContractEvent',
	            address,
	            args,
	            batch,
	            client.uid,
	            eventName,
	            pollingInterval,
	            strict,
	            fromBlock,
	        ]);
	        return (0, observe_js_1$5.observe)(observerId, { onLogs, onError }, (emit) => {
	            let previousBlockNumber;
	            if (fromBlock !== undefined)
	                previousBlockNumber = fromBlock - 1n;
	            let filter;
	            let initialized = false;
	            const unwatch = (0, poll_js_1$4.poll)(async () => {
	                if (!initialized) {
	                    try {
	                        filter = (await (0, getAction_js_1$i.getAction)(client, createContractEventFilter_js_1$2.createContractEventFilter, 'createContractEventFilter')({
	                            abi,
	                            address,
	                            args: args,
	                            eventName: eventName,
	                            strict: strict,
	                            fromBlock,
	                        }));
	                    }
	                    catch { }
	                    initialized = true;
	                    return;
	                }
	                try {
	                    let logs;
	                    if (filter) {
	                        logs = await (0, getAction_js_1$i.getAction)(client, getFilterChanges_js_1$3.getFilterChanges, 'getFilterChanges')({ filter });
	                    }
	                    else {
	                        const blockNumber = await (0, getAction_js_1$i.getAction)(client, getBlockNumber_js_1$4.getBlockNumber, 'getBlockNumber')({});
	                        if (previousBlockNumber && previousBlockNumber < blockNumber) {
	                            logs = await (0, getAction_js_1$i.getAction)(client, getContractEvents_js_1$2.getContractEvents, 'getContractEvents')({
	                                abi,
	                                address,
	                                args,
	                                eventName,
	                                fromBlock: previousBlockNumber + 1n,
	                                toBlock: blockNumber,
	                                strict,
	                            });
	                        }
	                        else {
	                            logs = [];
	                        }
	                        previousBlockNumber = blockNumber;
	                    }
	                    if (logs.length === 0)
	                        return;
	                    if (batch)
	                        emit.onLogs(logs);
	                    else
	                        for (const log of logs)
	                            emit.onLogs([log]);
	                }
	                catch (err) {
	                    if (filter && err instanceof rpc_js_1$b.InvalidInputRpcError)
	                        initialized = false;
	                    emit.onError?.(err);
	                }
	            }, {
	                emitOnBegin: true,
	                interval: pollingInterval,
	            });
	            return async () => {
	                if (filter)
	                    await (0, getAction_js_1$i.getAction)(client, uninstallFilter_js_1$3.uninstallFilter, 'uninstallFilter')({ filter });
	                unwatch();
	            };
	        });
	    };
	    const subscribeContractEvent = () => {
	        const strict = strict_ ?? false;
	        const observerId = (0, stringify_js_1$7.stringify)([
	            'watchContractEvent',
	            address,
	            args,
	            batch,
	            client.uid,
	            eventName,
	            pollingInterval,
	            strict,
	        ]);
	        let active = true;
	        let unsubscribe = () => (active = false);
	        return (0, observe_js_1$5.observe)(observerId, { onLogs, onError }, (emit) => {
	            (async () => {
	                try {
	                    const transport = (() => {
	                        if (client.transport.type === 'fallback') {
	                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');
	                            if (!transport)
	                                return client.transport;
	                            return transport.value;
	                        }
	                        return client.transport;
	                    })();
	                    const topics = eventName
	                        ? (0, encodeEventTopics_js_1$2.encodeEventTopics)({
	                            abi: abi,
	                            eventName: eventName,
	                            args,
	                        })
	                        : [];
	                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
	                        params: ['logs', { address, topics }],
	                        onData(data) {
	                            if (!active)
	                                return;
	                            const log = data.result;
	                            try {
	                                const { eventName, args } = (0, decodeEventLog_js_1$1.decodeEventLog)({
	                                    abi: abi,
	                                    data: log.data,
	                                    topics: log.topics,
	                                    strict: strict_,
	                                });
	                                const formatted = (0, log_js_1$2.formatLog)(log, {
	                                    args,
	                                    eventName: eventName,
	                                });
	                                emit.onLogs([formatted]);
	                            }
	                            catch (err) {
	                                let eventName;
	                                let isUnnamed;
	                                if (err instanceof abi_js_1$7.DecodeLogDataMismatch ||
	                                    err instanceof abi_js_1$7.DecodeLogTopicsMismatch) {
	                                    if (strict_)
	                                        return;
	                                    eventName = err.abiItem.name;
	                                    isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
	                                }
	                                const formatted = (0, log_js_1$2.formatLog)(log, {
	                                    args: isUnnamed ? [] : {},
	                                    eventName,
	                                });
	                                emit.onLogs([formatted]);
	                            }
	                        },
	                        onError(error) {
	                            emit.onError?.(error);
	                        },
	                    });
	                    unsubscribe = unsubscribe_;
	                    if (!active)
	                        unsubscribe();
	                }
	                catch (err) {
	                    onError?.(err);
	                }
	            })();
	            return () => unsubscribe();
	        });
	    };
	    return enablePolling ? pollContractEvent() : subscribeContractEvent();
	}

	var writeContract$1 = {};

	var account = {};

	Object.defineProperty(account, "__esModule", { value: true });
	account.AccountTypeNotSupportedError = account.AccountNotFoundError = void 0;
	const base_js_1$a = base$1;
	class AccountNotFoundError extends base_js_1$a.BaseError {
	    constructor({ docsPath } = {}) {
	        super([
	            'Could not find an Account to execute with this Action.',
	            'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',
	        ].join('\n'), {
	            docsPath,
	            docsSlug: 'account',
	            name: 'AccountNotFoundError',
	        });
	    }
	}
	account.AccountNotFoundError = AccountNotFoundError;
	class AccountTypeNotSupportedError extends base_js_1$a.BaseError {
	    constructor({ docsPath, metaMessages, type, }) {
	        super(`Account type "${type}" is not supported.`, {
	            docsPath,
	            metaMessages,
	            name: 'AccountTypeNotSupportedError',
	        });
	    }
	}
	account.AccountTypeNotSupportedError = AccountTypeNotSupportedError;

	var sendTransaction$3 = {};

	var assertCurrentChain$1 = {};

	Object.defineProperty(assertCurrentChain$1, "__esModule", { value: true });
	assertCurrentChain$1.assertCurrentChain = assertCurrentChain;
	const chain_js_1$1 = chain;
	function assertCurrentChain({ chain, currentChainId, }) {
	    if (!chain)
	        throw new chain_js_1$1.ChainNotFoundError();
	    if (currentChainId !== chain.id)
	        throw new chain_js_1$1.ChainMismatchError({ chain, currentChainId });
	}

	var getTransactionError$1 = {};

	Object.defineProperty(getTransactionError$1, "__esModule", { value: true });
	getTransactionError$1.getTransactionError = getTransactionError;
	const node_js_1$1 = node;
	const transaction_js_1$6 = transaction$1;
	const getNodeError_js_1 = getNodeError$1;
	function getTransactionError(err, { docsPath, ...args }) {
	    const cause = (() => {
	        const cause = (0, getNodeError_js_1.getNodeError)(err, args);
	        if (cause instanceof node_js_1$1.UnknownNodeError)
	            return err;
	        return cause;
	    })();
	    return new transaction_js_1$6.TransactionExecutionError(cause, {
	        docsPath,
	        ...args,
	    });
	}

	var sendRawTransaction$1 = {};

	Object.defineProperty(sendRawTransaction$1, "__esModule", { value: true });
	sendRawTransaction$1.sendRawTransaction = sendRawTransaction;
	async function sendRawTransaction(client, { serializedTransaction }) {
	    return client.request({
	        method: 'eth_sendRawTransaction',
	        params: [serializedTransaction],
	    }, { retryCount: 0 });
	}

	Object.defineProperty(sendTransaction$3, "__esModule", { value: true });
	sendTransaction$3.sendTransaction = sendTransaction$2;
	const parseAccount_js_1$5 = parseAccount$1;
	const account_js_1$4 = account;
	const base_js_1$9 = base$1;
	const recoverAuthorizationAddress_js_1 = recoverAuthorizationAddress$1;
	const assertCurrentChain_js_1$1 = assertCurrentChain$1;
	const getTransactionError_js_1 = getTransactionError$1;
	const extract_js_1$1 = extract$1;
	const transactionRequest_js_1$2 = transactionRequest;
	const getAction_js_1$h = getAction$1;
	const assertRequest_js_1$1 = assertRequest$1;
	const getChainId_js_1$3 = getChainId$1;
	const prepareTransactionRequest_js_1$2 = requirePrepareTransactionRequest();
	const sendRawTransaction_js_1$2 = sendRawTransaction$1;
	async function sendTransaction$2(client, parameters) {
	    const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, ...rest } = parameters;
	    if (!account_)
	        throw new account_js_1$4.AccountNotFoundError({
	            docsPath: '/docs/actions/wallet/sendTransaction',
	        });
	    const account = (0, parseAccount_js_1$5.parseAccount)(account_);
	    try {
	        (0, assertRequest_js_1$1.assertRequest)(parameters);
	        const to = await (async () => {
	            if (parameters.to)
	                return parameters.to;
	            if (authorizationList && authorizationList.length > 0)
	                return await (0, recoverAuthorizationAddress_js_1.recoverAuthorizationAddress)({
	                    authorization: authorizationList[0],
	                }).catch(() => {
	                    throw new base_js_1$9.BaseError('`to` is required. Could not infer from `authorizationList`.');
	                });
	            return undefined;
	        })();
	        if (account.type === 'json-rpc') {
	            let chainId;
	            if (chain !== null) {
	                chainId = await (0, getAction_js_1$h.getAction)(client, getChainId_js_1$3.getChainId, 'getChainId')({});
	                (0, assertCurrentChain_js_1$1.assertCurrentChain)({
	                    currentChainId: chainId,
	                    chain,
	                });
	            }
	            const chainFormat = client.chain?.formatters?.transactionRequest?.format;
	            const format = chainFormat || transactionRequest_js_1$2.formatTransactionRequest;
	            const request = format({
	                ...(0, extract_js_1$1.extract)(rest, { format: chainFormat }),
	                accessList,
	                authorizationList,
	                blobs,
	                chainId,
	                data,
	                from: account.address,
	                gas,
	                gasPrice,
	                maxFeePerBlobGas,
	                maxFeePerGas,
	                maxPriorityFeePerGas,
	                nonce,
	                to,
	                value,
	            });
	            return await client.request({
	                method: 'eth_sendTransaction',
	                params: [request],
	            }, { retryCount: 0 });
	        }
	        if (account.type === 'local') {
	            const request = await (0, getAction_js_1$h.getAction)(client, prepareTransactionRequest_js_1$2.prepareTransactionRequest, 'prepareTransactionRequest')({
	                account,
	                accessList,
	                authorizationList,
	                blobs,
	                chain,
	                data,
	                gas,
	                gasPrice,
	                maxFeePerBlobGas,
	                maxFeePerGas,
	                maxPriorityFeePerGas,
	                nonce,
	                nonceManager: account.nonceManager,
	                parameters: [...prepareTransactionRequest_js_1$2.defaultParameters, 'sidecars'],
	                value,
	                ...rest,
	                to,
	            });
	            const serializer = chain?.serializers?.transaction;
	            const serializedTransaction = (await account.signTransaction(request, {
	                serializer,
	            }));
	            return await (0, getAction_js_1$h.getAction)(client, sendRawTransaction_js_1$2.sendRawTransaction, 'sendRawTransaction')({
	                serializedTransaction,
	            });
	        }
	        if (account.type === 'smart')
	            throw new account_js_1$4.AccountTypeNotSupportedError({
	                metaMessages: [
	                    'Consider using the `sendUserOperation` Action instead.',
	                ],
	                docsPath: '/docs/actions/bundler/sendUserOperation',
	                type: 'smart',
	            });
	        throw new account_js_1$4.AccountTypeNotSupportedError({
	            docsPath: '/docs/actions/wallet/sendTransaction',
	            type: account.type,
	        });
	    }
	    catch (err) {
	        if (err instanceof account_js_1$4.AccountTypeNotSupportedError)
	            throw err;
	        throw (0, getTransactionError_js_1.getTransactionError)(err, {
	            ...parameters,
	            account,
	            chain: parameters.chain || undefined,
	        });
	    }
	}

	Object.defineProperty(writeContract$1, "__esModule", { value: true });
	writeContract$1.writeContract = writeContract;
	const parseAccount_js_1$4 = parseAccount$1;
	const account_js_1$3 = account;
	const encodeFunctionData_js_1$3 = encodeFunctionData$1;
	const getContractError_js_1$1 = getContractError$1;
	const getAction_js_1$g = getAction$1;
	const sendTransaction_js_1$2 = sendTransaction$3;
	async function writeContract(client, parameters) {
	    const { abi, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
	    if (!account_)
	        throw new account_js_1$3.AccountNotFoundError({
	            docsPath: '/docs/contract/writeContract',
	        });
	    const account = (0, parseAccount_js_1$4.parseAccount)(account_);
	    const data = (0, encodeFunctionData_js_1$3.encodeFunctionData)({
	        abi,
	        args,
	        functionName,
	    });
	    try {
	        return await (0, getAction_js_1$g.getAction)(client, sendTransaction_js_1$2.sendTransaction, 'sendTransaction')({
	            data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
	            to: address,
	            account,
	            ...request,
	        });
	    }
	    catch (error) {
	        throw (0, getContractError_js_1$1.getContractError)(error, {
	            abi,
	            address,
	            args,
	            docsPath: '/docs/contract/writeContract',
	            functionName,
	            sender: account.address,
	        });
	    }
	}

	Object.defineProperty(getContract$2, "__esModule", { value: true });
	getContract$2.getContract = getContract$1;
	getContract$2.getFunctionParameters = getFunctionParameters;
	getContract$2.getEventParameters = getEventParameters;
	const getAction_js_1$f = getAction$1;
	const createContractEventFilter_js_1$1 = createContractEventFilter$1;
	const estimateContractGas_js_1$1 = estimateContractGas$1;
	const getContractEvents_js_1$1 = getContractEvents$2;
	const readContract_js_1$8 = readContract$3;
	const simulateContract_js_1$1 = simulateContract$1;
	const watchContractEvent_js_1$1 = watchContractEvent$1;
	const writeContract_js_1$1 = writeContract$1;
	function getContract$1({ abi, address, client: client_, }) {
	    const client = client_;
	    const [publicClient, walletClient] = (() => {
	        if (!client)
	            return [undefined, undefined];
	        if ('public' in client && 'wallet' in client)
	            return [client.public, client.wallet];
	        if ('public' in client)
	            return [client.public, undefined];
	        if ('wallet' in client)
	            return [undefined, client.wallet];
	        return [client, client];
	    })();
	    const hasPublicClient = publicClient !== undefined && publicClient !== null;
	    const hasWalletClient = walletClient !== undefined && walletClient !== null;
	    const contract = {};
	    let hasReadFunction = false;
	    let hasWriteFunction = false;
	    let hasEvent = false;
	    for (const item of abi) {
	        if (item.type === 'function')
	            if (item.stateMutability === 'view' || item.stateMutability === 'pure')
	                hasReadFunction = true;
	            else
	                hasWriteFunction = true;
	        else if (item.type === 'event')
	            hasEvent = true;
	        if (hasReadFunction && hasWriteFunction && hasEvent)
	            break;
	    }
	    if (hasPublicClient) {
	        if (hasReadFunction)
	            contract.read = new Proxy({}, {
	                get(_, functionName) {
	                    return (...parameters) => {
	                        const { args, options } = getFunctionParameters(parameters);
	                        return (0, getAction_js_1$f.getAction)(publicClient, readContract_js_1$8.readContract, 'readContract')({
	                            abi,
	                            address,
	                            functionName,
	                            args,
	                            ...options,
	                        });
	                    };
	                },
	            });
	        if (hasWriteFunction)
	            contract.simulate = new Proxy({}, {
	                get(_, functionName) {
	                    return (...parameters) => {
	                        const { args, options } = getFunctionParameters(parameters);
	                        return (0, getAction_js_1$f.getAction)(publicClient, simulateContract_js_1$1.simulateContract, 'simulateContract')({
	                            abi,
	                            address,
	                            functionName,
	                            args,
	                            ...options,
	                        });
	                    };
	                },
	            });
	        if (hasEvent) {
	            contract.createEventFilter = new Proxy({}, {
	                get(_, eventName) {
	                    return (...parameters) => {
	                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
	                        const { args, options } = getEventParameters(parameters, abiEvent);
	                        return (0, getAction_js_1$f.getAction)(publicClient, createContractEventFilter_js_1$1.createContractEventFilter, 'createContractEventFilter')({
	                            abi,
	                            address,
	                            eventName,
	                            args,
	                            ...options,
	                        });
	                    };
	                },
	            });
	            contract.getEvents = new Proxy({}, {
	                get(_, eventName) {
	                    return (...parameters) => {
	                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
	                        const { args, options } = getEventParameters(parameters, abiEvent);
	                        return (0, getAction_js_1$f.getAction)(publicClient, getContractEvents_js_1$1.getContractEvents, 'getContractEvents')({
	                            abi,
	                            address,
	                            eventName,
	                            args,
	                            ...options,
	                        });
	                    };
	                },
	            });
	            contract.watchEvent = new Proxy({}, {
	                get(_, eventName) {
	                    return (...parameters) => {
	                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
	                        const { args, options } = getEventParameters(parameters, abiEvent);
	                        return (0, getAction_js_1$f.getAction)(publicClient, watchContractEvent_js_1$1.watchContractEvent, 'watchContractEvent')({
	                            abi,
	                            address,
	                            eventName,
	                            args,
	                            ...options,
	                        });
	                    };
	                },
	            });
	        }
	    }
	    if (hasWalletClient) {
	        if (hasWriteFunction)
	            contract.write = new Proxy({}, {
	                get(_, functionName) {
	                    return (...parameters) => {
	                        const { args, options } = getFunctionParameters(parameters);
	                        return (0, getAction_js_1$f.getAction)(walletClient, writeContract_js_1$1.writeContract, 'writeContract')({
	                            abi,
	                            address,
	                            functionName,
	                            args,
	                            ...options,
	                        });
	                    };
	                },
	            });
	    }
	    if (hasPublicClient || hasWalletClient)
	        if (hasWriteFunction)
	            contract.estimateGas = new Proxy({}, {
	                get(_, functionName) {
	                    return (...parameters) => {
	                        const { args, options } = getFunctionParameters(parameters);
	                        const client = (publicClient ?? walletClient);
	                        return (0, getAction_js_1$f.getAction)(client, estimateContractGas_js_1$1.estimateContractGas, 'estimateContractGas')({
	                            abi,
	                            address,
	                            functionName,
	                            args,
	                            ...options,
	                            account: options.account ??
	                                walletClient.account,
	                        });
	                    };
	                },
	            });
	    contract.address = address;
	    contract.abi = abi;
	    return contract;
	}
	function getFunctionParameters(values) {
	    const hasArgs = values.length && Array.isArray(values[0]);
	    const args = hasArgs ? values[0] : [];
	    const options = (hasArgs ? values[1] : values[0]) ?? {};
	    return { args, options };
	}
	function getEventParameters(values, abiEvent) {
	    let hasArgs = false;
	    if (Array.isArray(values[0]))
	        hasArgs = true;
	    else if (values.length === 1) {
	        hasArgs = abiEvent.inputs.some((x) => x.indexed);
	    }
	    else if (values.length === 2) {
	        hasArgs = true;
	    }
	    const args = hasArgs ? values[0] : undefined;
	    const options = (hasArgs ? values[1] : values[0]) ?? {};
	    return { args, options };
	}

	var createClient$1 = {};

	var uid$1 = {};

	Object.defineProperty(uid$1, "__esModule", { value: true });
	uid$1.uid = uid;
	const size = 256;
	let index = size;
	let buffer;
	function uid(length = 11) {
	    if (!buffer || index + length > size * 2) {
	        buffer = '';
	        index = 0;
	        for (let i = 0; i < size; i++) {
	            buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
	        }
	    }
	    return buffer.substring(index, index++ + length);
	}

	Object.defineProperty(createClient$1, "__esModule", { value: true });
	createClient$1.createClient = createClient;
	createClient$1.rpcSchema = rpcSchema;
	const parseAccount_js_1$3 = parseAccount$1;
	const uid_js_1$1 = uid$1;
	function createClient(parameters) {
	    const { batch, cacheTime = parameters.pollingInterval ?? 4_000, ccipRead, key = 'base', name = 'Base Client', pollingInterval = 4_000, type = 'base', } = parameters;
	    const chain = parameters.chain;
	    const account = parameters.account
	        ? (0, parseAccount_js_1$3.parseAccount)(parameters.account)
	        : undefined;
	    const { config, request, value } = parameters.transport({
	        chain,
	        pollingInterval,
	    });
	    const transport = { ...config, ...value };
	    const client = {
	        account,
	        batch,
	        cacheTime,
	        ccipRead,
	        chain,
	        key,
	        name,
	        pollingInterval,
	        request,
	        transport,
	        type,
	        uid: (0, uid_js_1$1.uid)(),
	    };
	    function extend(base) {
	        return (extendFn) => {
	            const extended = extendFn(base);
	            for (const key in client)
	                delete extended[key];
	            const combined = { ...base, ...extended };
	            return Object.assign(combined, { extend: extend(combined) });
	        };
	    }
	    return Object.assign(client, { extend: extend(client) });
	}
	function rpcSchema() {
	    return null;
	}

	var custom$1 = {};

	var createTransport$1 = {};

	var buildRequest$1 = {};

	var withDedupe = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.promiseCache = void 0;
		exports.withDedupe = withDedupe;
		const lru_js_1 = lru;
		exports.promiseCache = new lru_js_1.LruMap(8192);
		function withDedupe(fn, { enabled = true, id }) {
		    if (!enabled || !id)
		        return fn();
		    if (exports.promiseCache.get(id))
		        return exports.promiseCache.get(id);
		    const promise = fn().finally(() => exports.promiseCache.delete(id));
		    exports.promiseCache.set(id, promise);
		    return promise;
		}
		
	} (withDedupe));

	var withRetry$1 = {};

	Object.defineProperty(withRetry$1, "__esModule", { value: true });
	withRetry$1.withRetry = withRetry;
	const wait_js_1$1 = wait$1;
	function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true, } = {}) {
	    return new Promise((resolve, reject) => {
	        const attemptRetry = async ({ count = 0 } = {}) => {
	            const retry = async ({ error }) => {
	                const delay = typeof delay_ === 'function' ? delay_({ count, error }) : delay_;
	                if (delay)
	                    await (0, wait_js_1$1.wait)(delay);
	                attemptRetry({ count: count + 1 });
	            };
	            try {
	                const data = await fn();
	                resolve(data);
	            }
	            catch (err) {
	                if (count < retryCount &&
	                    (await shouldRetry({ count, error: err })))
	                    return retry({ error: err });
	                reject(err);
	            }
	        };
	        attemptRetry();
	    });
	}

	Object.defineProperty(buildRequest$1, "__esModule", { value: true });
	buildRequest$1.buildRequest = buildRequest;
	buildRequest$1.shouldRetry = shouldRetry;
	const base_js_1$8 = base$1;
	const request_js_1$4 = request;
	const rpc_js_1$a = rpc;
	const toHex_js_1$A = requireToHex();
	const keccak256_js_1$7 = keccak256$3;
	const withDedupe_js_1 = withDedupe;
	const withRetry_js_1$1 = withRetry$1;
	const stringify_js_1$6 = stringify$1;
	function buildRequest(request, options = {}) {
	    return async (args, overrideOptions = {}) => {
	        const { dedupe = false, retryDelay = 150, retryCount = 3, uid, } = {
	            ...options,
	            ...overrideOptions,
	        };
	        const requestId = dedupe
	            ? (0, keccak256_js_1$7.keccak256)((0, toHex_js_1$A.stringToHex)(`${uid}.${(0, stringify_js_1$6.stringify)(args)}`))
	            : undefined;
	        return (0, withDedupe_js_1.withDedupe)(() => (0, withRetry_js_1$1.withRetry)(async () => {
	            try {
	                return await request(args);
	            }
	            catch (err_) {
	                const err = err_;
	                switch (err.code) {
	                    case rpc_js_1$a.ParseRpcError.code:
	                        throw new rpc_js_1$a.ParseRpcError(err);
	                    case rpc_js_1$a.InvalidRequestRpcError.code:
	                        throw new rpc_js_1$a.InvalidRequestRpcError(err);
	                    case rpc_js_1$a.MethodNotFoundRpcError.code:
	                        throw new rpc_js_1$a.MethodNotFoundRpcError(err, { method: args.method });
	                    case rpc_js_1$a.InvalidParamsRpcError.code:
	                        throw new rpc_js_1$a.InvalidParamsRpcError(err);
	                    case rpc_js_1$a.InternalRpcError.code:
	                        throw new rpc_js_1$a.InternalRpcError(err);
	                    case rpc_js_1$a.InvalidInputRpcError.code:
	                        throw new rpc_js_1$a.InvalidInputRpcError(err);
	                    case rpc_js_1$a.ResourceNotFoundRpcError.code:
	                        throw new rpc_js_1$a.ResourceNotFoundRpcError(err);
	                    case rpc_js_1$a.ResourceUnavailableRpcError.code:
	                        throw new rpc_js_1$a.ResourceUnavailableRpcError(err);
	                    case rpc_js_1$a.TransactionRejectedRpcError.code:
	                        throw new rpc_js_1$a.TransactionRejectedRpcError(err);
	                    case rpc_js_1$a.MethodNotSupportedRpcError.code:
	                        throw new rpc_js_1$a.MethodNotSupportedRpcError(err, {
	                            method: args.method,
	                        });
	                    case rpc_js_1$a.LimitExceededRpcError.code:
	                        throw new rpc_js_1$a.LimitExceededRpcError(err);
	                    case rpc_js_1$a.JsonRpcVersionUnsupportedError.code:
	                        throw new rpc_js_1$a.JsonRpcVersionUnsupportedError(err);
	                    case rpc_js_1$a.UserRejectedRequestError.code:
	                        throw new rpc_js_1$a.UserRejectedRequestError(err);
	                    case rpc_js_1$a.UnauthorizedProviderError.code:
	                        throw new rpc_js_1$a.UnauthorizedProviderError(err);
	                    case rpc_js_1$a.UnsupportedProviderMethodError.code:
	                        throw new rpc_js_1$a.UnsupportedProviderMethodError(err);
	                    case rpc_js_1$a.ProviderDisconnectedError.code:
	                        throw new rpc_js_1$a.ProviderDisconnectedError(err);
	                    case rpc_js_1$a.ChainDisconnectedError.code:
	                        throw new rpc_js_1$a.ChainDisconnectedError(err);
	                    case rpc_js_1$a.SwitchChainError.code:
	                        throw new rpc_js_1$a.SwitchChainError(err);
	                    case 5000:
	                        throw new rpc_js_1$a.UserRejectedRequestError(err);
	                    default:
	                        if (err_ instanceof base_js_1$8.BaseError)
	                            throw err_;
	                        throw new rpc_js_1$a.UnknownRpcError(err);
	                }
	            }
	        }, {
	            delay: ({ count, error }) => {
	                if (error && error instanceof request_js_1$4.HttpRequestError) {
	                    const retryAfter = error?.headers?.get('Retry-After');
	                    if (retryAfter?.match(/\d/))
	                        return Number.parseInt(retryAfter) * 1000;
	                }
	                return ~~(1 << count) * retryDelay;
	            },
	            retryCount,
	            shouldRetry: ({ error }) => shouldRetry(error),
	        }), { enabled: dedupe, id: requestId });
	    };
	}
	function shouldRetry(error) {
	    if ('code' in error && typeof error.code === 'number') {
	        if (error.code === -1)
	            return true;
	        if (error.code === rpc_js_1$a.LimitExceededRpcError.code)
	            return true;
	        if (error.code === rpc_js_1$a.InternalRpcError.code)
	            return true;
	        return false;
	    }
	    if (error instanceof request_js_1$4.HttpRequestError && error.status) {
	        if (error.status === 403)
	            return true;
	        if (error.status === 408)
	            return true;
	        if (error.status === 413)
	            return true;
	        if (error.status === 429)
	            return true;
	        if (error.status === 500)
	            return true;
	        if (error.status === 502)
	            return true;
	        if (error.status === 503)
	            return true;
	        if (error.status === 504)
	            return true;
	        return false;
	    }
	    return true;
	}

	Object.defineProperty(createTransport$1, "__esModule", { value: true });
	createTransport$1.createTransport = createTransport;
	const buildRequest_js_1 = buildRequest$1;
	const uid_js_1 = uid$1;
	function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type, }, value) {
	    const uid = (0, uid_js_1.uid)();
	    return {
	        config: {
	            key,
	            name,
	            request,
	            retryCount,
	            retryDelay,
	            timeout,
	            type,
	        },
	        request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay, uid }),
	        value,
	    };
	}

	Object.defineProperty(custom$1, "__esModule", { value: true });
	custom$1.custom = custom;
	const createTransport_js_1$3 = createTransport$1;
	function custom(provider, config = {}) {
	    const { key = 'custom', name = 'Custom Provider', retryDelay } = config;
	    return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1$3.createTransport)({
	        key,
	        name,
	        request: provider.request.bind(provider),
	        retryCount: config.retryCount ?? defaultRetryCount,
	        retryDelay,
	        type: 'custom',
	    });
	}

	var fallback$1 = {};

	Object.defineProperty(fallback$1, "__esModule", { value: true });
	fallback$1.fallback = fallback;
	fallback$1.rankTransports = rankTransports;
	const rpc_js_1$9 = rpc;
	const wait_js_1 = wait$1;
	const createTransport_js_1$2 = createTransport$1;
	function fallback(transports_, config = {}) {
	    const { key = 'fallback', name = 'Fallback', rank = false, retryCount, retryDelay, } = config;
	    return (({ chain, pollingInterval = 4_000, timeout, ...rest }) => {
	        let transports = transports_;
	        let onResponse = () => { };
	        const transport = (0, createTransport_js_1$2.createTransport)({
	            key,
	            name,
	            async request({ method, params }) {
	                const fetch = async (i = 0) => {
	                    const transport = transports[i]({
	                        ...rest,
	                        chain,
	                        retryCount: 0,
	                        timeout,
	                    });
	                    try {
	                        const response = await transport.request({
	                            method,
	                            params,
	                        });
	                        onResponse({
	                            method,
	                            params: params,
	                            response,
	                            transport,
	                            status: 'success',
	                        });
	                        return response;
	                    }
	                    catch (err) {
	                        onResponse({
	                            error: err,
	                            method,
	                            params: params,
	                            transport,
	                            status: 'error',
	                        });
	                        if (shouldThrow(err))
	                            throw err;
	                        if (i === transports.length - 1)
	                            throw err;
	                        return fetch(i + 1);
	                    }
	                };
	                return fetch();
	            },
	            retryCount,
	            retryDelay,
	            type: 'fallback',
	        }, {
	            onResponse: (fn) => (onResponse = fn),
	            transports: transports.map((fn) => fn({ chain, retryCount: 0 })),
	        });
	        if (rank) {
	            const rankOptions = (typeof rank === 'object' ? rank : {});
	            rankTransports({
	                chain,
	                interval: rankOptions.interval ?? pollingInterval,
	                onTransports: (transports_) => (transports = transports_),
	                sampleCount: rankOptions.sampleCount,
	                timeout: rankOptions.timeout,
	                transports,
	                weights: rankOptions.weights,
	            });
	        }
	        return transport;
	    });
	}
	function shouldThrow(error) {
	    if ('code' in error && typeof error.code === 'number') {
	        if (error.code === rpc_js_1$9.TransactionRejectedRpcError.code ||
	            error.code === rpc_js_1$9.UserRejectedRequestError.code ||
	            error.code === 5000)
	            return true;
	    }
	    return false;
	}
	function rankTransports({ chain, interval = 4_000, onTransports, sampleCount = 10, timeout = 1_000, transports, weights = {}, }) {
	    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
	    const samples = [];
	    const rankTransports_ = async () => {
	        const sample = await Promise.all(transports.map(async (transport) => {
	            const transport_ = transport({ chain, retryCount: 0, timeout });
	            const start = Date.now();
	            let end;
	            let success;
	            try {
	                await transport_.request({ method: 'net_listening' });
	                success = 1;
	            }
	            catch {
	                success = 0;
	            }
	            finally {
	                end = Date.now();
	            }
	            const latency = end - start;
	            return { latency, success };
	        }));
	        samples.push(sample);
	        if (samples.length > sampleCount)
	            samples.shift();
	        const maxLatency = Math.max(...samples.map((sample) => Math.max(...sample.map(({ latency }) => latency))));
	        const scores = transports
	            .map((_, i) => {
	            const latencies = samples.map((sample) => sample[i].latency);
	            const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) /
	                latencies.length;
	            const latencyScore = 1 - meanLatency / maxLatency;
	            const successes = samples.map((sample) => sample[i].success);
	            const stabilityScore = successes.reduce((acc, success) => acc + success, 0) /
	                successes.length;
	            if (stabilityScore === 0)
	                return [0, i];
	            return [
	                latencyWeight * latencyScore + stabilityWeight * stabilityScore,
	                i,
	            ];
	        })
	            .sort((a, b) => b[0] - a[0]);
	        onTransports(scores.map(([, i]) => transports[i]));
	        await (0, wait_js_1.wait)(interval);
	        rankTransports_();
	    };
	    rankTransports_();
	}

	var http$2 = {};

	var transport = {};

	Object.defineProperty(transport, "__esModule", { value: true });
	transport.UrlRequiredError = void 0;
	const base_js_1$7 = base$1;
	class UrlRequiredError extends base_js_1$7.BaseError {
	    constructor() {
	        super('No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.', {
	            docsPath: '/docs/clients/intro',
	            name: 'UrlRequiredError',
	        });
	    }
	}
	transport.UrlRequiredError = UrlRequiredError;

	var http$1 = {};

	var withTimeout$1 = {};

	Object.defineProperty(withTimeout$1, "__esModule", { value: true });
	withTimeout$1.withTimeout = withTimeout;
	function withTimeout(fn, { errorInstance = new Error('timed out'), timeout, signal, }) {
	    return new Promise((resolve, reject) => {
	        (async () => {
	            let timeoutId;
	            try {
	                const controller = new AbortController();
	                if (timeout > 0) {
	                    timeoutId = setTimeout(() => {
	                        if (signal) {
	                            controller.abort();
	                        }
	                        else {
	                            reject(errorInstance);
	                        }
	                    }, timeout);
	                }
	                resolve(await fn({ signal: controller?.signal || null }));
	            }
	            catch (err) {
	                if (err?.name === 'AbortError')
	                    reject(errorInstance);
	                reject(err);
	            }
	            finally {
	                clearTimeout(timeoutId);
	            }
	        })();
	    });
	}

	var id = {};

	Object.defineProperty(id, "__esModule", { value: true });
	id.idCache = void 0;
	function createIdStore() {
	    return {
	        current: 0,
	        take() {
	            return this.current++;
	        },
	        reset() {
	            this.current = 0;
	        },
	    };
	}
	id.idCache = createIdStore();

	Object.defineProperty(http$1, "__esModule", { value: true });
	http$1.getHttpRpcClient = getHttpRpcClient;
	const request_js_1$3 = request;
	const withTimeout_js_1 = withTimeout$1;
	const stringify_js_1$5 = stringify$1;
	const id_js_1 = id;
	function getHttpRpcClient(url, options = {}) {
	    return {
	        async request(params) {
	            const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 10_000, } = params;
	            const fetchOptions = {
	                ...(options.fetchOptions ?? {}),
	                ...(params.fetchOptions ?? {}),
	            };
	            const { headers, method, signal: signal_ } = fetchOptions;
	            try {
	                const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
	                    const init = {
	                        ...fetchOptions,
	                        body: Array.isArray(body)
	                            ? (0, stringify_js_1$5.stringify)(body.map((body) => ({
	                                jsonrpc: '2.0',
	                                id: body.id ?? id_js_1.idCache.take(),
	                                ...body,
	                            })))
	                            : (0, stringify_js_1$5.stringify)({
	                                jsonrpc: '2.0',
	                                id: body.id ?? id_js_1.idCache.take(),
	                                ...body,
	                            }),
	                        headers: {
	                            'Content-Type': 'application/json',
	                            ...headers,
	                        },
	                        method: method || 'POST',
	                        signal: signal_ || (timeout > 0 ? signal : null),
	                    };
	                    const request = new Request(url, init);
	                    if (onRequest)
	                        await onRequest(request);
	                    const response = await fetch(url, init);
	                    return response;
	                }, {
	                    errorInstance: new request_js_1$3.TimeoutError({ body, url }),
	                    timeout,
	                    signal: true,
	                });
	                if (onResponse)
	                    await onResponse(response);
	                let data;
	                if (response.headers.get('Content-Type')?.startsWith('application/json'))
	                    data = await response.json();
	                else {
	                    data = await response.text();
	                    data = JSON.parse(data || '{}');
	                }
	                if (!response.ok) {
	                    throw new request_js_1$3.HttpRequestError({
	                        body,
	                        details: (0, stringify_js_1$5.stringify)(data.error) || response.statusText,
	                        headers: response.headers,
	                        status: response.status,
	                        url,
	                    });
	                }
	                return data;
	            }
	            catch (err) {
	                if (err instanceof request_js_1$3.HttpRequestError)
	                    throw err;
	                if (err instanceof request_js_1$3.TimeoutError)
	                    throw err;
	                throw new request_js_1$3.HttpRequestError({
	                    body,
	                    cause: err,
	                    url,
	                });
	            }
	        },
	    };
	}

	Object.defineProperty(http$2, "__esModule", { value: true });
	http$2.http = http;
	const request_js_1$2 = request;
	const transport_js_1$1 = transport;
	const createBatchScheduler_js_1 = createBatchScheduler$1;
	const http_js_1$1 = http$1;
	const createTransport_js_1$1 = createTransport$1;
	function http(url, config = {}) {
	    const { batch, fetchOptions, key = 'http', name = 'HTTP JSON-RPC', onFetchRequest, onFetchResponse, retryDelay, } = config;
	    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
	        const { batchSize = 1000, wait = 0 } = typeof batch === 'object' ? batch : {};
	        const retryCount = config.retryCount ?? retryCount_;
	        const timeout = timeout_ ?? config.timeout ?? 10_000;
	        const url_ = url || chain?.rpcUrls.default.http[0];
	        if (!url_)
	            throw new transport_js_1$1.UrlRequiredError();
	        const rpcClient = (0, http_js_1$1.getHttpRpcClient)(url_, {
	            fetchOptions,
	            onRequest: onFetchRequest,
	            onResponse: onFetchResponse,
	            timeout,
	        });
	        return (0, createTransport_js_1$1.createTransport)({
	            key,
	            name,
	            async request({ method, params }) {
	                const body = { method, params };
	                const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
	                    id: url_,
	                    wait,
	                    shouldSplitBatch(requests) {
	                        return requests.length > batchSize;
	                    },
	                    fn: (body) => rpcClient.request({
	                        body,
	                    }),
	                    sort: (a, b) => a.id - b.id,
	                });
	                const fn = async (body) => batch
	                    ? schedule(body)
	                    : [
	                        await rpcClient.request({
	                            body,
	                        }),
	                    ];
	                const [{ error, result }] = await fn(body);
	                if (error)
	                    throw new request_js_1$2.RpcRequestError({
	                        body,
	                        error,
	                        url: url_,
	                    });
	                return result;
	            },
	            retryCount,
	            retryDelay,
	            timeout,
	            type: 'http',
	        }, {
	            fetchOptions,
	            url: url_,
	        });
	    };
	}

	var createPublicClient$1 = {};

	var _public = {};

	var getEnsAddress$1 = {};

	var errors = {};

	Object.defineProperty(errors, "__esModule", { value: true });
	errors.isNullUniversalResolverError = isNullUniversalResolverError;
	const solidity_js_1 = solidity;
	const base_js_1$6 = base$1;
	const contract_js_1$5 = contract$2;
	function isNullUniversalResolverError(err, callType) {
	    if (!(err instanceof base_js_1$6.BaseError))
	        return false;
	    const cause = err.walk((e) => e instanceof contract_js_1$5.ContractFunctionRevertedError);
	    if (!(cause instanceof contract_js_1$5.ContractFunctionRevertedError))
	        return false;
	    if (cause.data?.errorName === 'ResolverNotFound')
	        return true;
	    if (cause.data?.errorName === 'ResolverWildcardNotSupported')
	        return true;
	    if (cause.data?.errorName === 'ResolverNotContract')
	        return true;
	    if (cause.data?.errorName === 'ResolverError')
	        return true;
	    if (cause.data?.errorName === 'HttpError')
	        return true;
	    if (cause.reason?.includes('Wildcard on non-extended resolvers is not supported'))
	        return true;
	    if (callType === 'reverse' && cause.reason === solidity_js_1.panicReasons[50])
	        return true;
	    return false;
	}

	var namehash$1 = {};

	var encodedLabelToLabelhash$1 = {};

	Object.defineProperty(encodedLabelToLabelhash$1, "__esModule", { value: true });
	encodedLabelToLabelhash$1.encodedLabelToLabelhash = encodedLabelToLabelhash;
	const isHex_js_1$5 = isHex$1;
	function encodedLabelToLabelhash(label) {
	    if (label.length !== 66)
	        return null;
	    if (label.indexOf('[') !== 0)
	        return null;
	    if (label.indexOf(']') !== 65)
	        return null;
	    const hash = `0x${label.slice(1, 65)}`;
	    if (!(0, isHex_js_1$5.isHex)(hash))
	        return null;
	    return hash;
	}

	Object.defineProperty(namehash$1, "__esModule", { value: true });
	namehash$1.namehash = namehash;
	const concat_js_1$5 = concat$1;
	const toBytes_js_1$b = requireToBytes();
	const toHex_js_1$z = requireToHex();
	const keccak256_js_1$6 = keccak256$3;
	const encodedLabelToLabelhash_js_1$1 = encodedLabelToLabelhash$1;
	function namehash(name) {
	    let result = new Uint8Array(32).fill(0);
	    if (!name)
	        return (0, toHex_js_1$z.bytesToHex)(result);
	    const labels = name.split('.');
	    for (let i = labels.length - 1; i >= 0; i -= 1) {
	        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1$1.encodedLabelToLabelhash)(labels[i]);
	        const hashed = hashFromEncodedLabel
	            ? (0, toBytes_js_1$b.toBytes)(hashFromEncodedLabel)
	            : (0, keccak256_js_1$6.keccak256)((0, toBytes_js_1$b.stringToBytes)(labels[i]), 'bytes');
	        result = (0, keccak256_js_1$6.keccak256)((0, concat_js_1$5.concat)([result, hashed]), 'bytes');
	    }
	    return (0, toHex_js_1$z.bytesToHex)(result);
	}

	var packetToBytes$1 = {};

	var encodeLabelhash$1 = {};

	Object.defineProperty(encodeLabelhash$1, "__esModule", { value: true });
	encodeLabelhash$1.encodeLabelhash = encodeLabelhash;
	function encodeLabelhash(hash) {
	    return `[${hash.slice(2)}]`;
	}

	var labelhash$1 = {};

	Object.defineProperty(labelhash$1, "__esModule", { value: true });
	labelhash$1.labelhash = labelhash;
	const toBytes_js_1$a = requireToBytes();
	const toHex_js_1$y = requireToHex();
	const keccak256_js_1$5 = keccak256$3;
	const encodedLabelToLabelhash_js_1 = encodedLabelToLabelhash$1;
	function labelhash(label) {
	    const result = new Uint8Array(32).fill(0);
	    if (!label)
	        return (0, toHex_js_1$y.bytesToHex)(result);
	    return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1$5.keccak256)((0, toBytes_js_1$a.stringToBytes)(label));
	}

	Object.defineProperty(packetToBytes$1, "__esModule", { value: true });
	packetToBytes$1.packetToBytes = packetToBytes;
	const toBytes_js_1$9 = requireToBytes();
	const encodeLabelhash_js_1 = encodeLabelhash$1;
	const labelhash_js_1 = labelhash$1;
	function packetToBytes(packet) {
	    const value = packet.replace(/^\.|\.$/gm, '');
	    if (value.length === 0)
	        return new Uint8Array(1);
	    const bytes = new Uint8Array((0, toBytes_js_1$9.stringToBytes)(value).byteLength + 2);
	    let offset = 0;
	    const list = value.split('.');
	    for (let i = 0; i < list.length; i++) {
	        let encoded = (0, toBytes_js_1$9.stringToBytes)(list[i]);
	        if (encoded.byteLength > 255)
	            encoded = (0, toBytes_js_1$9.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
	        bytes[offset] = encoded.length;
	        bytes.set(encoded, offset + 1);
	        offset += encoded.length + 1;
	    }
	    if (bytes.byteLength !== offset + 1)
	        return bytes.slice(0, offset + 1);
	    return bytes;
	}

	Object.defineProperty(getEnsAddress$1, "__esModule", { value: true });
	getEnsAddress$1.getEnsAddress = getEnsAddress;
	const abis_js_1$4 = abis;
	const decodeFunctionResult_js_1$2 = decodeFunctionResult$1;
	const encodeFunctionData_js_1$2 = encodeFunctionData$1;
	const getChainContractAddress_js_1$4 = getChainContractAddress$1;
	const trim_js_1$2 = trim$3;
	const toHex_js_1$x = requireToHex();
	const errors_js_1$2 = errors;
	const namehash_js_1$1 = namehash$1;
	const packetToBytes_js_1$3 = packetToBytes$1;
	const getAction_js_1$e = getAction$1;
	const readContract_js_1$7 = readContract$3;
	async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_, }) {
	    let universalResolverAddress = universalResolverAddress_;
	    if (!universalResolverAddress) {
	        if (!client.chain)
	            throw new Error('client chain not configured. universalResolverAddress is required.');
	        universalResolverAddress = (0, getChainContractAddress_js_1$4.getChainContractAddress)({
	            blockNumber,
	            chain: client.chain,
	            contract: 'ensUniversalResolver',
	        });
	    }
	    try {
	        const functionData = (0, encodeFunctionData_js_1$2.encodeFunctionData)({
	            abi: abis_js_1$4.addressResolverAbi,
	            functionName: 'addr',
	            ...(coinType != null
	                ? { args: [(0, namehash_js_1$1.namehash)(name), BigInt(coinType)] }
	                : { args: [(0, namehash_js_1$1.namehash)(name)] }),
	        });
	        const readContractParameters = {
	            address: universalResolverAddress,
	            abi: abis_js_1$4.universalResolverResolveAbi,
	            functionName: 'resolve',
	            args: [(0, toHex_js_1$x.toHex)((0, packetToBytes_js_1$3.packetToBytes)(name)), functionData],
	            blockNumber,
	            blockTag,
	        };
	        const readContractAction = (0, getAction_js_1$e.getAction)(client, readContract_js_1$7.readContract, 'readContract');
	        const res = gatewayUrls
	            ? await readContractAction({
	                ...readContractParameters,
	                args: [...readContractParameters.args, gatewayUrls],
	            })
	            : await readContractAction(readContractParameters);
	        if (res[0] === '0x')
	            return null;
	        const address = (0, decodeFunctionResult_js_1$2.decodeFunctionResult)({
	            abi: abis_js_1$4.addressResolverAbi,
	            args: coinType != null ? [(0, namehash_js_1$1.namehash)(name), BigInt(coinType)] : undefined,
	            functionName: 'addr',
	            data: res[0],
	        });
	        if (address === '0x')
	            return null;
	        if ((0, trim_js_1$2.trim)(address) === '0x00')
	            return null;
	        return address;
	    }
	    catch (err) {
	        if (strict)
	            throw err;
	        if ((0, errors_js_1$2.isNullUniversalResolverError)(err, 'resolve'))
	            return null;
	        throw err;
	    }
	}

	var getEnsAvatar$1 = {};

	var parseAvatarRecord$1 = {};

	var utils$3 = {};

	var ens = {};

	Object.defineProperty(ens, "__esModule", { value: true });
	ens.EnsAvatarUnsupportedNamespaceError = ens.EnsAvatarUriResolutionError = ens.EnsAvatarInvalidNftUriError = ens.EnsAvatarInvalidMetadataError = void 0;
	const base_js_1$5 = base$1;
	class EnsAvatarInvalidMetadataError extends base_js_1$5.BaseError {
	    constructor({ data }) {
	        super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
	            metaMessages: [
	                '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
	                '',
	                `Provided data: ${JSON.stringify(data)}`,
	            ],
	            name: 'EnsAvatarInvalidMetadataError',
	        });
	    }
	}
	ens.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
	class EnsAvatarInvalidNftUriError extends base_js_1$5.BaseError {
	    constructor({ reason }) {
	        super(`ENS NFT avatar URI is invalid. ${reason}`, {
	            name: 'EnsAvatarInvalidNftUriError',
	        });
	    }
	}
	ens.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
	class EnsAvatarUriResolutionError extends base_js_1$5.BaseError {
	    constructor({ uri }) {
	        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: 'EnsAvatarUriResolutionError' });
	    }
	}
	ens.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
	class EnsAvatarUnsupportedNamespaceError extends base_js_1$5.BaseError {
	    constructor({ namespace }) {
	        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: 'EnsAvatarUnsupportedNamespaceError' });
	    }
	}
	ens.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;

	Object.defineProperty(utils$3, "__esModule", { value: true });
	utils$3.isImageUri = isImageUri;
	utils$3.getGateway = getGateway;
	utils$3.resolveAvatarUri = resolveAvatarUri;
	utils$3.getJsonImage = getJsonImage;
	utils$3.getMetadataAvatarUri = getMetadataAvatarUri;
	utils$3.parseAvatarUri = parseAvatarUri;
	utils$3.parseNftUri = parseNftUri;
	utils$3.getNftTokenUri = getNftTokenUri;
	const readContract_js_1$6 = readContract$3;
	const ens_js_1 = ens;
	const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
	const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
	const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
	const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
	async function isImageUri(uri) {
	    try {
	        const res = await fetch(uri, { method: 'HEAD' });
	        if (res.status === 200) {
	            const contentType = res.headers.get('content-type');
	            return contentType?.startsWith('image/');
	        }
	        return false;
	    }
	    catch (error) {
	        if (typeof error === 'object' && typeof error.response !== 'undefined') {
	            return false;
	        }
	        if (!globalThis.hasOwnProperty('Image'))
	            return false;
	        return new Promise((resolve) => {
	            const img = new Image();
	            img.onload = () => {
	                resolve(true);
	            };
	            img.onerror = () => {
	                resolve(false);
	            };
	            img.src = uri;
	        });
	    }
	}
	function getGateway(custom, defaultGateway) {
	    if (!custom)
	        return defaultGateway;
	    if (custom.endsWith('/'))
	        return custom.slice(0, -1);
	    return custom;
	}
	function resolveAvatarUri({ uri, gatewayUrls, }) {
	    const isEncoded = base64Regex.test(uri);
	    if (isEncoded)
	        return { uri, isOnChain: true, isEncoded };
	    const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');
	    const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');
	    const networkRegexMatch = uri.match(networkRegex);
	    const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};
	    const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';
	    const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);
	    if (uri.startsWith('http') && !isIPNS && !isIPFS) {
	        let replacedUri = uri;
	        if (gatewayUrls?.arweave)
	            replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
	        return { uri: replacedUri, isOnChain: false, isEncoded: false };
	    }
	    if ((isIPNS || isIPFS) && target) {
	        return {
	            uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,
	            isOnChain: false,
	            isEncoded: false,
	        };
	    }
	    if (protocol === 'ar:/' && target) {
	        return {
	            uri: `${arweaveGateway}/${target}${subtarget || ''}`,
	            isOnChain: false,
	            isEncoded: false,
	        };
	    }
	    let parsedUri = uri.replace(dataURIRegex, '');
	    if (parsedUri.startsWith('<svg')) {
	        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
	    }
	    if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {
	        return {
	            uri: parsedUri,
	            isOnChain: true,
	            isEncoded: false,
	        };
	    }
	    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
	}
	function getJsonImage(data) {
	    if (typeof data !== 'object' ||
	        (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {
	        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
	    }
	    return data.image || data.image_url || data.image_data;
	}
	async function getMetadataAvatarUri({ gatewayUrls, uri, }) {
	    try {
	        const res = await fetch(uri).then((res) => res.json());
	        const image = await parseAvatarUri({
	            gatewayUrls,
	            uri: getJsonImage(res),
	        });
	        return image;
	    }
	    catch {
	        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
	    }
	}
	async function parseAvatarUri({ gatewayUrls, uri, }) {
	    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
	    if (isOnChain)
	        return resolvedURI;
	    const isImage = await isImageUri(resolvedURI);
	    if (isImage)
	        return resolvedURI;
	    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
	}
	function parseNftUri(uri_) {
	    let uri = uri_;
	    if (uri.startsWith('did:nft:')) {
	        uri = uri.replace('did:nft:', '').replace(/_/g, '/');
	    }
	    const [reference, asset_namespace, tokenID] = uri.split('/');
	    const [eip_namespace, chainID] = reference.split(':');
	    const [erc_namespace, contractAddress] = asset_namespace.split(':');
	    if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')
	        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });
	    if (!chainID)
	        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });
	    if (!contractAddress)
	        throw new ens_js_1.EnsAvatarInvalidNftUriError({
	            reason: 'Contract address not found',
	        });
	    if (!tokenID)
	        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });
	    if (!erc_namespace)
	        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });
	    return {
	        chainID: Number.parseInt(chainID),
	        namespace: erc_namespace.toLowerCase(),
	        contractAddress: contractAddress,
	        tokenID,
	    };
	}
	async function getNftTokenUri(client, { nft }) {
	    if (nft.namespace === 'erc721') {
	        return (0, readContract_js_1$6.readContract)(client, {
	            address: nft.contractAddress,
	            abi: [
	                {
	                    name: 'tokenURI',
	                    type: 'function',
	                    stateMutability: 'view',
	                    inputs: [{ name: 'tokenId', type: 'uint256' }],
	                    outputs: [{ name: '', type: 'string' }],
	                },
	            ],
	            functionName: 'tokenURI',
	            args: [BigInt(nft.tokenID)],
	        });
	    }
	    if (nft.namespace === 'erc1155') {
	        return (0, readContract_js_1$6.readContract)(client, {
	            address: nft.contractAddress,
	            abi: [
	                {
	                    name: 'uri',
	                    type: 'function',
	                    stateMutability: 'view',
	                    inputs: [{ name: '_id', type: 'uint256' }],
	                    outputs: [{ name: '', type: 'string' }],
	                },
	            ],
	            functionName: 'uri',
	            args: [BigInt(nft.tokenID)],
	        });
	    }
	    throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
	}

	Object.defineProperty(parseAvatarRecord$1, "__esModule", { value: true });
	parseAvatarRecord$1.parseAvatarRecord = parseAvatarRecord;
	const utils_js_1$d = utils$3;
	async function parseAvatarRecord(client, { gatewayUrls, record, }) {
	    if (/eip155:/i.test(record))
	        return parseNftAvatarUri(client, { gatewayUrls, record });
	    return (0, utils_js_1$d.parseAvatarUri)({ uri: record, gatewayUrls });
	}
	async function parseNftAvatarUri(client, { gatewayUrls, record, }) {
	    const nft = (0, utils_js_1$d.parseNftUri)(record);
	    const nftUri = await (0, utils_js_1$d.getNftTokenUri)(client, { nft });
	    const { uri: resolvedNftUri, isOnChain, isEncoded, } = (0, utils_js_1$d.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
	    if (isOnChain &&
	        (resolvedNftUri.includes('data:application/json;base64,') ||
	            resolvedNftUri.startsWith('{'))) {
	        const encodedJson = isEncoded
	            ?
	                atob(resolvedNftUri.replace('data:application/json;base64,', ''))
	            :
	                resolvedNftUri;
	        const decoded = JSON.parse(encodedJson);
	        return (0, utils_js_1$d.parseAvatarUri)({ uri: (0, utils_js_1$d.getJsonImage)(decoded), gatewayUrls });
	    }
	    let uriTokenId = nft.tokenID;
	    if (nft.namespace === 'erc1155')
	        uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');
	    return (0, utils_js_1$d.getMetadataAvatarUri)({
	        gatewayUrls,
	        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),
	    });
	}

	var getEnsText$1 = {};

	Object.defineProperty(getEnsText$1, "__esModule", { value: true });
	getEnsText$1.getEnsText = getEnsText;
	const abis_js_1$3 = abis;
	const decodeFunctionResult_js_1$1 = decodeFunctionResult$1;
	const encodeFunctionData_js_1$1 = encodeFunctionData$1;
	const getChainContractAddress_js_1$3 = getChainContractAddress$1;
	const toHex_js_1$w = requireToHex();
	const errors_js_1$1 = errors;
	const namehash_js_1 = namehash$1;
	const packetToBytes_js_1$2 = packetToBytes$1;
	const getAction_js_1$d = getAction$1;
	const readContract_js_1$5 = readContract$3;
	async function getEnsText(client, { blockNumber, blockTag, name, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_, }) {
	    let universalResolverAddress = universalResolverAddress_;
	    if (!universalResolverAddress) {
	        if (!client.chain)
	            throw new Error('client chain not configured. universalResolverAddress is required.');
	        universalResolverAddress = (0, getChainContractAddress_js_1$3.getChainContractAddress)({
	            blockNumber,
	            chain: client.chain,
	            contract: 'ensUniversalResolver',
	        });
	    }
	    try {
	        const readContractParameters = {
	            address: universalResolverAddress,
	            abi: abis_js_1$3.universalResolverResolveAbi,
	            functionName: 'resolve',
	            args: [
	                (0, toHex_js_1$w.toHex)((0, packetToBytes_js_1$2.packetToBytes)(name)),
	                (0, encodeFunctionData_js_1$1.encodeFunctionData)({
	                    abi: abis_js_1$3.textResolverAbi,
	                    functionName: 'text',
	                    args: [(0, namehash_js_1.namehash)(name), key],
	                }),
	            ],
	            blockNumber,
	            blockTag,
	        };
	        const readContractAction = (0, getAction_js_1$d.getAction)(client, readContract_js_1$5.readContract, 'readContract');
	        const res = gatewayUrls
	            ? await readContractAction({
	                ...readContractParameters,
	                args: [...readContractParameters.args, gatewayUrls],
	            })
	            : await readContractAction(readContractParameters);
	        if (res[0] === '0x')
	            return null;
	        const record = (0, decodeFunctionResult_js_1$1.decodeFunctionResult)({
	            abi: abis_js_1$3.textResolverAbi,
	            functionName: 'text',
	            data: res[0],
	        });
	        return record === '' ? null : record;
	    }
	    catch (err) {
	        if (strict)
	            throw err;
	        if ((0, errors_js_1$1.isNullUniversalResolverError)(err, 'resolve'))
	            return null;
	        throw err;
	    }
	}

	Object.defineProperty(getEnsAvatar$1, "__esModule", { value: true });
	getEnsAvatar$1.getEnsAvatar = getEnsAvatar;
	const parseAvatarRecord_js_1 = parseAvatarRecord$1;
	const getAction_js_1$c = getAction$1;
	const getEnsText_js_1$1 = getEnsText$1;
	async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress, }) {
	    const record = await (0, getAction_js_1$c.getAction)(client, getEnsText_js_1$1.getEnsText, 'getEnsText')({
	        blockNumber,
	        blockTag,
	        key: 'avatar',
	        name,
	        universalResolverAddress,
	        gatewayUrls,
	        strict,
	    });
	    if (!record)
	        return null;
	    try {
	        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, {
	            record,
	            gatewayUrls: assetGatewayUrls,
	        });
	    }
	    catch {
	        return null;
	    }
	}

	var getEnsName$1 = {};

	Object.defineProperty(getEnsName$1, "__esModule", { value: true });
	getEnsName$1.getEnsName = getEnsName;
	const abis_js_1$2 = abis;
	const getChainContractAddress_js_1$2 = getChainContractAddress$1;
	const toHex_js_1$v = requireToHex();
	const errors_js_1 = errors;
	const packetToBytes_js_1$1 = packetToBytes$1;
	const getAction_js_1$b = getAction$1;
	const readContract_js_1$4 = readContract$3;
	async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_, }) {
	    let universalResolverAddress = universalResolverAddress_;
	    if (!universalResolverAddress) {
	        if (!client.chain)
	            throw new Error('client chain not configured. universalResolverAddress is required.');
	        universalResolverAddress = (0, getChainContractAddress_js_1$2.getChainContractAddress)({
	            blockNumber,
	            chain: client.chain,
	            contract: 'ensUniversalResolver',
	        });
	    }
	    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
	    try {
	        const readContractParameters = {
	            address: universalResolverAddress,
	            abi: abis_js_1$2.universalResolverReverseAbi,
	            functionName: 'reverse',
	            args: [(0, toHex_js_1$v.toHex)((0, packetToBytes_js_1$1.packetToBytes)(reverseNode))],
	            blockNumber,
	            blockTag,
	        };
	        const readContractAction = (0, getAction_js_1$b.getAction)(client, readContract_js_1$4.readContract, 'readContract');
	        const [name, resolvedAddress] = gatewayUrls
	            ? await readContractAction({
	                ...readContractParameters,
	                args: [...readContractParameters.args, gatewayUrls],
	            })
	            : await readContractAction(readContractParameters);
	        if (address.toLowerCase() !== resolvedAddress.toLowerCase())
	            return null;
	        return name;
	    }
	    catch (err) {
	        if (strict)
	            throw err;
	        if ((0, errors_js_1.isNullUniversalResolverError)(err, 'reverse'))
	            return null;
	        throw err;
	    }
	}

	var getEnsResolver$1 = {};

	Object.defineProperty(getEnsResolver$1, "__esModule", { value: true });
	getEnsResolver$1.getEnsResolver = getEnsResolver;
	const getChainContractAddress_js_1$1 = getChainContractAddress$1;
	const toHex_js_1$u = requireToHex();
	const packetToBytes_js_1 = packetToBytes$1;
	const getAction_js_1$a = getAction$1;
	const readContract_js_1$3 = readContract$3;
	async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }) {
	    let universalResolverAddress = universalResolverAddress_;
	    if (!universalResolverAddress) {
	        if (!client.chain)
	            throw new Error('client chain not configured. universalResolverAddress is required.');
	        universalResolverAddress = (0, getChainContractAddress_js_1$1.getChainContractAddress)({
	            blockNumber,
	            chain: client.chain,
	            contract: 'ensUniversalResolver',
	        });
	    }
	    const [resolverAddress] = await (0, getAction_js_1$a.getAction)(client, readContract_js_1$3.readContract, 'readContract')({
	        address: universalResolverAddress,
	        abi: [
	            {
	                inputs: [{ type: 'bytes' }],
	                name: 'findResolver',
	                outputs: [{ type: 'address' }, { type: 'bytes32' }],
	                stateMutability: 'view',
	                type: 'function',
	            },
	        ],
	        functionName: 'findResolver',
	        args: [(0, toHex_js_1$u.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
	        blockNumber,
	        blockTag,
	    });
	    return resolverAddress;
	}

	var createBlockFilter$1 = {};

	Object.defineProperty(createBlockFilter$1, "__esModule", { value: true });
	createBlockFilter$1.createBlockFilter = createBlockFilter;
	const createFilterRequestScope_js_1$2 = createFilterRequestScope$1;
	async function createBlockFilter(client) {
	    const getRequest = (0, createFilterRequestScope_js_1$2.createFilterRequestScope)(client, {
	        method: 'eth_newBlockFilter',
	    });
	    const id = await client.request({
	        method: 'eth_newBlockFilter',
	    });
	    return { id, request: getRequest(id), type: 'block' };
	}

	var createEventFilter$1 = {};

	Object.defineProperty(createEventFilter$1, "__esModule", { value: true });
	createEventFilter$1.createEventFilter = createEventFilter;
	const encodeEventTopics_js_1$1 = encodeEventTopics$1;
	const toHex_js_1$t = requireToHex();
	const createFilterRequestScope_js_1$1 = createFilterRequestScope$1;
	async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock, } = {}) {
	    const events = events_ ?? (event ? [event] : undefined);
	    const getRequest = (0, createFilterRequestScope_js_1$1.createFilterRequestScope)(client, {
	        method: 'eth_newFilter',
	    });
	    let topics = [];
	    if (events) {
	        const encoded = events.flatMap((event) => (0, encodeEventTopics_js_1$1.encodeEventTopics)({
	            abi: [event],
	            eventName: event.name,
	            args,
	        }));
	        topics = [encoded];
	        if (event)
	            topics = topics[0];
	    }
	    const id = await client.request({
	        method: 'eth_newFilter',
	        params: [
	            {
	                address,
	                fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1$t.numberToHex)(fromBlock) : fromBlock,
	                toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1$t.numberToHex)(toBlock) : toBlock,
	                ...(topics.length ? { topics } : {}),
	            },
	        ],
	    });
	    return {
	        abi: events,
	        args,
	        eventName: event ? event.name : undefined,
	        fromBlock,
	        id,
	        request: getRequest(id),
	        strict: Boolean(strict),
	        toBlock,
	        type: 'event',
	    };
	}

	var createPendingTransactionFilter$1 = {};

	Object.defineProperty(createPendingTransactionFilter$1, "__esModule", { value: true });
	createPendingTransactionFilter$1.createPendingTransactionFilter = createPendingTransactionFilter;
	const createFilterRequestScope_js_1 = createFilterRequestScope$1;
	async function createPendingTransactionFilter(client) {
	    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
	        method: 'eth_newPendingTransactionFilter',
	    });
	    const id = await client.request({
	        method: 'eth_newPendingTransactionFilter',
	    });
	    return { id, request: getRequest(id), type: 'transaction' };
	}

	var getBlobBaseFee$1 = {};

	Object.defineProperty(getBlobBaseFee$1, "__esModule", { value: true });
	getBlobBaseFee$1.getBlobBaseFee = getBlobBaseFee;
	async function getBlobBaseFee(client) {
	    const baseFee = await client.request({
	        method: 'eth_blobBaseFee',
	    });
	    return BigInt(baseFee);
	}

	var getBlockTransactionCount$1 = {};

	Object.defineProperty(getBlockTransactionCount$1, "__esModule", { value: true });
	getBlockTransactionCount$1.getBlockTransactionCount = getBlockTransactionCount;
	const fromHex_js_1$7 = requireFromHex();
	const toHex_js_1$s = requireToHex();
	async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = 'latest', } = {}) {
	    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1$s.numberToHex)(blockNumber) : undefined;
	    let count;
	    if (blockHash) {
	        count = await client.request({
	            method: 'eth_getBlockTransactionCountByHash',
	            params: [blockHash],
	        }, { dedupe: true });
	    }
	    else {
	        count = await client.request({
	            method: 'eth_getBlockTransactionCountByNumber',
	            params: [blockNumberHex || blockTag],
	        }, { dedupe: Boolean(blockNumberHex) });
	    }
	    return (0, fromHex_js_1$7.hexToNumber)(count);
	}

	var getCode$1 = {};

	Object.defineProperty(getCode$1, "__esModule", { value: true });
	getCode$1.getCode = getCode;
	const toHex_js_1$r = requireToHex();
	async function getCode(client, { address, blockNumber, blockTag = 'latest' }) {
	    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1$r.numberToHex)(blockNumber) : undefined;
	    const hex = await client.request({
	        method: 'eth_getCode',
	        params: [address, blockNumberHex || blockTag],
	    }, { dedupe: Boolean(blockNumberHex) });
	    if (hex === '0x')
	        return undefined;
	    return hex;
	}

	var getEip712Domain$1 = {};

	var eip712 = {};

	Object.defineProperty(eip712, "__esModule", { value: true });
	eip712.Eip712DomainNotFoundError = void 0;
	const base_js_1$4 = base$1;
	class Eip712DomainNotFoundError extends base_js_1$4.BaseError {
	    constructor({ address }) {
	        super(`No EIP-712 domain found on contract "${address}".`, {
	            metaMessages: [
	                'Ensure that:',
	                `- The contract is deployed at the address "${address}".`,
	                '- `eip712Domain()` function exists on the contract.',
	                '- `eip712Domain()` function matches signature to ERC-5267 specification.',
	            ],
	            name: 'Eip712DomainNotFoundError',
	        });
	    }
	}
	eip712.Eip712DomainNotFoundError = Eip712DomainNotFoundError;

	Object.defineProperty(getEip712Domain$1, "__esModule", { value: true });
	getEip712Domain$1.getEip712Domain = getEip712Domain;
	const eip712_js_1 = eip712;
	const getAction_js_1$9 = getAction$1;
	const readContract_js_1$2 = readContract$3;
	async function getEip712Domain(client, parameters) {
	    const { address, factory, factoryData } = parameters;
	    try {
	        const [fields, name, version, chainId, verifyingContract, salt, extensions,] = await (0, getAction_js_1$9.getAction)(client, readContract_js_1$2.readContract, 'readContract')({
	            abi,
	            address,
	            functionName: 'eip712Domain',
	            factory,
	            factoryData,
	        });
	        return {
	            domain: {
	                name,
	                version,
	                chainId: Number(chainId),
	                verifyingContract,
	                salt,
	            },
	            extensions,
	            fields,
	        };
	    }
	    catch (e) {
	        const error = e;
	        if (error.name === 'ContractFunctionExecutionError' &&
	            error.cause.name === 'ContractFunctionZeroDataError') {
	            throw new eip712_js_1.Eip712DomainNotFoundError({ address });
	        }
	        throw error;
	    }
	}
	const abi = [
	    {
	        inputs: [],
	        name: 'eip712Domain',
	        outputs: [
	            { name: 'fields', type: 'bytes1' },
	            { name: 'name', type: 'string' },
	            { name: 'version', type: 'string' },
	            { name: 'chainId', type: 'uint256' },
	            { name: 'verifyingContract', type: 'address' },
	            { name: 'salt', type: 'bytes32' },
	            { name: 'extensions', type: 'uint256[]' },
	        ],
	        stateMutability: 'view',
	        type: 'function',
	    },
	];

	var getFeeHistory$1 = {};

	var feeHistory = {};

	Object.defineProperty(feeHistory, "__esModule", { value: true });
	feeHistory.formatFeeHistory = formatFeeHistory;
	function formatFeeHistory(feeHistory) {
	    return {
	        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
	        gasUsedRatio: feeHistory.gasUsedRatio,
	        oldestBlock: BigInt(feeHistory.oldestBlock),
	        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value))),
	    };
	}

	Object.defineProperty(getFeeHistory$1, "__esModule", { value: true });
	getFeeHistory$1.getFeeHistory = getFeeHistory;
	const toHex_js_1$q = requireToHex();
	const feeHistory_js_1 = feeHistory;
	async function getFeeHistory(client, { blockCount, blockNumber, blockTag = 'latest', rewardPercentiles, }) {
	    const blockNumberHex = blockNumber ? (0, toHex_js_1$q.numberToHex)(blockNumber) : undefined;
	    const feeHistory = await client.request({
	        method: 'eth_feeHistory',
	        params: [
	            (0, toHex_js_1$q.numberToHex)(blockCount),
	            blockNumberHex || blockTag,
	            rewardPercentiles,
	        ],
	    }, { dedupe: Boolean(blockNumberHex) });
	    return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
	}

	var getFilterLogs$1 = {};

	Object.defineProperty(getFilterLogs$1, "__esModule", { value: true });
	getFilterLogs$1.getFilterLogs = getFilterLogs;
	const parseEventLogs_js_1 = parseEventLogs$2;
	const log_js_1$1 = log;
	async function getFilterLogs(_client, { filter, }) {
	    const strict = filter.strict ?? false;
	    const logs = await filter.request({
	        method: 'eth_getFilterLogs',
	        params: [filter.id],
	    });
	    const formattedLogs = logs.map((log) => (0, log_js_1$1.formatLog)(log));
	    if (!filter.abi)
	        return formattedLogs;
	    return (0, parseEventLogs_js_1.parseEventLogs)({
	        abi: filter.abi,
	        logs: formattedLogs,
	        strict,
	    });
	}

	var getProof$1 = {};

	var proof = {};

	var utils$2 = {};

	var defineChain$1 = {};

	Object.defineProperty(defineChain$1, "__esModule", { value: true });
	defineChain$1.defineChain = defineChain;
	function defineChain(chain) {
	    return {
	        formatters: undefined,
	        fees: undefined,
	        serializers: undefined,
	        ...chain,
	    };
	}

	var extractChain$1 = {};

	Object.defineProperty(extractChain$1, "__esModule", { value: true });
	extractChain$1.extractChain = extractChain;
	function extractChain({ chains, id, }) {
	    return chains.find((chain) => chain.id === id);
	}

	var regex = {};

	Object.defineProperty(regex, "__esModule", { value: true });
	regex.integerRegex = regex.bytesRegex = regex.arrayRegex = void 0;
	regex.arrayRegex = /^(.*)\[([0-9]*)\]$/;
	regex.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
	regex.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

	var compat = {};

	var webSocket$3 = {};

	var socket = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.socketClientCache = void 0;
		exports.getSocketRpcClient = getSocketRpcClient;
		const request_js_1 = request;
		const createBatchScheduler_js_1 = createBatchScheduler$1;
		const withTimeout_js_1 = withTimeout$1;
		const id_js_1 = id;
		exports.socketClientCache = new Map();
		async function getSocketRpcClient(parameters) {
		    const { getSocket, keepAlive = true, key = 'socket', reconnect = true, url, } = parameters;
		    const { interval: keepAliveInterval = 30_000 } = typeof keepAlive === 'object' ? keepAlive : {};
		    const { attempts = 5, delay = 2_000 } = typeof reconnect === 'object' ? reconnect : {};
		    let socketClient = exports.socketClientCache.get(`${key}:${url}`);
		    if (socketClient)
		        return socketClient;
		    let reconnectCount = 0;
		    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
		        id: `${key}:${url}`,
		        fn: async () => {
		            const requests = new Map();
		            const subscriptions = new Map();
		            let error;
		            let socket;
		            let keepAliveTimer;
		            async function setup() {
		                const result = await getSocket({
		                    onClose() {
		                        for (const request of requests.values())
		                            request.onError?.(new request_js_1.SocketClosedError({ url }));
		                        for (const subscription of subscriptions.values())
		                            subscription.onError?.(new request_js_1.SocketClosedError({ url }));
		                        requests.clear();
		                        subscriptions.clear();
		                        if (reconnect && reconnectCount < attempts)
		                            setTimeout(async () => {
		                                reconnectCount++;
		                                await setup().catch(console.error);
		                            }, delay);
		                    },
		                    onError(error_) {
		                        error = error_;
		                        for (const request of requests.values())
		                            request.onError?.(error);
		                        for (const subscription of subscriptions.values())
		                            subscription.onError?.(error);
		                        requests.clear();
		                        subscriptions.clear();
		                        if (reconnect && reconnectCount < attempts)
		                            setTimeout(async () => {
		                                reconnectCount++;
		                                await setup().catch(console.error);
		                            }, delay);
		                    },
		                    onOpen() {
		                        error = undefined;
		                        reconnectCount = 0;
		                    },
		                    onResponse(data) {
		                        const isSubscription = data.method === 'eth_subscription';
		                        const id = isSubscription ? data.params.subscription : data.id;
		                        const cache = isSubscription ? subscriptions : requests;
		                        const callback = cache.get(id);
		                        if (callback)
		                            callback.onResponse(data);
		                        if (!isSubscription)
		                            cache.delete(id);
		                    },
		                });
		                socket = result;
		                if (keepAlive) {
		                    if (keepAliveTimer)
		                        clearInterval(keepAliveTimer);
		                    keepAliveTimer = setInterval(() => socket.ping?.(), keepAliveInterval);
		                }
		                return result;
		            }
		            await setup();
		            error = undefined;
		            socketClient = {
		                close() {
		                    keepAliveTimer && clearInterval(keepAliveTimer);
		                    socket.close();
		                    exports.socketClientCache.delete(`${key}:${url}`);
		                },
		                get socket() {
		                    return socket;
		                },
		                request({ body, onError, onResponse }) {
		                    if (error && onError)
		                        onError(error);
		                    const id = body.id ?? id_js_1.idCache.take();
		                    const callback = (response) => {
		                        if (typeof response.id === 'number' && id !== response.id)
		                            return;
		                        if (body.method === 'eth_subscribe' &&
		                            typeof response.result === 'string')
		                            subscriptions.set(response.result, {
		                                onResponse: callback,
		                                onError,
		                            });
		                        if (body.method === 'eth_unsubscribe')
		                            subscriptions.delete(body.params?.[0]);
		                        onResponse(response);
		                    };
		                    requests.set(id, { onResponse: callback, onError });
		                    try {
		                        socket.request({
		                            body: {
		                                jsonrpc: '2.0',
		                                id,
		                                ...body,
		                            },
		                        });
		                    }
		                    catch (error) {
		                        onError?.(error);
		                    }
		                },
		                requestAsync({ body, timeout = 10_000 }) {
		                    return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse, onError) => this.request({
		                        body,
		                        onError,
		                        onResponse,
		                    })), {
		                        errorInstance: new request_js_1.TimeoutError({ body, url }),
		                        timeout,
		                    });
		                },
		                requests,
		                subscriptions,
		                url,
		            };
		            exports.socketClientCache.set(`${key}:${url}`, socketClient);
		            return [socketClient];
		        },
		    });
		    const [_, [socketClient_]] = await schedule();
		    return socketClient_;
		}
		
	} (socket));

	function getNativeWebSocket() {
	    if (typeof WebSocket !== "undefined")
	        return WebSocket;
	    if (typeof global.WebSocket !== "undefined")
	        return global.WebSocket;
	    if (typeof window.WebSocket !== "undefined")
	        return window.WebSocket;
	    if (typeof self.WebSocket !== "undefined")
	        return self.WebSocket;
	    throw new Error("`WebSocket` is not supported in this environment");
	}

	const WebSocket$1 = getNativeWebSocket();

	var native = /*#__PURE__*/Object.freeze({
		__proto__: null,
		WebSocket: WebSocket$1
	});

	var require$$2 = /*@__PURE__*/getAugmentedNamespace(native);

	Object.defineProperty(webSocket$3, "__esModule", { value: true });
	webSocket$3.getWebSocketRpcClient = getWebSocketRpcClient;
	const request_js_1$1 = request;
	const socket_js_1 = socket;
	async function getWebSocketRpcClient(url, options = {}) {
	    const { keepAlive, reconnect } = options;
	    return (0, socket_js_1.getSocketRpcClient)({
	        async getSocket({ onClose, onError, onOpen, onResponse }) {
	            const WebSocket = await Promise.resolve().then(() => require$$2).then((module) => module.WebSocket);
	            const socket = new WebSocket(url);
	            function onClose_() {
	                onClose();
	                socket.removeEventListener('close', onClose_);
	                socket.removeEventListener('message', onMessage);
	                socket.removeEventListener('error', onError);
	                socket.removeEventListener('open', onOpen);
	            }
	            function onMessage({ data }) {
	                onResponse(JSON.parse(data));
	            }
	            socket.addEventListener('close', onClose_);
	            socket.addEventListener('message', onMessage);
	            socket.addEventListener('error', onError);
	            socket.addEventListener('open', onOpen);
	            if (socket.readyState === WebSocket.CONNECTING) {
	                await new Promise((resolve, reject) => {
	                    if (!socket)
	                        return;
	                    socket.onopen = resolve;
	                    socket.onerror = reject;
	                });
	            }
	            const { close: close_ } = socket;
	            return Object.assign(socket, {
	                close() {
	                    close_.bind(socket)();
	                    onClose();
	                },
	                ping() {
	                    try {
	                        if (socket.readyState === socket.CLOSED ||
	                            socket.readyState === socket.CLOSING)
	                            throw new request_js_1$1.WebSocketRequestError({
	                                url: socket.url,
	                                cause: new request_js_1$1.SocketClosedError({ url: socket.url }),
	                            });
	                        const body = {
	                            jsonrpc: '2.0',
	                            method: 'net_version',
	                            params: [],
	                        };
	                        socket.send(JSON.stringify(body));
	                    }
	                    catch (error) {
	                        onError(error);
	                    }
	                },
	                request({ body }) {
	                    if (socket.readyState === socket.CLOSED ||
	                        socket.readyState === socket.CLOSING)
	                        throw new request_js_1$1.WebSocketRequestError({
	                            body,
	                            url: socket.url,
	                            cause: new request_js_1$1.SocketClosedError({ url: socket.url }),
	                        });
	                    return socket.send(JSON.stringify(body));
	                },
	            });
	        },
	        keepAlive,
	        reconnect,
	        url,
	    });
	}

	Object.defineProperty(compat, "__esModule", { value: true });
	compat.rpc = void 0;
	compat.getSocket = getSocket;
	const http_js_1 = http$1;
	const webSocket_js_1$1 = webSocket$3;
	function webSocket$2(socketClient, { body, onError, onResponse }) {
	    socketClient.request({
	        body,
	        onError,
	        onResponse,
	    });
	    return socketClient;
	}
	async function webSocketAsync(socketClient, { body, timeout = 10_000 }) {
	    return socketClient.requestAsync({
	        body,
	        timeout,
	    });
	}
	async function getSocket(url) {
	    const client = await (0, webSocket_js_1$1.getWebSocketRpcClient)(url);
	    return Object.assign(client.socket, {
	        requests: client.requests,
	        subscriptions: client.subscriptions,
	    });
	}
	compat.rpc = {
	    http(url, params) {
	        return (0, http_js_1.getHttpRpcClient)(url).request(params);
	    },
	    webSocket: webSocket$2,
	    webSocketAsync,
	};

	var typedData = {};

	var hashTypedData = {};

	var hasRequiredHashTypedData;

	function requireHashTypedData () {
		if (hasRequiredHashTypedData) return hashTypedData;
		hasRequiredHashTypedData = 1;
		Object.defineProperty(hashTypedData, "__esModule", { value: true });
		hashTypedData.hashTypedData = hashTypedData$1;
		hashTypedData.hashDomain = hashDomain;
		hashTypedData.hashStruct = hashStruct;
		hashTypedData.encodeType = encodeType;
		const encodeAbiParameters_js_1 = encodeAbiParameters$3;
		const concat_js_1 = concat$1;
		const toHex_js_1 = requireToHex();
		const keccak256_js_1 = keccak256$3;
		const typedData_js_1 = requireTypedData();
		function hashTypedData$1(parameters) {
		    const { domain = {}, message, primaryType, } = parameters;
		    const types = {
		        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
		        ...parameters.types,
		    };
		    (0, typedData_js_1.validateTypedData)({
		        domain,
		        message,
		        primaryType,
		        types,
		    });
		    const parts = ['0x1901'];
		    if (domain)
		        parts.push(hashDomain({
		            domain,
		            types: types,
		        }));
		    if (primaryType !== 'EIP712Domain')
		        parts.push(hashStruct({
		            data: message,
		            primaryType,
		            types: types,
		        }));
		    return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
		}
		function hashDomain({ domain, types, }) {
		    return hashStruct({
		        data: domain,
		        primaryType: 'EIP712Domain',
		        types,
		    });
		}
		function hashStruct({ data, primaryType, types, }) {
		    const encoded = encodeData({
		        data,
		        primaryType,
		        types,
		    });
		    return (0, keccak256_js_1.keccak256)(encoded);
		}
		function encodeData({ data, primaryType, types, }) {
		    const encodedTypes = [{ type: 'bytes32' }];
		    const encodedValues = [hashType({ primaryType, types })];
		    for (const field of types[primaryType]) {
		        const [type, value] = encodeField({
		            types,
		            name: field.name,
		            type: field.type,
		            value: data[field.name],
		        });
		        encodedTypes.push(type);
		        encodedValues.push(value);
		    }
		    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
		}
		function hashType({ primaryType, types, }) {
		    const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
		    return (0, keccak256_js_1.keccak256)(encodedHashType);
		}
		function encodeType({ primaryType, types, }) {
		    let result = '';
		    const unsortedDeps = findTypeDependencies({ primaryType, types });
		    unsortedDeps.delete(primaryType);
		    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
		    for (const type of deps) {
		        result += `${type}(${types[type]
	            .map(({ name, type: t }) => `${t} ${name}`)
	            .join(',')})`;
		    }
		    return result;
		}
		function findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {
		    const match = primaryType_.match(/^\w*/u);
		    const primaryType = match?.[0];
		    if (results.has(primaryType) || types[primaryType] === undefined) {
		        return results;
		    }
		    results.add(primaryType);
		    for (const field of types[primaryType]) {
		        findTypeDependencies({ primaryType: field.type, types }, results);
		    }
		    return results;
		}
		function encodeField({ types, name, type, value, }) {
		    if (types[type] !== undefined) {
		        return [
		            { type: 'bytes32' },
		            (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types })),
		        ];
		    }
		    if (type === 'bytes') {
		        const prepend = value.length % 2 ? '0' : '';
		        value = `0x${prepend + value.slice(2)}`;
		        return [{ type: 'bytes32' }, (0, keccak256_js_1.keccak256)(value)];
		    }
		    if (type === 'string')
		        return [{ type: 'bytes32' }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
		    if (type.lastIndexOf(']') === type.length - 1) {
		        const parsedType = type.slice(0, type.lastIndexOf('['));
		        const typeValuePairs = value.map((item) => encodeField({
		            name,
		            type: parsedType,
		            types,
		            value: item,
		        }));
		        return [
		            { type: 'bytes32' },
		            (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
		        ];
		    }
		    return [{ type }, value];
		}
		
		return hashTypedData;
	}

	var hasRequiredTypedData;

	function requireTypedData () {
		if (hasRequiredTypedData) return typedData;
		hasRequiredTypedData = 1;
		Object.defineProperty(typedData, "__esModule", { value: true });
		typedData.serializeTypedData = serializeTypedData;
		typedData.validateTypedData = validateTypedData;
		typedData.getTypesForEIP712Domain = getTypesForEIP712Domain;
		typedData.domainSeparator = domainSeparator;
		const abi_js_1 = requireAbi();
		const address_js_1 = address$2;
		const isAddress_js_1 = requireIsAddress();
		const size_js_1 = size$2;
		const toHex_js_1 = requireToHex();
		const regex_js_1 = regex;
		const hashTypedData_js_1 = requireHashTypedData();
		const stringify_js_1 = stringify$1;
		function serializeTypedData(parameters) {
		    const { domain: domain_, message: message_, primaryType, types, } = parameters;
		    const normalizeData = (struct, data_) => {
		        const data = { ...data_ };
		        for (const param of struct) {
		            const { name, type } = param;
		            if (type === 'address')
		                data[name] = data[name].toLowerCase();
		        }
		        return data;
		    };
		    const domain = (() => {
		        if (!types.EIP712Domain)
		            return {};
		        if (!domain_)
		            return {};
		        return normalizeData(types.EIP712Domain, domain_);
		    })();
		    const message = (() => {
		        if (primaryType === 'EIP712Domain')
		            return undefined;
		        return normalizeData(types[primaryType], message_);
		    })();
		    return (0, stringify_js_1.stringify)({ domain, message, primaryType, types });
		}
		function validateTypedData(parameters) {
		    const { domain, message, primaryType, types } = parameters;
		    const validateData = (struct, data) => {
		        for (const param of struct) {
		            const { name, type } = param;
		            const value = data[name];
		            const integerMatch = type.match(regex_js_1.integerRegex);
		            if (integerMatch &&
		                (typeof value === 'number' || typeof value === 'bigint')) {
		                const [_type, base, size_] = integerMatch;
		                (0, toHex_js_1.numberToHex)(value, {
		                    signed: base === 'int',
		                    size: Number.parseInt(size_) / 8,
		                });
		            }
		            if (type === 'address' && typeof value === 'string' && !(0, isAddress_js_1.isAddress)(value))
		                throw new address_js_1.InvalidAddressError({ address: value });
		            const bytesMatch = type.match(regex_js_1.bytesRegex);
		            if (bytesMatch) {
		                const [_type, size_] = bytesMatch;
		                if (size_ && (0, size_js_1.size)(value) !== Number.parseInt(size_))
		                    throw new abi_js_1.BytesSizeMismatchError({
		                        expectedSize: Number.parseInt(size_),
		                        givenSize: (0, size_js_1.size)(value),
		                    });
		            }
		            const struct = types[type];
		            if (struct)
		                validateData(struct, value);
		        }
		    };
		    if (types.EIP712Domain && domain)
		        validateData(types.EIP712Domain, domain);
		    if (primaryType !== 'EIP712Domain')
		        validateData(types[primaryType], message);
		}
		function getTypesForEIP712Domain({ domain, }) {
		    return [
		        typeof domain?.name === 'string' && { name: 'name', type: 'string' },
		        domain?.version && { name: 'version', type: 'string' },
		        typeof domain?.chainId === 'number' && {
		            name: 'chainId',
		            type: 'uint256',
		        },
		        domain?.verifyingContract && {
		            name: 'verifyingContract',
		            type: 'address',
		        },
		        domain?.salt && { name: 'salt', type: 'bytes32' },
		    ].filter(Boolean);
		}
		function domainSeparator({ domain }) {
		    return (0, hashTypedData_js_1.hashDomain)({
		        domain,
		        types: {
		            EIP712Domain: getTypesForEIP712Domain({ domain }),
		        },
		    });
		}
		
		return typedData;
	}

	var decodeFunctionData$1 = {};

	Object.defineProperty(decodeFunctionData$1, "__esModule", { value: true });
	decodeFunctionData$1.decodeFunctionData = decodeFunctionData;
	const abi_js_1$6 = requireAbi();
	const slice_js_1$4 = slice$1;
	const toFunctionSelector_js_1$1 = toFunctionSelector$1;
	const decodeAbiParameters_js_1$2 = decodeAbiParameters$1;
	const formatAbiItem_js_1$1 = requireFormatAbiItem();
	function decodeFunctionData(parameters) {
	    const { abi, data } = parameters;
	    const signature = (0, slice_js_1$4.slice)(data, 0, 4);
	    const description = abi.find((x) => x.type === 'function' &&
	        signature === (0, toFunctionSelector_js_1$1.toFunctionSelector)((0, formatAbiItem_js_1$1.formatAbiItem)(x)));
	    if (!description)
	        throw new abi_js_1$6.AbiFunctionSignatureNotFoundError(signature, {
	            docsPath: '/docs/contract/decodeFunctionData',
	        });
	    return {
	        functionName: description.name,
	        args: ('inputs' in description &&
	            description.inputs &&
	            description.inputs.length > 0
	            ? (0, decodeAbiParameters_js_1$2.decodeAbiParameters)(description.inputs, (0, slice_js_1$4.slice)(data, 4))
	            : undefined),
	    };
	}

	var encodeErrorResult$1 = {};

	Object.defineProperty(encodeErrorResult$1, "__esModule", { value: true });
	encodeErrorResult$1.encodeErrorResult = encodeErrorResult;
	const abi_js_1$5 = requireAbi();
	const concat_js_1$4 = concat$1;
	const toFunctionSelector_js_1 = toFunctionSelector$1;
	const encodeAbiParameters_js_1$5 = encodeAbiParameters$3;
	const formatAbiItem_js_1 = requireFormatAbiItem();
	const getAbiItem_js_1$1 = getAbiItem$1;
	const docsPath$2 = '/docs/contract/encodeErrorResult';
	function encodeErrorResult(parameters) {
	    const { abi, errorName, args } = parameters;
	    let abiItem = abi[0];
	    if (errorName) {
	        const item = (0, getAbiItem_js_1$1.getAbiItem)({ abi, args, name: errorName });
	        if (!item)
	            throw new abi_js_1$5.AbiErrorNotFoundError(errorName, { docsPath: docsPath$2 });
	        abiItem = item;
	    }
	    if (abiItem.type !== 'error')
	        throw new abi_js_1$5.AbiErrorNotFoundError(undefined, { docsPath: docsPath$2 });
	    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
	    const signature = (0, toFunctionSelector_js_1.toFunctionSelector)(definition);
	    let data = '0x';
	    if (args && args.length > 0) {
	        if (!abiItem.inputs)
	            throw new abi_js_1$5.AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath$2 });
	        data = (0, encodeAbiParameters_js_1$5.encodeAbiParameters)(abiItem.inputs, args);
	    }
	    return (0, concat_js_1$4.concatHex)([signature, data]);
	}

	var encodeFunctionResult$1 = {};

	Object.defineProperty(encodeFunctionResult$1, "__esModule", { value: true });
	encodeFunctionResult$1.encodeFunctionResult = encodeFunctionResult;
	const abi_js_1$4 = requireAbi();
	const encodeAbiParameters_js_1$4 = encodeAbiParameters$3;
	const getAbiItem_js_1 = getAbiItem$1;
	const docsPath$1 = '/docs/contract/encodeFunctionResult';
	function encodeFunctionResult(parameters) {
	    const { abi, functionName, result } = parameters;
	    let abiItem = abi[0];
	    if (functionName) {
	        const item = (0, getAbiItem_js_1.getAbiItem)({ abi, name: functionName });
	        if (!item)
	            throw new abi_js_1$4.AbiFunctionNotFoundError(functionName, { docsPath: docsPath$1 });
	        abiItem = item;
	    }
	    if (abiItem.type !== 'function')
	        throw new abi_js_1$4.AbiFunctionNotFoundError(undefined, { docsPath: docsPath$1 });
	    if (!abiItem.outputs)
	        throw new abi_js_1$4.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$1 });
	    let values = Array.isArray(result) ? result : [result];
	    if (abiItem.outputs.length === 0 && !values[0])
	        values = [];
	    return (0, encodeAbiParameters_js_1$4.encodeAbiParameters)(abiItem.outputs, values);
	}

	var encodePacked$1 = {};

	Object.defineProperty(encodePacked$1, "__esModule", { value: true });
	encodePacked$1.encodePacked = encodePacked;
	const abi_js_1$3 = requireAbi();
	const address_js_1$4 = address$2;
	const isAddress_js_1$3 = requireIsAddress();
	const concat_js_1$3 = concat$1;
	const pad_js_1$2 = pad$1;
	const toHex_js_1$p = requireToHex();
	const regex_js_1 = regex;
	function encodePacked(types, values) {
	    if (types.length !== values.length)
	        throw new abi_js_1$3.AbiEncodingLengthMismatchError({
	            expectedLength: types.length,
	            givenLength: values.length,
	        });
	    const data = [];
	    for (let i = 0; i < types.length; i++) {
	        const type = types[i];
	        const value = values[i];
	        data.push(encode$3(type, value));
	    }
	    return (0, concat_js_1$3.concatHex)(data);
	}
	function encode$3(type, value, isArray = false) {
	    if (type === 'address') {
	        const address = value;
	        if (!(0, isAddress_js_1$3.isAddress)(address))
	            throw new address_js_1$4.InvalidAddressError({ address });
	        return (0, pad_js_1$2.pad)(address.toLowerCase(), {
	            size: isArray ? 32 : null,
	        });
	    }
	    if (type === 'string')
	        return (0, toHex_js_1$p.stringToHex)(value);
	    if (type === 'bytes')
	        return value;
	    if (type === 'bool')
	        return (0, pad_js_1$2.pad)((0, toHex_js_1$p.boolToHex)(value), { size: isArray ? 32 : 1 });
	    const intMatch = type.match(regex_js_1.integerRegex);
	    if (intMatch) {
	        const [_type, baseType, bits = '256'] = intMatch;
	        const size = Number.parseInt(bits) / 8;
	        return (0, toHex_js_1$p.numberToHex)(value, {
	            size: isArray ? 32 : size,
	            signed: baseType === 'int',
	        });
	    }
	    const bytesMatch = type.match(regex_js_1.bytesRegex);
	    if (bytesMatch) {
	        const [_type, size] = bytesMatch;
	        if (Number.parseInt(size) !== (value.length - 2) / 2)
	            throw new abi_js_1$3.BytesSizeMismatchError({
	                expectedSize: Number.parseInt(size),
	                givenSize: (value.length - 2) / 2,
	            });
	        return (0, pad_js_1$2.pad)(value, { dir: 'right', size: isArray ? 32 : null });
	    }
	    const arrayMatch = type.match(regex_js_1.arrayRegex);
	    if (arrayMatch && Array.isArray(value)) {
	        const [_type, childType] = arrayMatch;
	        const data = [];
	        for (let i = 0; i < value.length; i++) {
	            data.push(encode$3(childType, value[i], true));
	        }
	        if (data.length === 0)
	            return '0x';
	        return (0, concat_js_1$3.concatHex)(data);
	    }
	    throw new abi_js_1$3.UnsupportedPackedAbiType(type);
	}

	var getContractAddress$1 = {};

	var isBytes$1 = {};

	Object.defineProperty(isBytes$1, "__esModule", { value: true });
	isBytes$1.isBytes = isBytes;
	function isBytes(value) {
	    if (!value)
	        return false;
	    if (typeof value !== 'object')
	        return false;
	    if (!('BYTES_PER_ELEMENT' in value))
	        return false;
	    return (value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array');
	}

	Object.defineProperty(getContractAddress$1, "__esModule", { value: true });
	getContractAddress$1.getContractAddress = getContractAddress;
	getContractAddress$1.getCreateAddress = getCreateAddress;
	getContractAddress$1.getCreate2Address = getCreate2Address;
	const concat_js_1$2 = concat$1;
	const isBytes_js_1 = isBytes$1;
	const pad_js_1$1 = pad$1;
	const slice_js_1$3 = slice$1;
	const toBytes_js_1$8 = requireToBytes();
	const toRlp_js_1 = toRlp$1;
	const keccak256_js_1$4 = keccak256$3;
	const getAddress_js_1$6 = requireGetAddress();
	function getContractAddress(opts) {
	    if (opts.opcode === 'CREATE2')
	        return getCreate2Address(opts);
	    return getCreateAddress(opts);
	}
	function getCreateAddress(opts) {
	    const from = (0, toBytes_js_1$8.toBytes)((0, getAddress_js_1$6.getAddress)(opts.from));
	    let nonce = (0, toBytes_js_1$8.toBytes)(opts.nonce);
	    if (nonce[0] === 0)
	        nonce = new Uint8Array([]);
	    return (0, getAddress_js_1$6.getAddress)(`0x${(0, keccak256_js_1$4.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], 'bytes')).slice(26)}`);
	}
	function getCreate2Address(opts) {
	    const from = (0, toBytes_js_1$8.toBytes)((0, getAddress_js_1$6.getAddress)(opts.from));
	    const salt = (0, pad_js_1$1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1$8.toBytes)(opts.salt), {
	        size: 32,
	    });
	    const bytecodeHash = (() => {
	        if ('bytecodeHash' in opts) {
	            if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash))
	                return opts.bytecodeHash;
	            return (0, toBytes_js_1$8.toBytes)(opts.bytecodeHash);
	        }
	        return (0, keccak256_js_1$4.keccak256)(opts.bytecode, 'bytes');
	    })();
	    return (0, getAddress_js_1$6.getAddress)((0, slice_js_1$3.slice)((0, keccak256_js_1$4.keccak256)((0, concat_js_1$2.concat)([(0, toBytes_js_1$8.toBytes)('0xff'), from, salt, bytecodeHash])), 12));
	}

	var transactionReceipt = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.defineTransactionReceipt = exports.receiptStatuses = void 0;
		exports.formatTransactionReceipt = formatTransactionReceipt;
		const fromHex_js_1 = requireFromHex();
		const formatter_js_1 = formatter;
		const log_js_1 = log;
		const transaction_js_1 = transaction;
		exports.receiptStatuses = {
		    '0x0': 'reverted',
		    '0x1': 'success',
		};
		function formatTransactionReceipt(transactionReceipt) {
		    const receipt = {
		        ...transactionReceipt,
		        blockNumber: transactionReceipt.blockNumber
		            ? BigInt(transactionReceipt.blockNumber)
		            : null,
		        contractAddress: transactionReceipt.contractAddress
		            ? transactionReceipt.contractAddress
		            : null,
		        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed
		            ? BigInt(transactionReceipt.cumulativeGasUsed)
		            : null,
		        effectiveGasPrice: transactionReceipt.effectiveGasPrice
		            ? BigInt(transactionReceipt.effectiveGasPrice)
		            : null,
		        gasUsed: transactionReceipt.gasUsed
		            ? BigInt(transactionReceipt.gasUsed)
		            : null,
		        logs: transactionReceipt.logs
		            ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log))
		            : null,
		        to: transactionReceipt.to ? transactionReceipt.to : null,
		        transactionIndex: transactionReceipt.transactionIndex
		            ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex)
		            : null,
		        status: transactionReceipt.status
		            ? exports.receiptStatuses[transactionReceipt.status]
		            : null,
		        type: transactionReceipt.type
		            ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type
		            : null,
		    };
		    if (transactionReceipt.blobGasPrice)
		        receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
		    if (transactionReceipt.blobGasUsed)
		        receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
		    return receipt;
		}
		exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)('transactionReceipt', formatTransactionReceipt);
		
	} (transactionReceipt));

	var fromRlp$1 = {};

	Object.defineProperty(fromRlp$1, "__esModule", { value: true });
	fromRlp$1.fromRlp = fromRlp;
	const base_js_1$3 = base$1;
	const encoding_js_1 = encoding;
	const cursor_js_1$1 = cursor$1;
	const toBytes_js_1$7 = requireToBytes();
	const toHex_js_1$o = requireToHex();
	function fromRlp(value, to = 'hex') {
	    const bytes = (() => {
	        if (typeof value === 'string') {
	            if (value.length > 3 && value.length % 2 !== 0)
	                throw new encoding_js_1.InvalidHexValueError(value);
	            return (0, toBytes_js_1$7.hexToBytes)(value);
	        }
	        return value;
	    })();
	    const cursor = (0, cursor_js_1$1.createCursor)(bytes, {
	        recursiveReadLimit: Number.POSITIVE_INFINITY,
	    });
	    const result = fromRlpCursor(cursor, to);
	    return result;
	}
	function fromRlpCursor(cursor, to = 'hex') {
	    if (cursor.bytes.length === 0)
	        return (to === 'hex' ? (0, toHex_js_1$o.bytesToHex)(cursor.bytes) : cursor.bytes);
	    const prefix = cursor.readByte();
	    if (prefix < 0x80)
	        cursor.decrementPosition(1);
	    if (prefix < 0xc0) {
	        const length = readLength(cursor, prefix, 0x80);
	        const bytes = cursor.readBytes(length);
	        return (to === 'hex' ? (0, toHex_js_1$o.bytesToHex)(bytes) : bytes);
	    }
	    const length = readLength(cursor, prefix, 0xc0);
	    return readList(cursor, length, to);
	}
	function readLength(cursor, prefix, offset) {
	    if (offset === 0x80 && prefix < 0x80)
	        return 1;
	    if (prefix <= offset + 55)
	        return prefix - offset;
	    if (prefix === offset + 55 + 1)
	        return cursor.readUint8();
	    if (prefix === offset + 55 + 2)
	        return cursor.readUint16();
	    if (prefix === offset + 55 + 3)
	        return cursor.readUint24();
	    if (prefix === offset + 55 + 4)
	        return cursor.readUint32();
	    throw new base_js_1$3.BaseError('Invalid RLP prefix');
	}
	function readList(cursor, length, to) {
	    const position = cursor.position;
	    const value = [];
	    while (cursor.position - position < length)
	        value.push(fromRlpCursor(cursor, to));
	    return value;
	}

	var toEventSignature = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.toEventSignature = void 0;
		var toSignature_js_1 = toSignature$1;
		Object.defineProperty(exports, "toEventSignature", { enumerable: true, get: function () { return toSignature_js_1.toSignature; } });
		
	} (toEventSignature));

	var toFunctionSignature = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.toFunctionSignature = void 0;
		var toSignature_js_1 = toSignature$1;
		Object.defineProperty(exports, "toFunctionSignature", { enumerable: true, get: function () { return toSignature_js_1.toSignature; } });
		
	} (toFunctionSignature));

	var toEventHash = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.toEventHash = void 0;
		var toSignatureHash_js_1 = toSignatureHash$1;
		Object.defineProperty(exports, "toEventHash", { enumerable: true, get: function () { return toSignatureHash_js_1.toSignatureHash; } });
		
	} (toEventHash));

	var toFunctionHash = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.toFunctionHash = void 0;
		var toSignatureHash_js_1 = toSignatureHash$1;
		Object.defineProperty(exports, "toFunctionHash", { enumerable: true, get: function () { return toSignatureHash_js_1.toSignatureHash; } });
		
	} (toFunctionHash));

	var isHash$1 = {};

	Object.defineProperty(isHash$1, "__esModule", { value: true });
	isHash$1.isHash = isHash;
	const isHex_js_1$4 = isHex$1;
	const size_js_1$2 = size$2;
	function isHash(hash) {
	    return (0, isHex_js_1$4.isHex)(hash) && (0, size_js_1$2.size)(hash) === 32;
	}

	var ripemd160$2 = {};

	var ripemd160$1 = {};

	Object.defineProperty(ripemd160$1, "__esModule", { value: true });
	ripemd160$1.ripemd160 = ripemd160$1.RIPEMD160 = void 0;
	const _md_js_1 = _md;
	const utils_js_1$c = utils$8;
	// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
	// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
	const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
	const Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));
	const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
	let idxL = [Id];
	let idxR = [Pi];
	for (let i = 0; i < 4; i++)
	    for (let j of [idxL, idxR])
	        j.push(j[i].map((k) => Rho[k]));
	const shifts = /* @__PURE__ */ [
	    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
	    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
	    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
	    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
	    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
	].map((i) => new Uint8Array(i));
	const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
	const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
	const Kl = /* @__PURE__ */ new Uint32Array([
	    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
	]);
	const Kr = /* @__PURE__ */ new Uint32Array([
	    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
	]);
	// It's called f() in spec.
	function f(group, x, y, z) {
	    if (group === 0)
	        return x ^ y ^ z;
	    else if (group === 1)
	        return (x & y) | (~x & z);
	    else if (group === 2)
	        return (x | ~y) ^ z;
	    else if (group === 3)
	        return (x & z) | (y & ~z);
	    else
	        return x ^ (y | ~z);
	}
	// Temporary buffer, not used to store anything between runs
	const R_BUF = /* @__PURE__ */ new Uint32Array(16);
	class RIPEMD160 extends _md_js_1.HashMD {
	    constructor() {
	        super(64, 20, 8, true);
	        this.h0 = 0x67452301 | 0;
	        this.h1 = 0xefcdab89 | 0;
	        this.h2 = 0x98badcfe | 0;
	        this.h3 = 0x10325476 | 0;
	        this.h4 = 0xc3d2e1f0 | 0;
	    }
	    get() {
	        const { h0, h1, h2, h3, h4 } = this;
	        return [h0, h1, h2, h3, h4];
	    }
	    set(h0, h1, h2, h3, h4) {
	        this.h0 = h0 | 0;
	        this.h1 = h1 | 0;
	        this.h2 = h2 | 0;
	        this.h3 = h3 | 0;
	        this.h4 = h4 | 0;
	    }
	    process(view, offset) {
	        for (let i = 0; i < 16; i++, offset += 4)
	            R_BUF[i] = view.getUint32(offset, true);
	        // prettier-ignore
	        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
	        // Instead of iterating 0 to 80, we split it into 5 groups
	        // And use the groups in constants, functions, etc. Much simpler
	        for (let group = 0; group < 5; group++) {
	            const rGroup = 4 - group;
	            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
	            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
	            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
	            for (let i = 0; i < 16; i++) {
	                const tl = ((0, utils_js_1$c.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;
	                al = el, el = dl, dl = (0, utils_js_1$c.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
	            }
	            // 2 loops are 10% faster
	            for (let i = 0; i < 16; i++) {
	                const tr = ((0, utils_js_1$c.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;
	                ar = er, er = dr, dr = (0, utils_js_1$c.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
	            }
	        }
	        // Add the compressed chunk to the current hash value
	        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
	    }
	    roundClean() {
	        R_BUF.fill(0);
	    }
	    destroy() {
	        this.destroyed = true;
	        this.buffer.fill(0);
	        this.set(0, 0, 0, 0, 0);
	    }
	}
	ripemd160$1.RIPEMD160 = RIPEMD160;
	/**
	 * RIPEMD-160 - a hash function from 1990s.
	 * @param message - msg that would be hashed
	 */
	ripemd160$1.ripemd160 = (0, utils_js_1$c.wrapConstructor)(() => new RIPEMD160());

	Object.defineProperty(ripemd160$2, "__esModule", { value: true });
	ripemd160$2.ripemd160 = ripemd160;
	const ripemd160_1 = ripemd160$1;
	const isHex_js_1$3 = isHex$1;
	const toBytes_js_1$6 = requireToBytes();
	const toHex_js_1$n = requireToHex();
	function ripemd160(value, to_) {
	    const to = to_ || 'hex';
	    const bytes = (0, ripemd160_1.ripemd160)((0, isHex_js_1$3.isHex)(value, { strict: false }) ? (0, toBytes_js_1$6.toBytes)(value) : value);
	    if (to === 'bytes')
	        return bytes;
	    return (0, toHex_js_1$n.toHex)(bytes);
	}

	var recoverMessageAddress$1 = {};

	var hashMessage$1 = {};

	var toPrefixedMessage$1 = {};

	var strings = {};

	Object.defineProperty(strings, "__esModule", { value: true });
	strings.presignMessagePrefix = void 0;
	strings.presignMessagePrefix = '\x19Ethereum Signed Message:\n';

	Object.defineProperty(toPrefixedMessage$1, "__esModule", { value: true });
	toPrefixedMessage$1.toPrefixedMessage = toPrefixedMessage;
	const strings_js_1 = strings;
	const concat_js_1$1 = concat$1;
	const size_js_1$1 = size$2;
	const toHex_js_1$m = requireToHex();
	function toPrefixedMessage(message_) {
	    const message = (() => {
	        if (typeof message_ === 'string')
	            return (0, toHex_js_1$m.stringToHex)(message_);
	        if (typeof message_.raw === 'string')
	            return message_.raw;
	        return (0, toHex_js_1$m.bytesToHex)(message_.raw);
	    })();
	    const prefix = (0, toHex_js_1$m.stringToHex)(`${strings_js_1.presignMessagePrefix}${(0, size_js_1$1.size)(message)}`);
	    return (0, concat_js_1$1.concat)([prefix, message]);
	}

	Object.defineProperty(hashMessage$1, "__esModule", { value: true });
	hashMessage$1.hashMessage = hashMessage;
	const keccak256_js_1$3 = keccak256$3;
	const toPrefixedMessage_js_1 = toPrefixedMessage$1;
	function hashMessage(message, to_) {
	    return (0, keccak256_js_1$3.keccak256)((0, toPrefixedMessage_js_1.toPrefixedMessage)(message), to_);
	}

	Object.defineProperty(recoverMessageAddress$1, "__esModule", { value: true });
	recoverMessageAddress$1.recoverMessageAddress = recoverMessageAddress;
	const hashMessage_js_1$2 = hashMessage$1;
	const recoverAddress_js_1$4 = recoverAddress$1;
	async function recoverMessageAddress({ message, signature, }) {
	    return (0, recoverAddress_js_1$4.recoverAddress)({ hash: (0, hashMessage_js_1$2.hashMessage)(message), signature });
	}

	var recoverTypedDataAddress$1 = {};

	Object.defineProperty(recoverTypedDataAddress$1, "__esModule", { value: true });
	recoverTypedDataAddress$1.recoverTypedDataAddress = recoverTypedDataAddress;
	const hashTypedData_js_1$1 = requireHashTypedData();
	const recoverAddress_js_1$3 = recoverAddress$1;
	async function recoverTypedDataAddress(parameters) {
	    const { domain, message, primaryType, signature, types } = parameters;
	    return (0, recoverAddress_js_1$3.recoverAddress)({
	        hash: (0, hashTypedData_js_1$1.hashTypedData)({
	            domain,
	            message,
	            primaryType,
	            types,
	        }),
	        signature,
	    });
	}

	var verifyHash$5 = {};

	Object.defineProperty(verifyHash$5, "__esModule", { value: true });
	verifyHash$5.verifyHash = verifyHash$4;
	const getAddress_js_1$5 = requireGetAddress();
	const isAddressEqual_js_1$4 = isAddressEqual$1;
	const recoverAddress_js_1$2 = recoverAddress$1;
	async function verifyHash$4({ address, hash, signature, }) {
	    return (0, isAddressEqual_js_1$4.isAddressEqual)((0, getAddress_js_1$5.getAddress)(address), await (0, recoverAddress_js_1$2.recoverAddress)({ hash, signature }));
	}

	var verifyMessage$3 = {};

	Object.defineProperty(verifyMessage$3, "__esModule", { value: true });
	verifyMessage$3.verifyMessage = verifyMessage$2;
	const getAddress_js_1$4 = requireGetAddress();
	const isAddressEqual_js_1$3 = isAddressEqual$1;
	const recoverMessageAddress_js_1 = recoverMessageAddress$1;
	async function verifyMessage$2({ address, message, signature, }) {
	    return (0, isAddressEqual_js_1$3.isAddressEqual)((0, getAddress_js_1$4.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
	}

	var verifyTypedData$5 = {};

	Object.defineProperty(verifyTypedData$5, "__esModule", { value: true });
	verifyTypedData$5.verifyTypedData = verifyTypedData$4;
	const getAddress_js_1$3 = requireGetAddress();
	const isAddressEqual_js_1$2 = isAddressEqual$1;
	const recoverTypedDataAddress_js_1 = recoverTypedDataAddress$1;
	async function verifyTypedData$4(parameters) {
	    const { address, domain, message, primaryType, signature, types } = parameters;
	    return (0, isAddressEqual_js_1$2.isAddressEqual)((0, getAddress_js_1$3.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
	        domain,
	        message,
	        primaryType,
	        signature,
	        types,
	    }));
	}

	var parseErc6492Signature$1 = {};

	var isErc6492Signature$3 = {};

	var bytes = {};

	Object.defineProperty(bytes, "__esModule", { value: true });
	bytes.zeroHash = bytes.erc6492MagicBytes = void 0;
	bytes.erc6492MagicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';
	bytes.zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';

	Object.defineProperty(isErc6492Signature$3, "__esModule", { value: true });
	isErc6492Signature$3.isErc6492Signature = isErc6492Signature$2;
	const bytes_js_1$1 = bytes;
	const slice_js_1$2 = slice$1;
	function isErc6492Signature$2(signature) {
	    return (0, slice_js_1$2.sliceHex)(signature, -32) === bytes_js_1$1.erc6492MagicBytes;
	}

	Object.defineProperty(parseErc6492Signature$1, "__esModule", { value: true });
	parseErc6492Signature$1.parseErc6492Signature = parseErc6492Signature;
	const decodeAbiParameters_js_1$1 = decodeAbiParameters$1;
	const isErc6492Signature_js_1$1 = isErc6492Signature$3;
	function parseErc6492Signature(signature) {
	    if (!(0, isErc6492Signature_js_1$1.isErc6492Signature)(signature))
	        return { signature };
	    const [address, data, signature_] = (0, decodeAbiParameters_js_1$1.decodeAbiParameters)([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], signature);
	    return { address, data, signature: signature_ };
	}

	var serializeErc6492Signature$3 = {};

	Object.defineProperty(serializeErc6492Signature$3, "__esModule", { value: true });
	serializeErc6492Signature$3.serializeErc6492Signature = serializeErc6492Signature$2;
	const bytes_js_1 = bytes;
	const encodeAbiParameters_js_1$3 = encodeAbiParameters$3;
	const concat_js_1 = concat$1;
	const toBytes_js_1$5 = requireToBytes();
	function serializeErc6492Signature$2(parameters) {
	    const { address, data, signature, to = 'hex' } = parameters;
	    const signature_ = (0, concat_js_1.concatHex)([
	        (0, encodeAbiParameters_js_1$3.encodeAbiParameters)([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], [address, data, signature]),
	        bytes_js_1.erc6492MagicBytes,
	    ]);
	    if (to === 'hex')
	        return signature_;
	    return (0, toBytes_js_1$5.hexToBytes)(signature_);
	}

	var getSerializedTransactionType$1 = {};

	Object.defineProperty(getSerializedTransactionType$1, "__esModule", { value: true });
	getSerializedTransactionType$1.getSerializedTransactionType = getSerializedTransactionType;
	const transaction_js_1$5 = transaction$1;
	const slice_js_1$1 = slice$1;
	const fromHex_js_1$6 = requireFromHex();
	function getSerializedTransactionType(serializedTransaction) {
	    const serializedType = (0, slice_js_1$1.sliceHex)(serializedTransaction, 0, 1);
	    if (serializedType === '0x04')
	        return 'eip7702';
	    if (serializedType === '0x03')
	        return 'eip4844';
	    if (serializedType === '0x02')
	        return 'eip1559';
	    if (serializedType === '0x01')
	        return 'eip2930';
	    if (serializedType !== '0x' && (0, fromHex_js_1$6.hexToNumber)(serializedType) >= 0xc0)
	        return 'legacy';
	    throw new transaction_js_1$5.InvalidSerializedTransactionTypeError({ serializedType });
	}

	var assertTransaction = {};

	Object.defineProperty(assertTransaction, "__esModule", { value: true });
	assertTransaction.assertTransactionEIP7702 = assertTransactionEIP7702;
	assertTransaction.assertTransactionEIP4844 = assertTransactionEIP4844;
	assertTransaction.assertTransactionEIP1559 = assertTransactionEIP1559;
	assertTransaction.assertTransactionEIP2930 = assertTransactionEIP2930;
	assertTransaction.assertTransactionLegacy = assertTransactionLegacy;
	const kzg_js_1 = kzg;
	const address_js_1$3 = address$2;
	const base_js_1$2 = base$1;
	const blob_js_1 = blob;
	const chain_js_1 = chain;
	const node_js_1 = node;
	const isAddress_js_1$2 = requireIsAddress();
	const size_js_1 = size$2;
	const slice_js_1 = slice$1;
	const fromHex_js_1$5 = requireFromHex();
	function assertTransactionEIP7702(transaction) {
	    const { authorizationList } = transaction;
	    if (authorizationList) {
	        for (const authorization of authorizationList) {
	            const { contractAddress, chainId } = authorization;
	            if (!(0, isAddress_js_1$2.isAddress)(contractAddress))
	                throw new address_js_1$3.InvalidAddressError({ address: contractAddress });
	            if (chainId <= 0)
	                throw new chain_js_1.InvalidChainIdError({ chainId });
	        }
	    }
	    assertTransactionEIP1559(transaction);
	}
	function assertTransactionEIP4844(transaction) {
	    const { blobVersionedHashes } = transaction;
	    if (blobVersionedHashes) {
	        if (blobVersionedHashes.length === 0)
	            throw new blob_js_1.EmptyBlobError();
	        for (const hash of blobVersionedHashes) {
	            const size_ = (0, size_js_1.size)(hash);
	            const version = (0, fromHex_js_1$5.hexToNumber)((0, slice_js_1.slice)(hash, 0, 1));
	            if (size_ !== 32)
	                throw new blob_js_1.InvalidVersionedHashSizeError({ hash, size: size_ });
	            if (version !== kzg_js_1.versionedHashVersionKzg)
	                throw new blob_js_1.InvalidVersionedHashVersionError({
	                    hash,
	                    version,
	                });
	        }
	    }
	    assertTransactionEIP1559(transaction);
	}
	function assertTransactionEIP1559(transaction) {
	    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
	    if (chainId <= 0)
	        throw new chain_js_1.InvalidChainIdError({ chainId });
	    if (to && !(0, isAddress_js_1$2.isAddress)(to))
	        throw new address_js_1$3.InvalidAddressError({ address: to });
	    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
	        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
	    if (maxPriorityFeePerGas &&
	        maxFeePerGas &&
	        maxPriorityFeePerGas > maxFeePerGas)
	        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
	}
	function assertTransactionEIP2930(transaction) {
	    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
	    if (chainId <= 0)
	        throw new chain_js_1.InvalidChainIdError({ chainId });
	    if (to && !(0, isAddress_js_1$2.isAddress)(to))
	        throw new address_js_1$3.InvalidAddressError({ address: to });
	    if (maxPriorityFeePerGas || maxFeePerGas)
	        throw new base_js_1$2.BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.');
	    if (gasPrice && gasPrice > 2n ** 256n - 1n)
	        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
	}
	function assertTransactionLegacy(transaction) {
	    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
	    if (to && !(0, isAddress_js_1$2.isAddress)(to))
	        throw new address_js_1$3.InvalidAddressError({ address: to });
	    if (typeof chainId !== 'undefined' && chainId <= 0)
	        throw new chain_js_1.InvalidChainIdError({ chainId });
	    if (maxPriorityFeePerGas || maxFeePerGas)
	        throw new base_js_1$2.BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.');
	    if (gasPrice && gasPrice > 2n ** 256n - 1n)
	        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
	}

	var parseTransaction$1 = {};

	Object.defineProperty(parseTransaction$1, "__esModule", { value: true });
	parseTransaction$1.parseTransaction = parseTransaction;
	parseTransaction$1.toTransactionArray = toTransactionArray;
	parseTransaction$1.parseAccessList = parseAccessList;
	const address_js_1$2 = address$2;
	const transaction_js_1$4 = transaction$1;
	const isAddress_js_1$1 = requireIsAddress();
	const toBlobSidecars_js_1 = toBlobSidecars$1;
	const isHex_js_1$2 = isHex$1;
	const pad_js_1 = pad$1;
	const trim_js_1$1 = trim$3;
	const fromHex_js_1$4 = requireFromHex();
	const fromRlp_js_1 = fromRlp$1;
	const isHash_js_1 = isHash$1;
	const assertTransaction_js_1 = assertTransaction;
	const getSerializedTransactionType_js_1 = getSerializedTransactionType$1;
	function parseTransaction(serializedTransaction) {
	    const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
	    if (type === 'eip1559')
	        return parseTransactionEIP1559(serializedTransaction);
	    if (type === 'eip2930')
	        return parseTransactionEIP2930(serializedTransaction);
	    if (type === 'eip4844')
	        return parseTransactionEIP4844(serializedTransaction);
	    if (type === 'eip7702')
	        return parseTransactionEIP7702(serializedTransaction);
	    return parseTransactionLegacy(serializedTransaction);
	}
	function parseTransactionEIP7702(serializedTransaction) {
	    const transactionArray = toTransactionArray(serializedTransaction);
	    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, v, r, s,] = transactionArray;
	    if (transactionArray.length !== 10 && transactionArray.length !== 13)
	        throw new transaction_js_1$4.InvalidSerializedTransactionError({
	            attributes: {
	                chainId,
	                nonce,
	                maxPriorityFeePerGas,
	                maxFeePerGas,
	                gas,
	                to,
	                value,
	                data,
	                accessList,
	                authorizationList,
	                ...(transactionArray.length > 9
	                    ? {
	                        v,
	                        r,
	                        s,
	                    }
	                    : {}),
	            },
	            serializedTransaction,
	            type: 'eip7702',
	        });
	    const transaction = {
	        chainId: (0, fromHex_js_1$4.hexToNumber)(chainId),
	        type: 'eip7702',
	    };
	    if ((0, isHex_js_1$2.isHex)(to) && to !== '0x')
	        transaction.to = to;
	    if ((0, isHex_js_1$2.isHex)(gas) && gas !== '0x')
	        transaction.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
	    if ((0, isHex_js_1$2.isHex)(data) && data !== '0x')
	        transaction.data = data;
	    if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== '0x')
	        transaction.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
	    if ((0, isHex_js_1$2.isHex)(value) && value !== '0x')
	        transaction.value = (0, fromHex_js_1$4.hexToBigInt)(value);
	    if ((0, isHex_js_1$2.isHex)(maxFeePerGas) && maxFeePerGas !== '0x')
	        transaction.maxFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxFeePerGas);
	    if ((0, isHex_js_1$2.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
	        transaction.maxPriorityFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxPriorityFeePerGas);
	    if (accessList.length !== 0 && accessList !== '0x')
	        transaction.accessList = parseAccessList(accessList);
	    if (authorizationList.length !== 0 && authorizationList !== '0x')
	        transaction.authorizationList = parseAuthorizationList(authorizationList);
	    (0, assertTransaction_js_1.assertTransactionEIP7702)(transaction);
	    const signature = transactionArray.length === 13
	        ? parseEIP155Signature(transactionArray)
	        : undefined;
	    return { ...signature, ...transaction };
	}
	function parseTransactionEIP4844(serializedTransaction) {
	    const transactionOrWrapperArray = toTransactionArray(serializedTransaction);
	    const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
	    const transactionArray = hasNetworkWrapper
	        ? transactionOrWrapperArray[0]
	        : transactionOrWrapperArray;
	    const wrapperArray = hasNetworkWrapper
	        ? transactionOrWrapperArray.slice(1)
	        : [];
	    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s,] = transactionArray;
	    const [blobs, commitments, proofs] = wrapperArray;
	    if (!(transactionArray.length === 11 || transactionArray.length === 14))
	        throw new transaction_js_1$4.InvalidSerializedTransactionError({
	            attributes: {
	                chainId,
	                nonce,
	                maxPriorityFeePerGas,
	                maxFeePerGas,
	                gas,
	                to,
	                value,
	                data,
	                accessList,
	                ...(transactionArray.length > 9
	                    ? {
	                        v,
	                        r,
	                        s,
	                    }
	                    : {}),
	            },
	            serializedTransaction,
	            type: 'eip4844',
	        });
	    const transaction = {
	        blobVersionedHashes: blobVersionedHashes,
	        chainId: (0, fromHex_js_1$4.hexToNumber)(chainId),
	        type: 'eip4844',
	    };
	    if ((0, isHex_js_1$2.isHex)(to) && to !== '0x')
	        transaction.to = to;
	    if ((0, isHex_js_1$2.isHex)(gas) && gas !== '0x')
	        transaction.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
	    if ((0, isHex_js_1$2.isHex)(data) && data !== '0x')
	        transaction.data = data;
	    if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== '0x')
	        transaction.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
	    if ((0, isHex_js_1$2.isHex)(value) && value !== '0x')
	        transaction.value = (0, fromHex_js_1$4.hexToBigInt)(value);
	    if ((0, isHex_js_1$2.isHex)(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')
	        transaction.maxFeePerBlobGas = (0, fromHex_js_1$4.hexToBigInt)(maxFeePerBlobGas);
	    if ((0, isHex_js_1$2.isHex)(maxFeePerGas) && maxFeePerGas !== '0x')
	        transaction.maxFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxFeePerGas);
	    if ((0, isHex_js_1$2.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
	        transaction.maxPriorityFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxPriorityFeePerGas);
	    if (accessList.length !== 0 && accessList !== '0x')
	        transaction.accessList = parseAccessList(accessList);
	    if (blobs && commitments && proofs)
	        transaction.sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({
	            blobs: blobs,
	            commitments: commitments,
	            proofs: proofs,
	        });
	    (0, assertTransaction_js_1.assertTransactionEIP4844)(transaction);
	    const signature = transactionArray.length === 14
	        ? parseEIP155Signature(transactionArray)
	        : undefined;
	    return { ...signature, ...transaction };
	}
	function parseTransactionEIP1559(serializedTransaction) {
	    const transactionArray = toTransactionArray(serializedTransaction);
	    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s,] = transactionArray;
	    if (!(transactionArray.length === 9 || transactionArray.length === 12))
	        throw new transaction_js_1$4.InvalidSerializedTransactionError({
	            attributes: {
	                chainId,
	                nonce,
	                maxPriorityFeePerGas,
	                maxFeePerGas,
	                gas,
	                to,
	                value,
	                data,
	                accessList,
	                ...(transactionArray.length > 9
	                    ? {
	                        v,
	                        r,
	                        s,
	                    }
	                    : {}),
	            },
	            serializedTransaction,
	            type: 'eip1559',
	        });
	    const transaction = {
	        chainId: (0, fromHex_js_1$4.hexToNumber)(chainId),
	        type: 'eip1559',
	    };
	    if ((0, isHex_js_1$2.isHex)(to) && to !== '0x')
	        transaction.to = to;
	    if ((0, isHex_js_1$2.isHex)(gas) && gas !== '0x')
	        transaction.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
	    if ((0, isHex_js_1$2.isHex)(data) && data !== '0x')
	        transaction.data = data;
	    if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== '0x')
	        transaction.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
	    if ((0, isHex_js_1$2.isHex)(value) && value !== '0x')
	        transaction.value = (0, fromHex_js_1$4.hexToBigInt)(value);
	    if ((0, isHex_js_1$2.isHex)(maxFeePerGas) && maxFeePerGas !== '0x')
	        transaction.maxFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxFeePerGas);
	    if ((0, isHex_js_1$2.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
	        transaction.maxPriorityFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxPriorityFeePerGas);
	    if (accessList.length !== 0 && accessList !== '0x')
	        transaction.accessList = parseAccessList(accessList);
	    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
	    const signature = transactionArray.length === 12
	        ? parseEIP155Signature(transactionArray)
	        : undefined;
	    return { ...signature, ...transaction };
	}
	function parseTransactionEIP2930(serializedTransaction) {
	    const transactionArray = toTransactionArray(serializedTransaction);
	    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
	    if (!(transactionArray.length === 8 || transactionArray.length === 11))
	        throw new transaction_js_1$4.InvalidSerializedTransactionError({
	            attributes: {
	                chainId,
	                nonce,
	                gasPrice,
	                gas,
	                to,
	                value,
	                data,
	                accessList,
	                ...(transactionArray.length > 8
	                    ? {
	                        v,
	                        r,
	                        s,
	                    }
	                    : {}),
	            },
	            serializedTransaction,
	            type: 'eip2930',
	        });
	    const transaction = {
	        chainId: (0, fromHex_js_1$4.hexToNumber)(chainId),
	        type: 'eip2930',
	    };
	    if ((0, isHex_js_1$2.isHex)(to) && to !== '0x')
	        transaction.to = to;
	    if ((0, isHex_js_1$2.isHex)(gas) && gas !== '0x')
	        transaction.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
	    if ((0, isHex_js_1$2.isHex)(data) && data !== '0x')
	        transaction.data = data;
	    if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== '0x')
	        transaction.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
	    if ((0, isHex_js_1$2.isHex)(value) && value !== '0x')
	        transaction.value = (0, fromHex_js_1$4.hexToBigInt)(value);
	    if ((0, isHex_js_1$2.isHex)(gasPrice) && gasPrice !== '0x')
	        transaction.gasPrice = (0, fromHex_js_1$4.hexToBigInt)(gasPrice);
	    if (accessList.length !== 0 && accessList !== '0x')
	        transaction.accessList = parseAccessList(accessList);
	    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
	    const signature = transactionArray.length === 11
	        ? parseEIP155Signature(transactionArray)
	        : undefined;
	    return { ...signature, ...transaction };
	}
	function parseTransactionLegacy(serializedTransaction) {
	    const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, 'hex');
	    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
	    if (!(transactionArray.length === 6 || transactionArray.length === 9))
	        throw new transaction_js_1$4.InvalidSerializedTransactionError({
	            attributes: {
	                nonce,
	                gasPrice,
	                gas,
	                to,
	                value,
	                data,
	                ...(transactionArray.length > 6
	                    ? {
	                        v: chainIdOrV_,
	                        r,
	                        s,
	                    }
	                    : {}),
	            },
	            serializedTransaction,
	            type: 'legacy',
	        });
	    const transaction = {
	        type: 'legacy',
	    };
	    if ((0, isHex_js_1$2.isHex)(to) && to !== '0x')
	        transaction.to = to;
	    if ((0, isHex_js_1$2.isHex)(gas) && gas !== '0x')
	        transaction.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
	    if ((0, isHex_js_1$2.isHex)(data) && data !== '0x')
	        transaction.data = data;
	    if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== '0x')
	        transaction.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
	    if ((0, isHex_js_1$2.isHex)(value) && value !== '0x')
	        transaction.value = (0, fromHex_js_1$4.hexToBigInt)(value);
	    if ((0, isHex_js_1$2.isHex)(gasPrice) && gasPrice !== '0x')
	        transaction.gasPrice = (0, fromHex_js_1$4.hexToBigInt)(gasPrice);
	    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
	    if (transactionArray.length === 6)
	        return transaction;
	    const chainIdOrV = (0, isHex_js_1$2.isHex)(chainIdOrV_) && chainIdOrV_ !== '0x'
	        ? (0, fromHex_js_1$4.hexToBigInt)(chainIdOrV_)
	        : 0n;
	    if (s === '0x' && r === '0x') {
	        if (chainIdOrV > 0)
	            transaction.chainId = Number(chainIdOrV);
	        return transaction;
	    }
	    const v = chainIdOrV;
	    const chainId = Number((v - 35n) / 2n);
	    if (chainId > 0)
	        transaction.chainId = chainId;
	    else if (v !== 27n && v !== 28n)
	        throw new transaction_js_1$4.InvalidLegacyVError({ v });
	    transaction.v = v;
	    transaction.s = s;
	    transaction.r = r;
	    transaction.yParity = v % 2n === 0n ? 1 : 0;
	    return transaction;
	}
	function toTransactionArray(serializedTransaction) {
	    return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, 'hex');
	}
	function parseAccessList(accessList_) {
	    const accessList = [];
	    for (let i = 0; i < accessList_.length; i++) {
	        const [address, storageKeys] = accessList_[i];
	        if (!(0, isAddress_js_1$1.isAddress)(address, { strict: false }))
	            throw new address_js_1$2.InvalidAddressError({ address });
	        accessList.push({
	            address: address,
	            storageKeys: storageKeys.map((key) => ((0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1$1.trim)(key))),
	        });
	    }
	    return accessList;
	}
	function parseAuthorizationList(serializedAuthorizationList) {
	    const authorizationList = [];
	    for (let i = 0; i < serializedAuthorizationList.length; i++) {
	        const [chainId, contractAddress, nonce, yParity, r, s] = serializedAuthorizationList[i];
	        authorizationList.push({
	            chainId: (0, fromHex_js_1$4.hexToNumber)(chainId),
	            contractAddress,
	            nonce: (0, fromHex_js_1$4.hexToNumber)(nonce),
	            ...parseEIP155Signature([yParity, r, s]),
	        });
	    }
	    return authorizationList;
	}
	function parseEIP155Signature(transactionArray) {
	    const signature = transactionArray.slice(-3);
	    const v = signature[0] === '0x' || (0, fromHex_js_1$4.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
	    return {
	        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
	        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
	        v,
	        yParity: v === 27n ? 0 : 1,
	    };
	}

	var serializeTransaction$2 = {};

	var serializeAuthorizationList = {};

	var hasRequiredSerializeAuthorizationList;

	function requireSerializeAuthorizationList () {
		if (hasRequiredSerializeAuthorizationList) return serializeAuthorizationList;
		hasRequiredSerializeAuthorizationList = 1;
		Object.defineProperty(serializeAuthorizationList, "__esModule", { value: true });
		serializeAuthorizationList.serializeAuthorizationList = serializeAuthorizationList$1;
		const toHex_js_1 = requireToHex();
		const serializeTransaction_js_1 = requireSerializeTransaction();
		function serializeAuthorizationList$1(authorizationList) {
		    if (!authorizationList || authorizationList.length === 0)
		        return [];
		    const serializedAuthorizationList = [];
		    for (const authorization of authorizationList) {
		        const { contractAddress, chainId, nonce, ...signature } = authorization;
		        serializedAuthorizationList.push([
		            (0, toHex_js_1.toHex)(chainId),
		            contractAddress,
		            (0, toHex_js_1.toHex)(nonce),
		            ...(0, serializeTransaction_js_1.toYParitySignatureArray)({}, signature),
		        ]);
		    }
		    return serializedAuthorizationList;
		}
		
		return serializeAuthorizationList;
	}

	var serializeAccessList$1 = {};

	Object.defineProperty(serializeAccessList$1, "__esModule", { value: true });
	serializeAccessList$1.serializeAccessList = serializeAccessList;
	const address_js_1$1 = address$2;
	const transaction_js_1$3 = transaction$1;
	const isAddress_js_1 = requireIsAddress();
	function serializeAccessList(accessList) {
	    if (!accessList || accessList.length === 0)
	        return [];
	    const serializedAccessList = [];
	    for (let i = 0; i < accessList.length; i++) {
	        const { address, storageKeys } = accessList[i];
	        for (let j = 0; j < storageKeys.length; j++) {
	            if (storageKeys[j].length - 2 !== 64) {
	                throw new transaction_js_1$3.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
	            }
	        }
	        if (!(0, isAddress_js_1.isAddress)(address, { strict: false })) {
	            throw new address_js_1$1.InvalidAddressError({ address });
	        }
	        serializedAccessList.push([address, storageKeys]);
	    }
	    return serializedAccessList;
	}

	var hasRequiredSerializeTransaction;

	function requireSerializeTransaction () {
		if (hasRequiredSerializeTransaction) return serializeTransaction$2;
		hasRequiredSerializeTransaction = 1;
		Object.defineProperty(serializeTransaction$2, "__esModule", { value: true });
		serializeTransaction$2.serializeTransaction = serializeTransaction;
		serializeTransaction$2.toYParitySignatureArray = toYParitySignatureArray;
		const transaction_js_1 = transaction$1;
		const blobsToCommitments_js_1 = blobsToCommitments$1;
		const blobsToProofs_js_1 = blobsToProofs$1;
		const commitmentsToVersionedHashes_js_1 = commitmentsToVersionedHashes$1;
		const toBlobSidecars_js_1 = toBlobSidecars$1;
		const concat_js_1 = concat$1;
		const trim_js_1 = trim$3;
		const toHex_js_1 = requireToHex();
		const toRlp_js_1 = toRlp$1;
		const serializeAuthorizationList_js_1 = requireSerializeAuthorizationList();
		const assertTransaction_js_1 = assertTransaction;
		const getTransactionType_js_1 = getTransactionType$1;
		const serializeAccessList_js_1 = serializeAccessList$1;
		function serializeTransaction(transaction, signature) {
		    const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
		    if (type === 'eip1559')
		        return serializeTransactionEIP1559(transaction, signature);
		    if (type === 'eip2930')
		        return serializeTransactionEIP2930(transaction, signature);
		    if (type === 'eip4844')
		        return serializeTransactionEIP4844(transaction, signature);
		    if (type === 'eip7702')
		        return serializeTransactionEIP7702(transaction, signature);
		    return serializeTransactionLegacy(transaction, signature);
		}
		function serializeTransactionEIP7702(transaction, signature) {
		    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = transaction;
		    (0, assertTransaction_js_1.assertTransactionEIP7702)(transaction);
		    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
		    const serializedAuthorizationList = (0, serializeAuthorizationList_js_1.serializeAuthorizationList)(authorizationList);
		    return (0, concat_js_1.concatHex)([
		        '0x04',
		        (0, toRlp_js_1.toRlp)([
		            (0, toHex_js_1.toHex)(chainId),
		            nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
		            maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : '0x',
		            maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : '0x',
		            gas ? (0, toHex_js_1.toHex)(gas) : '0x',
		            to ?? '0x',
		            value ? (0, toHex_js_1.toHex)(value) : '0x',
		            data ?? '0x',
		            serializedAccessList,
		            serializedAuthorizationList,
		            ...toYParitySignatureArray(transaction, signature),
		        ]),
		    ]);
		}
		function serializeTransactionEIP4844(transaction, signature) {
		    const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = transaction;
		    (0, assertTransaction_js_1.assertTransactionEIP4844)(transaction);
		    let blobVersionedHashes = transaction.blobVersionedHashes;
		    let sidecars = transaction.sidecars;
		    if (transaction.blobs &&
		        (typeof blobVersionedHashes === 'undefined' ||
		            typeof sidecars === 'undefined')) {
		        const blobs = (typeof transaction.blobs[0] === 'string'
		            ? transaction.blobs
		            : transaction.blobs.map((x) => (0, toHex_js_1.bytesToHex)(x)));
		        const kzg = transaction.kzg;
		        const commitments = (0, blobsToCommitments_js_1.blobsToCommitments)({
		            blobs,
		            kzg,
		        });
		        if (typeof blobVersionedHashes === 'undefined')
		            blobVersionedHashes = (0, commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes)({
		                commitments,
		            });
		        if (typeof sidecars === 'undefined') {
		            const proofs = (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg });
		            sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({ blobs, commitments, proofs });
		        }
		    }
		    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
		    const serializedTransaction = [
		        (0, toHex_js_1.toHex)(chainId),
		        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
		        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : '0x',
		        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : '0x',
		        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
		        to ?? '0x',
		        value ? (0, toHex_js_1.toHex)(value) : '0x',
		        data ?? '0x',
		        serializedAccessList,
		        maxFeePerBlobGas ? (0, toHex_js_1.toHex)(maxFeePerBlobGas) : '0x',
		        blobVersionedHashes ?? [],
		        ...toYParitySignatureArray(transaction, signature),
		    ];
		    const blobs = [];
		    const commitments = [];
		    const proofs = [];
		    if (sidecars)
		        for (let i = 0; i < sidecars.length; i++) {
		            const { blob, commitment, proof } = sidecars[i];
		            blobs.push(blob);
		            commitments.push(commitment);
		            proofs.push(proof);
		        }
		    return (0, concat_js_1.concatHex)([
		        '0x03',
		        sidecars
		            ?
		                (0, toRlp_js_1.toRlp)([serializedTransaction, blobs, commitments, proofs])
		            :
		                (0, toRlp_js_1.toRlp)(serializedTransaction),
		    ]);
		}
		function serializeTransactionEIP1559(transaction, signature) {
		    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = transaction;
		    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
		    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
		    const serializedTransaction = [
		        (0, toHex_js_1.toHex)(chainId),
		        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
		        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : '0x',
		        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : '0x',
		        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
		        to ?? '0x',
		        value ? (0, toHex_js_1.toHex)(value) : '0x',
		        data ?? '0x',
		        serializedAccessList,
		        ...toYParitySignatureArray(transaction, signature),
		    ];
		    return (0, concat_js_1.concatHex)([
		        '0x02',
		        (0, toRlp_js_1.toRlp)(serializedTransaction),
		    ]);
		}
		function serializeTransactionEIP2930(transaction, signature) {
		    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
		    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
		    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
		    const serializedTransaction = [
		        (0, toHex_js_1.toHex)(chainId),
		        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
		        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : '0x',
		        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
		        to ?? '0x',
		        value ? (0, toHex_js_1.toHex)(value) : '0x',
		        data ?? '0x',
		        serializedAccessList,
		        ...toYParitySignatureArray(transaction, signature),
		    ];
		    return (0, concat_js_1.concatHex)([
		        '0x01',
		        (0, toRlp_js_1.toRlp)(serializedTransaction),
		    ]);
		}
		function serializeTransactionLegacy(transaction, signature) {
		    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
		    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
		    let serializedTransaction = [
		        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
		        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : '0x',
		        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
		        to ?? '0x',
		        value ? (0, toHex_js_1.toHex)(value) : '0x',
		        data ?? '0x',
		    ];
		    if (signature) {
		        const v = (() => {
		            if (signature.v >= 35n) {
		                const inferredChainId = (signature.v - 35n) / 2n;
		                if (inferredChainId > 0)
		                    return signature.v;
		                return 27n + (signature.v === 35n ? 0n : 1n);
		            }
		            if (chainId > 0)
		                return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
		            const v = 27n + (signature.v === 27n ? 0n : 1n);
		            if (signature.v !== v)
		                throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
		            return v;
		        })();
		        const r = (0, trim_js_1.trim)(signature.r);
		        const s = (0, trim_js_1.trim)(signature.s);
		        serializedTransaction = [
		            ...serializedTransaction,
		            (0, toHex_js_1.toHex)(v),
		            r === '0x00' ? '0x' : r,
		            s === '0x00' ? '0x' : s,
		        ];
		    }
		    else if (chainId > 0) {
		        serializedTransaction = [
		            ...serializedTransaction,
		            (0, toHex_js_1.toHex)(chainId),
		            '0x',
		            '0x',
		        ];
		    }
		    return (0, toRlp_js_1.toRlp)(serializedTransaction);
		}
		function toYParitySignatureArray(transaction, signature_) {
		    const signature = signature_ ?? transaction;
		    const { v, yParity } = signature;
		    if (typeof signature.r === 'undefined')
		        return [];
		    if (typeof signature.s === 'undefined')
		        return [];
		    if (typeof v === 'undefined' && typeof yParity === 'undefined')
		        return [];
		    const r = (0, trim_js_1.trim)(signature.r);
		    const s = (0, trim_js_1.trim)(signature.s);
		    const yParity_ = (() => {
		        if (typeof yParity === 'number')
		            return yParity ? (0, toHex_js_1.toHex)(1) : '0x';
		        if (v === 0n)
		            return '0x';
		        if (v === 1n)
		            return (0, toHex_js_1.toHex)(1);
		        return v === 27n ? '0x' : (0, toHex_js_1.toHex)(1);
		    })();
		    return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];
		}
		
		return serializeTransaction$2;
	}

	var parseUnits$1 = {};

	Object.defineProperty(parseUnits$1, "__esModule", { value: true });
	parseUnits$1.parseUnits = parseUnits;
	function parseUnits(value, decimals) {
	    let [integer, fraction = '0'] = value.split('.');
	    const negative = integer.startsWith('-');
	    if (negative)
	        integer = integer.slice(1);
	    fraction = fraction.replace(/(0+)$/, '');
	    if (decimals === 0) {
	        if (Math.round(Number(`.${fraction}`)) === 1)
	            integer = `${BigInt(integer) + 1n}`;
	        fraction = '';
	    }
	    else if (fraction.length > decimals) {
	        const [left, unit, right] = [
	            fraction.slice(0, decimals - 1),
	            fraction.slice(decimals - 1, decimals),
	            fraction.slice(decimals),
	        ];
	        const rounded = Math.round(Number(`${unit}.${right}`));
	        if (rounded > 9)
	            fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');
	        else
	            fraction = `${left}${rounded}`;
	        if (fraction.length > decimals) {
	            fraction = fraction.slice(1);
	            integer = `${BigInt(integer) + 1n}`;
	        }
	        fraction = fraction.slice(0, decimals);
	    }
	    else {
	        fraction = fraction.padEnd(decimals, '0');
	    }
	    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);
	}

	var parseEther$1 = {};

	Object.defineProperty(parseEther$1, "__esModule", { value: true });
	parseEther$1.parseEther = parseEther;
	const unit_js_1$1 = unit;
	const parseUnits_js_1$1 = parseUnits$1;
	function parseEther(ether, unit = 'wei') {
	    return (0, parseUnits_js_1$1.parseUnits)(ether, unit_js_1$1.etherUnits[unit]);
	}

	var parseGwei$1 = {};

	Object.defineProperty(parseGwei$1, "__esModule", { value: true });
	parseGwei$1.parseGwei = parseGwei;
	const unit_js_1 = unit;
	const parseUnits_js_1 = parseUnits$1;
	function parseGwei(ether, unit = 'wei') {
	    return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
	}

	var nonceManager = {};

	Object.defineProperty(nonceManager, "__esModule", { value: true });
	nonceManager.nonceManager = void 0;
	nonceManager.createNonceManager = createNonceManager;
	nonceManager.jsonRpc = jsonRpc;
	const getTransactionCount_js_1$1 = getTransactionCount$1;
	const lru_js_1$2 = lru;
	function createNonceManager(parameters) {
	    const { source } = parameters;
	    const deltaMap = new Map();
	    const nonceMap = new lru_js_1$2.LruMap(8192);
	    const promiseMap = new Map();
	    const getKey = ({ address, chainId }) => `${address}.${chainId}`;
	    return {
	        async consume({ address, chainId, client }) {
	            const key = getKey({ address, chainId });
	            const promise = this.get({ address, chainId, client });
	            this.increment({ address, chainId });
	            const nonce = await promise;
	            await source.set({ address, chainId }, nonce);
	            nonceMap.set(key, nonce);
	            return nonce;
	        },
	        async increment({ address, chainId }) {
	            const key = getKey({ address, chainId });
	            const delta = deltaMap.get(key) ?? 0;
	            deltaMap.set(key, delta + 1);
	        },
	        async get({ address, chainId, client }) {
	            const key = getKey({ address, chainId });
	            let promise = promiseMap.get(key);
	            if (!promise) {
	                promise = (async () => {
	                    try {
	                        const nonce = await source.get({ address, chainId, client });
	                        const previousNonce = nonceMap.get(key) ?? 0;
	                        if (previousNonce > 0 && nonce <= previousNonce)
	                            return previousNonce + 1;
	                        nonceMap.delete(key);
	                        return nonce;
	                    }
	                    finally {
	                        this.reset({ address, chainId });
	                    }
	                })();
	                promiseMap.set(key, promise);
	            }
	            const delta = deltaMap.get(key) ?? 0;
	            return delta + (await promise);
	        },
	        reset({ address, chainId }) {
	            const key = getKey({ address, chainId });
	            deltaMap.delete(key);
	            promiseMap.delete(key);
	        },
	    };
	}
	function jsonRpc() {
	    return {
	        async get(parameters) {
	            const { address, client } = parameters;
	            return (0, getTransactionCount_js_1$1.getTransactionCount)(client, {
	                address,
	                blockTag: 'pending',
	            });
	        },
	        set() { },
	    };
	}
	nonceManager.nonceManager = createNonceManager({
	    source: jsonRpc(),
	});

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.parseEventLogs = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.serializeTypedData = exports.stringify = exports.getWebSocketRpcClient = exports.socketClientCache = exports.getSocketRpcClient = exports.getHttpRpcClient = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.ccipRequest = exports.buildRequest = void 0;
		exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = exports.concatHex = exports.concatBytes = exports.concat = exports.isAddressEqual = void 0;
		exports.nonceManager = exports.createNonceManager = exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.serializeErc6492Signature = exports.isErc6492Signature = exports.parseErc6492Signature = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.verifyHash = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHash = exports.toFunctionHash = exports.toEventHash = exports.getFunctionSignature = exports.toFunctionSignature = exports.getEventSignature = exports.toEventSignature = exports.getFunctionSelector = exports.toFunctionSelector = exports.getEventSelector = exports.toEventSelector = exports.defineFormatter = exports.getAction = exports.getTransactionError = exports.getEstimateGasError = exports.getContractError = void 0;
		var buildRequest_js_1 = buildRequest$1;
		Object.defineProperty(exports, "buildRequest", { enumerable: true, get: function () { return buildRequest_js_1.buildRequest; } });
		var ccip_js_1 = requireCcip();
		Object.defineProperty(exports, "ccipRequest", { enumerable: true, get: function () { return ccip_js_1.ccipRequest; } });
		Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function () { return ccip_js_1.ccipRequest; } });
		Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function () { return ccip_js_1.offchainLookup; } });
		Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function () { return ccip_js_1.offchainLookupAbiItem; } });
		Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function () { return ccip_js_1.offchainLookupSignature; } });
		var assertCurrentChain_js_1 = assertCurrentChain$1;
		Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function () { return assertCurrentChain_js_1.assertCurrentChain; } });
		var defineChain_js_1 = defineChain$1;
		Object.defineProperty(exports, "defineChain", { enumerable: true, get: function () { return defineChain_js_1.defineChain; } });
		var extractChain_js_1 = extractChain$1;
		Object.defineProperty(exports, "extractChain", { enumerable: true, get: function () { return extractChain_js_1.extractChain; } });
		var getChainContractAddress_js_1 = getChainContractAddress$1;
		Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function () { return getChainContractAddress_js_1.getChainContractAddress; } });
		var regex_js_1 = regex;
		Object.defineProperty(exports, "arrayRegex", { enumerable: true, get: function () { return regex_js_1.arrayRegex; } });
		Object.defineProperty(exports, "bytesRegex", { enumerable: true, get: function () { return regex_js_1.bytesRegex; } });
		Object.defineProperty(exports, "integerRegex", { enumerable: true, get: function () { return regex_js_1.integerRegex; } });
		var compat_js_1 = compat;
		Object.defineProperty(exports, "getSocket", { enumerable: true, get: function () { return compat_js_1.getSocket; } });
		Object.defineProperty(exports, "rpc", { enumerable: true, get: function () { return compat_js_1.rpc; } });
		var http_js_1 = http$1;
		Object.defineProperty(exports, "getHttpRpcClient", { enumerable: true, get: function () { return http_js_1.getHttpRpcClient; } });
		var socket_js_1 = socket;
		Object.defineProperty(exports, "getSocketRpcClient", { enumerable: true, get: function () { return socket_js_1.getSocketRpcClient; } });
		Object.defineProperty(exports, "socketClientCache", { enumerable: true, get: function () { return socket_js_1.socketClientCache; } });
		var webSocket_js_1 = webSocket$3;
		Object.defineProperty(exports, "getWebSocketRpcClient", { enumerable: true, get: function () { return webSocket_js_1.getWebSocketRpcClient; } });
		var stringify_js_1 = stringify$1;
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return stringify_js_1.stringify; } });
		var typedData_js_1 = requireTypedData();
		Object.defineProperty(exports, "serializeTypedData", { enumerable: true, get: function () { return typedData_js_1.serializeTypedData; } });
		Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function () { return typedData_js_1.validateTypedData; } });
		var decodeAbiParameters_js_1 = decodeAbiParameters$1;
		Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function () { return decodeAbiParameters_js_1.decodeAbiParameters; } });
		var decodeErrorResult_js_1 = decodeErrorResult$1;
		Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function () { return decodeErrorResult_js_1.decodeErrorResult; } });
		var decodeEventLog_js_1 = decodeEventLog$1;
		Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function () { return decodeEventLog_js_1.decodeEventLog; } });
		var decodeFunctionData_js_1 = decodeFunctionData$1;
		Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function () { return decodeFunctionData_js_1.decodeFunctionData; } });
		var decodeFunctionResult_js_1 = decodeFunctionResult$1;
		Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function () { return decodeFunctionResult_js_1.decodeFunctionResult; } });
		var encodeAbiParameters_js_1 = encodeAbiParameters$3;
		Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function () { return encodeAbiParameters_js_1.encodeAbiParameters; } });
		var encodeDeployData_js_1 = encodeDeployData$1;
		Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function () { return encodeDeployData_js_1.encodeDeployData; } });
		var encodeErrorResult_js_1 = encodeErrorResult$1;
		Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function () { return encodeErrorResult_js_1.encodeErrorResult; } });
		var encodeEventTopics_js_1 = encodeEventTopics$1;
		Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function () { return encodeEventTopics_js_1.encodeEventTopics; } });
		var encodeFunctionData_js_1 = encodeFunctionData$1;
		Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function () { return encodeFunctionData_js_1.encodeFunctionData; } });
		var encodeFunctionResult_js_1 = encodeFunctionResult$1;
		Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function () { return encodeFunctionResult_js_1.encodeFunctionResult; } });
		var parseEventLogs_js_1 = parseEventLogs$2;
		Object.defineProperty(exports, "parseEventLogs", { enumerable: true, get: function () { return parseEventLogs_js_1.parseEventLogs; } });
		var getAbiItem_js_1 = getAbiItem$1;
		Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function () { return getAbiItem_js_1.getAbiItem; } });
		var abitype_1 = exports$1;
		Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function () { return abitype_1.parseAbi; } });
		Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function () { return abitype_1.parseAbiItem; } });
		Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function () { return abitype_1.parseAbiParameter; } });
		Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function () { return abitype_1.parseAbiParameters; } });
		var encodePacked_js_1 = encodePacked$1;
		Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function () { return encodePacked_js_1.encodePacked; } });
		var formatAbiItemWithArgs_js_1 = formatAbiItemWithArgs$1;
		Object.defineProperty(exports, "formatAbiItemWithArgs", { enumerable: true, get: function () { return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs; } });
		var formatAbiItem_js_1 = requireFormatAbiItem();
		Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiItem; } });
		Object.defineProperty(exports, "formatAbiParams", { enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiParams; } });
		var parseAccount_js_1 = parseAccount$1;
		Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function () { return parseAccount_js_1.parseAccount; } });
		var publicKeyToAddress_js_1 = publicKeyToAddress$1;
		Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function () { return publicKeyToAddress_js_1.publicKeyToAddress; } });
		var getContractAddress_js_1 = getContractAddress$1;
		Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function () { return getContractAddress_js_1.getContractAddress; } });
		Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function () { return getContractAddress_js_1.getCreateAddress; } });
		Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function () { return getContractAddress_js_1.getCreate2Address; } });
		var getAddress_js_1 = requireGetAddress();
		Object.defineProperty(exports, "getAddress", { enumerable: true, get: function () { return getAddress_js_1.getAddress; } });
		var isAddress_js_1 = requireIsAddress();
		Object.defineProperty(exports, "isAddress", { enumerable: true, get: function () { return isAddress_js_1.isAddress; } });
		var isAddressEqual_js_1 = isAddressEqual$1;
		Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function () { return isAddressEqual_js_1.isAddressEqual; } });
		var concat_js_1 = concat$1;
		Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_js_1.concat; } });
		Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return concat_js_1.concatBytes; } });
		Object.defineProperty(exports, "concatHex", { enumerable: true, get: function () { return concat_js_1.concatHex; } });
		var isBytes_js_1 = isBytes$1;
		Object.defineProperty(exports, "isBytes", { enumerable: true, get: function () { return isBytes_js_1.isBytes; } });
		var isHex_js_1 = isHex$1;
		Object.defineProperty(exports, "isHex", { enumerable: true, get: function () { return isHex_js_1.isHex; } });
		var pad_js_1 = pad$1;
		Object.defineProperty(exports, "pad", { enumerable: true, get: function () { return pad_js_1.pad; } });
		Object.defineProperty(exports, "padBytes", { enumerable: true, get: function () { return pad_js_1.padBytes; } });
		Object.defineProperty(exports, "padHex", { enumerable: true, get: function () { return pad_js_1.padHex; } });
		var size_js_1 = size$2;
		Object.defineProperty(exports, "size", { enumerable: true, get: function () { return size_js_1.size; } });
		var slice_js_1 = slice$1;
		Object.defineProperty(exports, "slice", { enumerable: true, get: function () { return slice_js_1.slice; } });
		Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function () { return slice_js_1.sliceBytes; } });
		Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function () { return slice_js_1.sliceHex; } });
		var trim_js_1 = trim$3;
		Object.defineProperty(exports, "trim", { enumerable: true, get: function () { return trim_js_1.trim; } });
		var block_js_1 = block;
		Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function () { return block_js_1.defineBlock; } });
		Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function () { return block_js_1.formatBlock; } });
		var transaction_js_1 = transaction;
		Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function () { return transaction_js_1.defineTransaction; } });
		Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function () { return transaction_js_1.formatTransaction; } });
		Object.defineProperty(exports, "transactionType", { enumerable: true, get: function () { return transaction_js_1.transactionType; } });
		var log_js_1 = log;
		Object.defineProperty(exports, "formatLog", { enumerable: true, get: function () { return log_js_1.formatLog; } });
		var transactionReceipt_js_1 = transactionReceipt;
		Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function () { return transactionReceipt_js_1.defineTransactionReceipt; } });
		var transactionRequest_js_1 = transactionRequest;
		Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function () { return transactionRequest_js_1.defineTransactionRequest; } });
		Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function () { return transactionRequest_js_1.formatTransactionRequest; } });
		var extract_js_1 = extract$1;
		Object.defineProperty(exports, "extract", { enumerable: true, get: function () { return extract_js_1.extract; } });
		var toRlp_js_1 = toRlp$1;
		Object.defineProperty(exports, "toRlp", { enumerable: true, get: function () { return toRlp_js_1.toRlp; } });
		var toBytes_js_1 = requireToBytes();
		Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function () { return toBytes_js_1.boolToBytes; } });
		Object.defineProperty(exports, "toBytes", { enumerable: true, get: function () { return toBytes_js_1.toBytes; } });
		Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function () { return toBytes_js_1.hexToBytes; } });
		Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function () { return toBytes_js_1.numberToBytes; } });
		Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function () { return toBytes_js_1.stringToBytes; } });
		var toHex_js_1 = requireToHex();
		Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function () { return toHex_js_1.boolToHex; } });
		Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return toHex_js_1.bytesToHex; } });
		Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return toHex_js_1.toHex; } });
		Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function () { return toHex_js_1.numberToHex; } });
		Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function () { return toHex_js_1.stringToHex; } });
		var fromBytes_js_1 = fromBytes$3;
		Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } });
		Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } });
		Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function () { return fromBytes_js_1.bytesToBool; } });
		Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function () { return fromBytes_js_1.bytesToNumber; } });
		Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function () { return fromBytes_js_1.bytesToString; } });
		Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function () { return fromBytes_js_1.fromBytes; } });
		var fromHex_js_1 = requireFromHex();
		Object.defineProperty(exports, "fromHex", { enumerable: true, get: function () { return fromHex_js_1.fromHex; } });
		Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function () { return fromHex_js_1.hexToBool; } });
		Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function () { return fromHex_js_1.hexToBigInt; } });
		Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function () { return fromHex_js_1.hexToNumber; } });
		Object.defineProperty(exports, "hexToString", { enumerable: true, get: function () { return fromHex_js_1.hexToString; } });
		var fromRlp_js_1 = fromRlp$1;
		Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function () { return fromRlp_js_1.fromRlp; } });
		var getNodeError_js_1 = getNodeError$1;
		Object.defineProperty(exports, "containsNodeError", { enumerable: true, get: function () { return getNodeError_js_1.containsNodeError; } });
		Object.defineProperty(exports, "getNodeError", { enumerable: true, get: function () { return getNodeError_js_1.getNodeError; } });
		var getCallError_js_1 = getCallError$1;
		Object.defineProperty(exports, "getCallError", { enumerable: true, get: function () { return getCallError_js_1.getCallError; } });
		var getContractError_js_1 = getContractError$1;
		Object.defineProperty(exports, "getContractError", { enumerable: true, get: function () { return getContractError_js_1.getContractError; } });
		var getEstimateGasError_js_1 = getEstimateGasError$1;
		Object.defineProperty(exports, "getEstimateGasError", { enumerable: true, get: function () { return getEstimateGasError_js_1.getEstimateGasError; } });
		var getTransactionError_js_1 = getTransactionError$1;
		Object.defineProperty(exports, "getTransactionError", { enumerable: true, get: function () { return getTransactionError_js_1.getTransactionError; } });
		var getAction_js_1 = getAction$1;
		Object.defineProperty(exports, "getAction", { enumerable: true, get: function () { return getAction_js_1.getAction; } });
		var formatter_js_1 = formatter;
		Object.defineProperty(exports, "defineFormatter", { enumerable: true, get: function () { return formatter_js_1.defineFormatter; } });
		var toEventSelector_js_1 = toEventSelector;
		Object.defineProperty(exports, "toEventSelector", { enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } });
		Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } });
		var toFunctionSelector_js_1 = toFunctionSelector$1;
		Object.defineProperty(exports, "toFunctionSelector", { enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } });
		Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } });
		var toEventSignature_js_1 = toEventSignature;
		Object.defineProperty(exports, "toEventSignature", { enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } });
		Object.defineProperty(exports, "getEventSignature", { enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } });
		var toFunctionSignature_js_1 = toFunctionSignature;
		Object.defineProperty(exports, "toFunctionSignature", { enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } });
		Object.defineProperty(exports, "getFunctionSignature", { enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } });
		var toEventHash_js_1 = toEventHash;
		Object.defineProperty(exports, "toEventHash", { enumerable: true, get: function () { return toEventHash_js_1.toEventHash; } });
		var toFunctionHash_js_1 = toFunctionHash;
		Object.defineProperty(exports, "toFunctionHash", { enumerable: true, get: function () { return toFunctionHash_js_1.toFunctionHash; } });
		var isHash_js_1 = isHash$1;
		Object.defineProperty(exports, "isHash", { enumerable: true, get: function () { return isHash_js_1.isHash; } });
		var keccak256_js_1 = keccak256$3;
		Object.defineProperty(exports, "keccak256", { enumerable: true, get: function () { return keccak256_js_1.keccak256; } });
		var sha256_js_1 = sha256$1;
		Object.defineProperty(exports, "sha256", { enumerable: true, get: function () { return sha256_js_1.sha256; } });
		var ripemd160_js_1 = ripemd160$2;
		Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } });
		var hashTypedData_js_1 = requireHashTypedData();
		Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function () { return hashTypedData_js_1.hashTypedData; } });
		var recoverAddress_js_1 = recoverAddress$1;
		Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function () { return recoverAddress_js_1.recoverAddress; } });
		var recoverMessageAddress_js_1 = recoverMessageAddress$1;
		Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function () { return recoverMessageAddress_js_1.recoverMessageAddress; } });
		var recoverPublicKey_js_1 = recoverPublicKey$1;
		Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function () { return recoverPublicKey_js_1.recoverPublicKey; } });
		var recoverTypedDataAddress_js_1 = recoverTypedDataAddress$1;
		Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function () { return recoverTypedDataAddress_js_1.recoverTypedDataAddress; } });
		var verifyHash_js_1 = verifyHash$5;
		Object.defineProperty(exports, "verifyHash", { enumerable: true, get: function () { return verifyHash_js_1.verifyHash; } });
		var verifyMessage_js_1 = verifyMessage$3;
		Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function () { return verifyMessage_js_1.verifyMessage; } });
		var verifyTypedData_js_1 = verifyTypedData$5;
		Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function () { return verifyTypedData_js_1.verifyTypedData; } });
		var hashMessage_js_1 = hashMessage$1;
		Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function () { return hashMessage_js_1.hashMessage; } });
		var parseErc6492Signature_js_1 = parseErc6492Signature$1;
		Object.defineProperty(exports, "parseErc6492Signature", { enumerable: true, get: function () { return parseErc6492Signature_js_1.parseErc6492Signature; } });
		var isErc6492Signature_js_1 = isErc6492Signature$3;
		Object.defineProperty(exports, "isErc6492Signature", { enumerable: true, get: function () { return isErc6492Signature_js_1.isErc6492Signature; } });
		var serializeErc6492Signature_js_1 = serializeErc6492Signature$3;
		Object.defineProperty(exports, "serializeErc6492Signature", { enumerable: true, get: function () { return serializeErc6492Signature_js_1.serializeErc6492Signature; } });
		var getSerializedTransactionType_js_1 = getSerializedTransactionType$1;
		Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function () { return getSerializedTransactionType_js_1.getSerializedTransactionType; } });
		var getTransactionType_js_1 = getTransactionType$1;
		Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function () { return getTransactionType_js_1.getTransactionType; } });
		var assertRequest_js_1 = assertRequest$1;
		Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function () { return assertRequest_js_1.assertRequest; } });
		var assertTransaction_js_1 = assertTransaction;
		Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP1559; } });
		Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP2930; } });
		Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionLegacy; } });
		var parseTransaction_js_1 = parseTransaction$1;
		Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function () { return parseTransaction_js_1.parseTransaction; } });
		var serializeTransaction_js_1 = requireSerializeTransaction();
		Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function () { return serializeTransaction_js_1.serializeTransaction; } });
		var serializeAccessList_js_1 = serializeAccessList$1;
		Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function () { return serializeAccessList_js_1.serializeAccessList; } });
		var formatEther_js_1 = formatEther$1;
		Object.defineProperty(exports, "formatEther", { enumerable: true, get: function () { return formatEther_js_1.formatEther; } });
		var formatGwei_js_1 = formatGwei$1;
		Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function () { return formatGwei_js_1.formatGwei; } });
		var formatUnits_js_1 = formatUnits$1;
		Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function () { return formatUnits_js_1.formatUnits; } });
		var parseUnits_js_1 = parseUnits$1;
		Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function () { return parseUnits_js_1.parseUnits; } });
		var parseEther_js_1 = parseEther$1;
		Object.defineProperty(exports, "parseEther", { enumerable: true, get: function () { return parseEther_js_1.parseEther; } });
		var parseGwei_js_1 = parseGwei$1;
		Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function () { return parseGwei_js_1.parseGwei; } });
		var nonceManager_js_1 = nonceManager;
		Object.defineProperty(exports, "createNonceManager", { enumerable: true, get: function () { return nonceManager_js_1.createNonceManager; } });
		Object.defineProperty(exports, "nonceManager", { enumerable: true, get: function () { return nonceManager_js_1.nonceManager; } });
		
	} (utils$2));

	Object.defineProperty(proof, "__esModule", { value: true });
	proof.formatProof = formatProof;
	const index_js_1 = utils$2;
	function formatStorageProof(storageProof) {
	    return storageProof.map((proof) => ({
	        ...proof,
	        value: BigInt(proof.value),
	    }));
	}
	function formatProof(proof) {
	    return {
	        ...proof,
	        balance: proof.balance ? BigInt(proof.balance) : undefined,
	        nonce: proof.nonce ? (0, index_js_1.hexToNumber)(proof.nonce) : undefined,
	        storageProof: proof.storageProof
	            ? formatStorageProof(proof.storageProof)
	            : undefined,
	    };
	}

	Object.defineProperty(getProof$1, "__esModule", { value: true });
	getProof$1.getProof = getProof;
	const toHex_js_1$l = requireToHex();
	const proof_js_1 = proof;
	async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys, }) {
	    const blockTag = blockTag_ ?? 'latest';
	    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1$l.numberToHex)(blockNumber) : undefined;
	    const proof = await client.request({
	        method: 'eth_getProof',
	        params: [address, storageKeys, blockNumberHex || blockTag],
	    });
	    return (0, proof_js_1.formatProof)(proof);
	}

	var getStorageAt$1 = {};

	Object.defineProperty(getStorageAt$1, "__esModule", { value: true });
	getStorageAt$1.getStorageAt = getStorageAt;
	const toHex_js_1$k = requireToHex();
	async function getStorageAt(client, { address, blockNumber, blockTag = 'latest', slot }) {
	    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1$k.numberToHex)(blockNumber) : undefined;
	    const data = await client.request({
	        method: 'eth_getStorageAt',
	        params: [address, slot, blockNumberHex || blockTag],
	    });
	    return data;
	}

	var getTransaction$1 = {};

	Object.defineProperty(getTransaction$1, "__esModule", { value: true });
	getTransaction$1.getTransaction = getTransaction;
	const transaction_js_1$2 = transaction$1;
	const toHex_js_1$j = requireToHex();
	const transaction_js_2 = transaction;
	async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index, }) {
	    const blockTag = blockTag_ || 'latest';
	    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1$j.numberToHex)(blockNumber) : undefined;
	    let transaction = null;
	    if (hash) {
	        transaction = await client.request({
	            method: 'eth_getTransactionByHash',
	            params: [hash],
	        }, { dedupe: true });
	    }
	    else if (blockHash) {
	        transaction = await client.request({
	            method: 'eth_getTransactionByBlockHashAndIndex',
	            params: [blockHash, (0, toHex_js_1$j.numberToHex)(index)],
	        }, { dedupe: true });
	    }
	    else if (blockNumberHex || blockTag) {
	        transaction = await client.request({
	            method: 'eth_getTransactionByBlockNumberAndIndex',
	            params: [blockNumberHex || blockTag, (0, toHex_js_1$j.numberToHex)(index)],
	        }, { dedupe: Boolean(blockNumberHex) });
	    }
	    if (!transaction)
	        throw new transaction_js_1$2.TransactionNotFoundError({
	            blockHash,
	            blockNumber,
	            blockTag,
	            hash,
	            index,
	        });
	    const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
	    return format(transaction);
	}

	var getTransactionConfirmations$1 = {};

	Object.defineProperty(getTransactionConfirmations$1, "__esModule", { value: true });
	getTransactionConfirmations$1.getTransactionConfirmations = getTransactionConfirmations;
	const getAction_js_1$8 = getAction$1;
	const getBlockNumber_js_1$3 = getBlockNumber$1;
	const getTransaction_js_1$2 = getTransaction$1;
	async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
	    const [blockNumber, transaction] = await Promise.all([
	        (0, getAction_js_1$8.getAction)(client, getBlockNumber_js_1$3.getBlockNumber, 'getBlockNumber')({}),
	        hash
	            ? (0, getAction_js_1$8.getAction)(client, getTransaction_js_1$2.getTransaction, 'getTransaction')({ hash })
	            : undefined,
	    ]);
	    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
	    if (!transactionBlockNumber)
	        return 0n;
	    return blockNumber - transactionBlockNumber + 1n;
	}

	var getTransactionReceipt$1 = {};

	Object.defineProperty(getTransactionReceipt$1, "__esModule", { value: true });
	getTransactionReceipt$1.getTransactionReceipt = getTransactionReceipt;
	const transaction_js_1$1 = transaction$1;
	const transactionReceipt_js_1 = transactionReceipt;
	async function getTransactionReceipt(client, { hash }) {
	    const receipt = await client.request({
	        method: 'eth_getTransactionReceipt',
	        params: [hash],
	    }, { dedupe: true });
	    if (!receipt)
	        throw new transaction_js_1$1.TransactionReceiptNotFoundError({ hash });
	    const format = client.chain?.formatters?.transactionReceipt?.format ||
	        transactionReceipt_js_1.formatTransactionReceipt;
	    return format(receipt);
	}

	var multicall$1 = {};

	Object.defineProperty(multicall$1, "__esModule", { value: true });
	multicall$1.multicall = multicall;
	const abis_js_1$1 = abis;
	const abi_js_1$2 = requireAbi();
	const base_js_1$1 = base$1;
	const contract_js_1$4 = contract$2;
	const decodeFunctionResult_js_1 = decodeFunctionResult$1;
	const encodeFunctionData_js_1 = encodeFunctionData$1;
	const getChainContractAddress_js_1 = getChainContractAddress$1;
	const getContractError_js_1 = getContractError$1;
	const getAction_js_1$7 = getAction$1;
	const readContract_js_1$1 = readContract$3;
	async function multicall(client, parameters) {
	    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride, } = parameters;
	    const contracts = parameters.contracts;
	    const batchSize = batchSize_ ??
	        ((typeof client.batch?.multicall === 'object' &&
	            client.batch.multicall.batchSize) ||
	            1_024);
	    let multicallAddress = multicallAddress_;
	    if (!multicallAddress) {
	        if (!client.chain)
	            throw new Error('client chain not configured. multicallAddress is required.');
	        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
	            blockNumber,
	            chain: client.chain,
	            contract: 'multicall3',
	        });
	    }
	    const chunkedCalls = [[]];
	    let currentChunk = 0;
	    let currentChunkSize = 0;
	    for (let i = 0; i < contracts.length; i++) {
	        const { abi, address, args, functionName } = contracts[i];
	        try {
	            const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({ abi, args, functionName });
	            currentChunkSize += (callData.length - 2) / 2;
	            if (batchSize > 0 &&
	                currentChunkSize > batchSize &&
	                chunkedCalls[currentChunk].length > 0) {
	                currentChunk++;
	                currentChunkSize = (callData.length - 2) / 2;
	                chunkedCalls[currentChunk] = [];
	            }
	            chunkedCalls[currentChunk] = [
	                ...chunkedCalls[currentChunk],
	                {
	                    allowFailure: true,
	                    callData,
	                    target: address,
	                },
	            ];
	        }
	        catch (err) {
	            const error = (0, getContractError_js_1.getContractError)(err, {
	                abi,
	                address,
	                args,
	                docsPath: '/docs/contract/multicall',
	                functionName,
	            });
	            if (!allowFailure)
	                throw error;
	            chunkedCalls[currentChunk] = [
	                ...chunkedCalls[currentChunk],
	                {
	                    allowFailure: true,
	                    callData: '0x',
	                    target: address,
	                },
	            ];
	        }
	    }
	    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, getAction_js_1$7.getAction)(client, readContract_js_1$1.readContract, 'readContract')({
	        abi: abis_js_1$1.multicall3Abi,
	        address: multicallAddress,
	        args: [calls],
	        blockNumber,
	        blockTag,
	        functionName: 'aggregate3',
	        stateOverride,
	    })));
	    const results = [];
	    for (let i = 0; i < aggregate3Results.length; i++) {
	        const result = aggregate3Results[i];
	        if (result.status === 'rejected') {
	            if (!allowFailure)
	                throw result.reason;
	            for (let j = 0; j < chunkedCalls[i].length; j++) {
	                results.push({
	                    status: 'failure',
	                    error: result.reason,
	                    result: undefined,
	                });
	            }
	            continue;
	        }
	        const aggregate3Result = result.value;
	        for (let j = 0; j < aggregate3Result.length; j++) {
	            const { returnData, success } = aggregate3Result[j];
	            const { callData } = chunkedCalls[i][j];
	            const { abi, address, functionName, args } = contracts[results.length];
	            try {
	                if (callData === '0x')
	                    throw new abi_js_1$2.AbiDecodingZeroDataError();
	                if (!success)
	                    throw new contract_js_1$4.RawContractError({ data: returnData });
	                const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
	                    abi,
	                    args,
	                    data: returnData,
	                    functionName,
	                });
	                results.push(allowFailure ? { result, status: 'success' } : result);
	            }
	            catch (err) {
	                const error = (0, getContractError_js_1.getContractError)(err, {
	                    abi,
	                    address,
	                    args,
	                    docsPath: '/docs/contract/multicall',
	                    functionName,
	                });
	                if (!allowFailure)
	                    throw error;
	                results.push({ error, result: undefined, status: 'failure' });
	            }
	        }
	    }
	    if (results.length !== contracts.length)
	        throw new base_js_1$1.BaseError('multicall results mismatch');
	    return results;
	}

	var verifyMessage$1 = {};

	var verifyHash$3 = {};

	var isBytesEqual$1 = {};

	Object.defineProperty(isBytesEqual$1, "__esModule", { value: true });
	isBytesEqual$1.isBytesEqual = isBytesEqual;
	const utils_1$2 = utils$4;
	const toBytes_js_1$4 = requireToBytes();
	const isHex_js_1$1 = isHex$1;
	function isBytesEqual(a_, b_) {
	    const a = (0, isHex_js_1$1.isHex)(a_) ? (0, toBytes_js_1$4.toBytes)(a_) : a_;
	    const b = (0, isHex_js_1$1.isHex)(b_) ? (0, toBytes_js_1$4.toBytes)(b_) : b_;
	    return (0, utils_1$2.equalBytes)(a, b);
	}

	var serializeSignature$1 = {};

	Object.defineProperty(serializeSignature$1, "__esModule", { value: true });
	serializeSignature$1.serializeSignature = serializeSignature;
	const secp256k1_1$4 = secp256k1;
	const fromHex_js_1$3 = requireFromHex();
	const toBytes_js_1$3 = requireToBytes();
	function serializeSignature({ r, s, to = 'hex', v, yParity, }) {
	    const yParity_ = (() => {
	        if (yParity === 0 || yParity === 1)
	            return yParity;
	        if (v && (v === 27n || v === 28n || v >= 35n))
	            return v % 2n === 0n ? 1 : 0;
	        throw new Error('Invalid `v` or `yParity` value');
	    })();
	    const signature = `0x${new secp256k1_1$4.secp256k1.Signature((0, fromHex_js_1$3.hexToBigInt)(r), (0, fromHex_js_1$3.hexToBigInt)(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;
	    if (to === 'hex')
	        return signature;
	    return (0, toBytes_js_1$3.hexToBytes)(signature);
	}

	Object.defineProperty(verifyHash$3, "__esModule", { value: true });
	verifyHash$3.verifyHash = verifyHash$2;
	const abis_js_1 = abis;
	const contracts_js_1 = contracts;
	const contract_js_1$3 = contract$2;
	const encodeDeployData_js_1$1 = encodeDeployData$1;
	const getAddress_js_1$2 = requireGetAddress();
	const isAddressEqual_js_1$1 = isAddressEqual$1;
	const isBytesEqual_js_1 = isBytesEqual$1;
	const isHex_js_1 = isHex$1;
	const toHex_js_1$i = requireToHex();
	const getAction_js_1$6 = getAction$1;
	const isErc6492Signature_js_1 = isErc6492Signature$3;
	const recoverAddress_js_1$1 = recoverAddress$1;
	const serializeErc6492Signature_js_1 = serializeErc6492Signature$3;
	const serializeSignature_js_1 = serializeSignature$1;
	const call_js_1$1 = requireCall();
	async function verifyHash$2(client, parameters) {
	    const { address, factory, factoryData, hash, signature, ...rest } = parameters;
	    const signatureHex = (() => {
	        if ((0, isHex_js_1.isHex)(signature))
	            return signature;
	        if (typeof signature === 'object' && 'r' in signature && 's' in signature)
	            return (0, serializeSignature_js_1.serializeSignature)(signature);
	        return (0, toHex_js_1$i.bytesToHex)(signature);
	    })();
	    const wrappedSignature = await (async () => {
	        if (!factory && !factoryData)
	            return signatureHex;
	        if ((0, isErc6492Signature_js_1.isErc6492Signature)(signatureHex))
	            return signatureHex;
	        return (0, serializeErc6492Signature_js_1.serializeErc6492Signature)({
	            address: factory,
	            data: factoryData,
	            signature: signatureHex,
	        });
	    })();
	    try {
	        const { data } = await (0, getAction_js_1$6.getAction)(client, call_js_1$1.call, 'call')({
	            data: (0, encodeDeployData_js_1$1.encodeDeployData)({
	                abi: abis_js_1.universalSignatureValidatorAbi,
	                args: [address, hash, wrappedSignature],
	                bytecode: contracts_js_1.universalSignatureValidatorByteCode,
	            }),
	            ...rest,
	        });
	        return (0, isBytesEqual_js_1.isBytesEqual)(data ?? '0x0', '0x1');
	    }
	    catch (error) {
	        try {
	            const verified = (0, isAddressEqual_js_1$1.isAddressEqual)((0, getAddress_js_1$2.getAddress)(address), await (0, recoverAddress_js_1$1.recoverAddress)({ hash, signature }));
	            if (verified)
	                return true;
	        }
	        catch { }
	        if (error instanceof contract_js_1$3.CallExecutionError) {
	            return false;
	        }
	        throw error;
	    }
	}

	Object.defineProperty(verifyMessage$1, "__esModule", { value: true });
	verifyMessage$1.verifyMessage = verifyMessage;
	const hashMessage_js_1$1 = hashMessage$1;
	const verifyHash_js_1$2 = verifyHash$3;
	async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {
	    const hash = (0, hashMessage_js_1$1.hashMessage)(message);
	    return (0, verifyHash_js_1$2.verifyHash)(client, {
	        address,
	        factory: factory,
	        factoryData: factoryData,
	        hash,
	        signature,
	        ...callRequest,
	    });
	}

	var verifyTypedData$3 = {};

	Object.defineProperty(verifyTypedData$3, "__esModule", { value: true });
	verifyTypedData$3.verifyTypedData = verifyTypedData$2;
	const hashTypedData_js_1 = requireHashTypedData();
	const verifyHash_js_1$1 = verifyHash$3;
	async function verifyTypedData$2(client, parameters) {
	    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
	    const hash = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
	    return (0, verifyHash_js_1$1.verifyHash)(client, {
	        address,
	        factory: factory,
	        factoryData: factoryData,
	        hash,
	        signature,
	        ...callRequest,
	    });
	}

	var waitForTransactionReceipt$1 = {};

	var watchBlockNumber$1 = {};

	Object.defineProperty(watchBlockNumber$1, "__esModule", { value: true });
	watchBlockNumber$1.watchBlockNumber = watchBlockNumber;
	const fromHex_js_1$2 = requireFromHex();
	const getAction_js_1$5 = getAction$1;
	const observe_js_1$4 = observe;
	const poll_js_1$3 = poll$1;
	const stringify_js_1$4 = stringify$1;
	const getBlockNumber_js_1$2 = getBlockNumber$1;
	function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, }) {
	    const enablePolling = (() => {
	        if (typeof poll_ !== 'undefined')
	            return poll_;
	        if (client.transport.type === 'webSocket')
	            return false;
	        if (client.transport.type === 'fallback' &&
	            client.transport.transports[0].config.type === 'webSocket')
	            return false;
	        return true;
	    })();
	    let prevBlockNumber;
	    const pollBlockNumber = () => {
	        const observerId = (0, stringify_js_1$4.stringify)([
	            'watchBlockNumber',
	            client.uid,
	            emitOnBegin,
	            emitMissed,
	            pollingInterval,
	        ]);
	        return (0, observe_js_1$4.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1$3.poll)(async () => {
	            try {
	                const blockNumber = await (0, getAction_js_1$5.getAction)(client, getBlockNumber_js_1$2.getBlockNumber, 'getBlockNumber')({ cacheTime: 0 });
	                if (prevBlockNumber) {
	                    if (blockNumber === prevBlockNumber)
	                        return;
	                    if (blockNumber - prevBlockNumber > 1 && emitMissed) {
	                        for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
	                            emit.onBlockNumber(i, prevBlockNumber);
	                            prevBlockNumber = i;
	                        }
	                    }
	                }
	                if (!prevBlockNumber || blockNumber > prevBlockNumber) {
	                    emit.onBlockNumber(blockNumber, prevBlockNumber);
	                    prevBlockNumber = blockNumber;
	                }
	            }
	            catch (err) {
	                emit.onError?.(err);
	            }
	        }, {
	            emitOnBegin,
	            interval: pollingInterval,
	        }));
	    };
	    const subscribeBlockNumber = () => {
	        const observerId = (0, stringify_js_1$4.stringify)([
	            'watchBlockNumber',
	            client.uid,
	            emitOnBegin,
	            emitMissed,
	        ]);
	        return (0, observe_js_1$4.observe)(observerId, { onBlockNumber, onError }, (emit) => {
	            let active = true;
	            let unsubscribe = () => (active = false);
	            (async () => {
	                try {
	                    const transport = (() => {
	                        if (client.transport.type === 'fallback') {
	                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');
	                            if (!transport)
	                                return client.transport;
	                            return transport.value;
	                        }
	                        return client.transport;
	                    })();
	                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
	                        params: ['newHeads'],
	                        onData(data) {
	                            if (!active)
	                                return;
	                            const blockNumber = (0, fromHex_js_1$2.hexToBigInt)(data.result?.number);
	                            emit.onBlockNumber(blockNumber, prevBlockNumber);
	                            prevBlockNumber = blockNumber;
	                        },
	                        onError(error) {
	                            emit.onError?.(error);
	                        },
	                    });
	                    unsubscribe = unsubscribe_;
	                    if (!active)
	                        unsubscribe();
	                }
	                catch (err) {
	                    onError?.(err);
	                }
	            })();
	            return () => unsubscribe();
	        });
	    };
	    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
	}

	Object.defineProperty(waitForTransactionReceipt$1, "__esModule", { value: true });
	waitForTransactionReceipt$1.waitForTransactionReceipt = waitForTransactionReceipt;
	const block_js_1$1 = block$1;
	const transaction_js_1 = transaction$1;
	const getAction_js_1$4 = getAction$1;
	const observe_js_1$3 = observe;
	const withRetry_js_1 = withRetry$1;
	const stringify_js_1$3 = stringify$1;
	const getBlock_js_1$2 = getBlock$1;
	const getTransaction_js_1$1 = getTransaction$1;
	const getTransactionReceipt_js_1$1 = getTransactionReceipt$1;
	const watchBlockNumber_js_1$2 = watchBlockNumber$1;
	async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, retryCount = 6, retryDelay = ({ count }) => ~~(1 << count) * 200, timeout, }) {
	    const observerId = (0, stringify_js_1$3.stringify)(['waitForTransactionReceipt', client.uid, hash]);
	    let count = 0;
	    let transaction;
	    let replacedTransaction;
	    let receipt;
	    let retrying = false;
	    return new Promise((resolve, reject) => {
	        if (timeout)
	            setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash })), timeout);
	        const _unobserve = (0, observe_js_1$3.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
	            const _unwatch = (0, getAction_js_1$4.getAction)(client, watchBlockNumber_js_1$2.watchBlockNumber, 'watchBlockNumber')({
	                emitMissed: true,
	                emitOnBegin: true,
	                poll: true,
	                pollingInterval,
	                async onBlockNumber(blockNumber_) {
	                    const done = (fn) => {
	                        _unwatch();
	                        fn();
	                        _unobserve();
	                    };
	                    let blockNumber = blockNumber_;
	                    if (retrying)
	                        return;
	                    if (count > retryCount)
	                        done(() => emit.reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash })));
	                    try {
	                        if (receipt) {
	                            if (confirmations > 1 &&
	                                (!receipt.blockNumber ||
	                                    blockNumber - receipt.blockNumber + 1n < confirmations))
	                                return;
	                            done(() => emit.resolve(receipt));
	                            return;
	                        }
	                        if (!transaction) {
	                            retrying = true;
	                            await (0, withRetry_js_1.withRetry)(async () => {
	                                transaction = (await (0, getAction_js_1$4.getAction)(client, getTransaction_js_1$1.getTransaction, 'getTransaction')({ hash }));
	                                if (transaction.blockNumber)
	                                    blockNumber = transaction.blockNumber;
	                            }, {
	                                delay: retryDelay,
	                                retryCount,
	                            });
	                            retrying = false;
	                        }
	                        receipt = await (0, getAction_js_1$4.getAction)(client, getTransactionReceipt_js_1$1.getTransactionReceipt, 'getTransactionReceipt')({ hash });
	                        if (confirmations > 1 &&
	                            (!receipt.blockNumber ||
	                                blockNumber - receipt.blockNumber + 1n < confirmations))
	                            return;
	                        done(() => emit.resolve(receipt));
	                    }
	                    catch (err) {
	                        if (err instanceof transaction_js_1.TransactionNotFoundError ||
	                            err instanceof transaction_js_1.TransactionReceiptNotFoundError) {
	                            if (!transaction) {
	                                retrying = false;
	                                return;
	                            }
	                            try {
	                                replacedTransaction = transaction;
	                                retrying = true;
	                                const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1$4.getAction)(client, getBlock_js_1$2.getBlock, 'getBlock')({
	                                    blockNumber,
	                                    includeTransactions: true,
	                                }), {
	                                    delay: retryDelay,
	                                    retryCount,
	                                    shouldRetry: ({ error }) => error instanceof block_js_1$1.BlockNotFoundError,
	                                });
	                                retrying = false;
	                                const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from &&
	                                    nonce === replacedTransaction.nonce);
	                                if (!replacementTransaction)
	                                    return;
	                                receipt = await (0, getAction_js_1$4.getAction)(client, getTransactionReceipt_js_1$1.getTransactionReceipt, 'getTransactionReceipt')({
	                                    hash: replacementTransaction.hash,
	                                });
	                                if (confirmations > 1 &&
	                                    (!receipt.blockNumber ||
	                                        blockNumber - receipt.blockNumber + 1n < confirmations))
	                                    return;
	                                let reason = 'replaced';
	                                if (replacementTransaction.to === replacedTransaction.to &&
	                                    replacementTransaction.value === replacedTransaction.value) {
	                                    reason = 'repriced';
	                                }
	                                else if (replacementTransaction.from === replacementTransaction.to &&
	                                    replacementTransaction.value === 0n) {
	                                    reason = 'cancelled';
	                                }
	                                done(() => {
	                                    emit.onReplaced?.({
	                                        reason,
	                                        replacedTransaction: replacedTransaction,
	                                        transaction: replacementTransaction,
	                                        transactionReceipt: receipt,
	                                    });
	                                    emit.resolve(receipt);
	                                });
	                            }
	                            catch (err_) {
	                                done(() => emit.reject(err_));
	                            }
	                        }
	                        else {
	                            done(() => emit.reject(err));
	                        }
	                    }
	                    finally {
	                        count++;
	                    }
	                },
	            });
	        });
	    });
	}

	var watchBlocks$1 = {};

	Object.defineProperty(watchBlocks$1, "__esModule", { value: true });
	watchBlocks$1.watchBlocks = watchBlocks;
	const block_js_1 = block;
	const getAction_js_1$3 = getAction$1;
	const observe_js_1$2 = observe;
	const poll_js_1$2 = poll$1;
	const stringify_js_1$2 = stringify$1;
	const getBlock_js_1$1 = getBlock$1;
	function watchBlocks(client, { blockTag = 'latest', emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval, }) {
	    const enablePolling = (() => {
	        if (typeof poll_ !== 'undefined')
	            return poll_;
	        if (client.transport.type === 'webSocket')
	            return false;
	        if (client.transport.type === 'fallback' &&
	            client.transport.transports[0].config.type === 'webSocket')
	            return false;
	        return true;
	    })();
	    const includeTransactions = includeTransactions_ ?? false;
	    let prevBlock;
	    const pollBlocks = () => {
	        const observerId = (0, stringify_js_1$2.stringify)([
	            'watchBlocks',
	            client.uid,
	            blockTag,
	            emitMissed,
	            emitOnBegin,
	            includeTransactions,
	            pollingInterval,
	        ]);
	        return (0, observe_js_1$2.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1$2.poll)(async () => {
	            try {
	                const block = await (0, getAction_js_1$3.getAction)(client, getBlock_js_1$1.getBlock, 'getBlock')({
	                    blockTag,
	                    includeTransactions,
	                });
	                if (block.number && prevBlock?.number) {
	                    if (block.number === prevBlock.number)
	                        return;
	                    if (block.number - prevBlock.number > 1 && emitMissed) {
	                        for (let i = prevBlock?.number + 1n; i < block.number; i++) {
	                            const block = (await (0, getAction_js_1$3.getAction)(client, getBlock_js_1$1.getBlock, 'getBlock')({
	                                blockNumber: i,
	                                includeTransactions,
	                            }));
	                            emit.onBlock(block, prevBlock);
	                            prevBlock = block;
	                        }
	                    }
	                }
	                if (!prevBlock?.number ||
	                    (blockTag === 'pending' && !block?.number) ||
	                    (block.number && block.number > prevBlock.number)) {
	                    emit.onBlock(block, prevBlock);
	                    prevBlock = block;
	                }
	            }
	            catch (err) {
	                emit.onError?.(err);
	            }
	        }, {
	            emitOnBegin,
	            interval: pollingInterval,
	        }));
	    };
	    const subscribeBlocks = () => {
	        let active = true;
	        let unsubscribe = () => (active = false);
	        (async () => {
	            try {
	                const transport = (() => {
	                    if (client.transport.type === 'fallback') {
	                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');
	                        if (!transport)
	                            return client.transport;
	                        return transport.value;
	                    }
	                    return client.transport;
	                })();
	                const { unsubscribe: unsubscribe_ } = await transport.subscribe({
	                    params: ['newHeads'],
	                    onData(data) {
	                        if (!active)
	                            return;
	                        const format = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
	                        const block = format(data.result);
	                        onBlock(block, prevBlock);
	                        prevBlock = block;
	                    },
	                    onError(error) {
	                        onError?.(error);
	                    },
	                });
	                unsubscribe = unsubscribe_;
	                if (!active)
	                    unsubscribe();
	            }
	            catch (err) {
	                onError?.(err);
	            }
	        })();
	        return () => unsubscribe();
	    };
	    return enablePolling ? pollBlocks() : subscribeBlocks();
	}

	var watchEvent$1 = {};

	Object.defineProperty(watchEvent$1, "__esModule", { value: true });
	watchEvent$1.watchEvent = watchEvent;
	const encodeEventTopics_js_1 = encodeEventTopics$1;
	const observe_js_1$1 = observe;
	const poll_js_1$1 = poll$1;
	const stringify_js_1$1 = stringify$1;
	const abi_js_1$1 = requireAbi();
	const rpc_js_1$8 = rpc;
	const decodeEventLog_js_1 = decodeEventLog$1;
	const log_js_1 = log;
	const getAction_js_1$2 = getAction$1;
	const createEventFilter_js_1$1 = createEventFilter$1;
	const getBlockNumber_js_1$1 = getBlockNumber$1;
	const getFilterChanges_js_1$2 = getFilterChanges$1;
	const getLogs_js_1$1 = getLogs$1;
	const uninstallFilter_js_1$2 = uninstallFilter$1;
	function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, }) {
	    const enablePolling = (() => {
	        if (typeof poll_ !== 'undefined')
	            return poll_;
	        if (typeof fromBlock === 'bigint')
	            return true;
	        if (client.transport.type === 'webSocket')
	            return false;
	        if (client.transport.type === 'fallback' &&
	            client.transport.transports[0].config.type === 'webSocket')
	            return false;
	        return true;
	    })();
	    const strict = strict_ ?? false;
	    const pollEvent = () => {
	        const observerId = (0, stringify_js_1$1.stringify)([
	            'watchEvent',
	            address,
	            args,
	            batch,
	            client.uid,
	            event,
	            pollingInterval,
	            fromBlock,
	        ]);
	        return (0, observe_js_1$1.observe)(observerId, { onLogs, onError }, (emit) => {
	            let previousBlockNumber;
	            if (fromBlock !== undefined)
	                previousBlockNumber = fromBlock - 1n;
	            let filter;
	            let initialized = false;
	            const unwatch = (0, poll_js_1$1.poll)(async () => {
	                if (!initialized) {
	                    try {
	                        filter = (await (0, getAction_js_1$2.getAction)(client, createEventFilter_js_1$1.createEventFilter, 'createEventFilter')({
	                            address,
	                            args,
	                            event: event,
	                            events,
	                            strict,
	                            fromBlock,
	                        }));
	                    }
	                    catch { }
	                    initialized = true;
	                    return;
	                }
	                try {
	                    let logs;
	                    if (filter) {
	                        logs = await (0, getAction_js_1$2.getAction)(client, getFilterChanges_js_1$2.getFilterChanges, 'getFilterChanges')({ filter });
	                    }
	                    else {
	                        const blockNumber = await (0, getAction_js_1$2.getAction)(client, getBlockNumber_js_1$1.getBlockNumber, 'getBlockNumber')({});
	                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {
	                            logs = await (0, getAction_js_1$2.getAction)(client, getLogs_js_1$1.getLogs, 'getLogs')({
	                                address,
	                                args,
	                                event: event,
	                                events,
	                                fromBlock: previousBlockNumber + 1n,
	                                toBlock: blockNumber,
	                            });
	                        }
	                        else {
	                            logs = [];
	                        }
	                        previousBlockNumber = blockNumber;
	                    }
	                    if (logs.length === 0)
	                        return;
	                    if (batch)
	                        emit.onLogs(logs);
	                    else
	                        for (const log of logs)
	                            emit.onLogs([log]);
	                }
	                catch (err) {
	                    if (filter && err instanceof rpc_js_1$8.InvalidInputRpcError)
	                        initialized = false;
	                    emit.onError?.(err);
	                }
	            }, {
	                emitOnBegin: true,
	                interval: pollingInterval,
	            });
	            return async () => {
	                if (filter)
	                    await (0, getAction_js_1$2.getAction)(client, uninstallFilter_js_1$2.uninstallFilter, 'uninstallFilter')({ filter });
	                unwatch();
	            };
	        });
	    };
	    const subscribeEvent = () => {
	        let active = true;
	        let unsubscribe = () => (active = false);
	        (async () => {
	            try {
	                const transport = (() => {
	                    if (client.transport.type === 'fallback') {
	                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');
	                        if (!transport)
	                            return client.transport;
	                        return transport.value;
	                    }
	                    return client.transport;
	                })();
	                const events_ = events ?? (event ? [event] : undefined);
	                let topics = [];
	                if (events_) {
	                    const encoded = events_.flatMap((event) => (0, encodeEventTopics_js_1.encodeEventTopics)({
	                        abi: [event],
	                        eventName: event.name,
	                        args,
	                    }));
	                    topics = [encoded];
	                    if (event)
	                        topics = topics[0];
	                }
	                const { unsubscribe: unsubscribe_ } = await transport.subscribe({
	                    params: ['logs', { address, topics }],
	                    onData(data) {
	                        if (!active)
	                            return;
	                        const log = data.result;
	                        try {
	                            const { eventName, args } = (0, decodeEventLog_js_1.decodeEventLog)({
	                                abi: events_ ?? [],
	                                data: log.data,
	                                topics: log.topics,
	                                strict,
	                            });
	                            const formatted = (0, log_js_1.formatLog)(log, { args, eventName });
	                            onLogs([formatted]);
	                        }
	                        catch (err) {
	                            let eventName;
	                            let isUnnamed;
	                            if (err instanceof abi_js_1$1.DecodeLogDataMismatch ||
	                                err instanceof abi_js_1$1.DecodeLogTopicsMismatch) {
	                                if (strict_)
	                                    return;
	                                eventName = err.abiItem.name;
	                                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
	                            }
	                            const formatted = (0, log_js_1.formatLog)(log, {
	                                args: isUnnamed ? [] : {},
	                                eventName,
	                            });
	                            onLogs([formatted]);
	                        }
	                    },
	                    onError(error) {
	                        onError?.(error);
	                    },
	                });
	                unsubscribe = unsubscribe_;
	                if (!active)
	                    unsubscribe();
	            }
	            catch (err) {
	                onError?.(err);
	            }
	        })();
	        return () => unsubscribe();
	    };
	    return enablePolling ? pollEvent() : subscribeEvent();
	}

	var watchPendingTransactions$1 = {};

	Object.defineProperty(watchPendingTransactions$1, "__esModule", { value: true });
	watchPendingTransactions$1.watchPendingTransactions = watchPendingTransactions;
	const getAction_js_1$1 = getAction$1;
	const observe_js_1 = observe;
	const poll_js_1 = poll$1;
	const stringify_js_1 = stringify$1;
	const createPendingTransactionFilter_js_1$1 = createPendingTransactionFilter$1;
	const getFilterChanges_js_1$1 = getFilterChanges$1;
	const uninstallFilter_js_1$1 = uninstallFilter$1;
	function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval, }) {
	    const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
	    const pollPendingTransactions = () => {
	        const observerId = (0, stringify_js_1.stringify)([
	            'watchPendingTransactions',
	            client.uid,
	            batch,
	            pollingInterval,
	        ]);
	        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
	            let filter;
	            const unwatch = (0, poll_js_1.poll)(async () => {
	                try {
	                    if (!filter) {
	                        try {
	                            filter = await (0, getAction_js_1$1.getAction)(client, createPendingTransactionFilter_js_1$1.createPendingTransactionFilter, 'createPendingTransactionFilter')({});
	                            return;
	                        }
	                        catch (err) {
	                            unwatch();
	                            throw err;
	                        }
	                    }
	                    const hashes = await (0, getAction_js_1$1.getAction)(client, getFilterChanges_js_1$1.getFilterChanges, 'getFilterChanges')({ filter });
	                    if (hashes.length === 0)
	                        return;
	                    if (batch)
	                        emit.onTransactions(hashes);
	                    else
	                        for (const hash of hashes)
	                            emit.onTransactions([hash]);
	                }
	                catch (err) {
	                    emit.onError?.(err);
	                }
	            }, {
	                emitOnBegin: true,
	                interval: pollingInterval,
	            });
	            return async () => {
	                if (filter)
	                    await (0, getAction_js_1$1.getAction)(client, uninstallFilter_js_1$1.uninstallFilter, 'uninstallFilter')({ filter });
	                unwatch();
	            };
	        });
	    };
	    const subscribePendingTransactions = () => {
	        let active = true;
	        let unsubscribe = () => (active = false);
	        (async () => {
	            try {
	                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
	                    params: ['newPendingTransactions'],
	                    onData(data) {
	                        if (!active)
	                            return;
	                        const transaction = data.result;
	                        onTransactions([transaction]);
	                    },
	                    onError(error) {
	                        onError?.(error);
	                    },
	                });
	                unsubscribe = unsubscribe_;
	                if (!active)
	                    unsubscribe();
	            }
	            catch (err) {
	                onError?.(err);
	            }
	        })();
	        return () => unsubscribe();
	    };
	    return enablePolling
	        ? pollPendingTransactions()
	        : subscribePendingTransactions();
	}

	var verifySiweMessage$1 = {};

	var parseSiweMessage$1 = {};

	Object.defineProperty(parseSiweMessage$1, "__esModule", { value: true });
	parseSiweMessage$1.parseSiweMessage = parseSiweMessage;
	function parseSiweMessage(message) {
	    const { scheme, statement, ...prefix } = (message.match(prefixRegex)
	        ?.groups ?? {});
	    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = (message.match(suffixRegex)?.groups ?? {});
	    const resources = message.split('Resources:')[1]?.split('\n- ').slice(1);
	    return {
	        ...prefix,
	        ...suffix,
	        ...(chainId ? { chainId: Number(chainId) } : {}),
	        ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),
	        ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),
	        ...(notBefore ? { notBefore: new Date(notBefore) } : {}),
	        ...(requestId ? { requestId } : {}),
	        ...(resources ? { resources } : {}),
	        ...(scheme ? { scheme } : {}),
	        ...(statement ? { statement } : {}),
	    };
	}
	const prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
	const suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

	var validateSiweMessage$1 = {};

	Object.defineProperty(validateSiweMessage$1, "__esModule", { value: true });
	validateSiweMessage$1.validateSiweMessage = validateSiweMessage;
	const isAddressEqual_js_1 = isAddressEqual$1;
	function validateSiweMessage(parameters) {
	    const { address, domain, message, nonce, scheme, time = new Date(), } = parameters;
	    if (domain && message.domain !== domain)
	        return false;
	    if (nonce && message.nonce !== nonce)
	        return false;
	    if (scheme && message.scheme !== scheme)
	        return false;
	    if (message.expirationTime && time >= message.expirationTime)
	        return false;
	    if (message.notBefore && time < message.notBefore)
	        return false;
	    try {
	        if (!message.address)
	            return false;
	        if (address && !(0, isAddressEqual_js_1.isAddressEqual)(message.address, address))
	            return false;
	    }
	    catch {
	        return false;
	    }
	    return true;
	}

	Object.defineProperty(verifySiweMessage$1, "__esModule", { value: true });
	verifySiweMessage$1.verifySiweMessage = verifySiweMessage;
	const hashMessage_js_1 = hashMessage$1;
	const parseSiweMessage_js_1 = parseSiweMessage$1;
	const validateSiweMessage_js_1 = validateSiweMessage$1;
	const verifyHash_js_1 = verifyHash$3;
	async function verifySiweMessage(client, parameters) {
	    const { address, domain, message, nonce, scheme, signature, time = new Date(), ...callRequest } = parameters;
	    const parsed = (0, parseSiweMessage_js_1.parseSiweMessage)(message);
	    if (!parsed.address)
	        return false;
	    const isValid = (0, validateSiweMessage_js_1.validateSiweMessage)({
	        address,
	        domain,
	        message: parsed,
	        nonce,
	        scheme,
	        time,
	    });
	    if (!isValid)
	        return false;
	    const hash = (0, hashMessage_js_1.hashMessage)(message);
	    return (0, verifyHash_js_1.verifyHash)(client, {
	        address: parsed.address,
	        hash,
	        signature,
	        ...callRequest,
	    });
	}

	Object.defineProperty(_public, "__esModule", { value: true });
	_public.publicActions = publicActions;
	const getEnsAddress_js_1 = getEnsAddress$1;
	const getEnsAvatar_js_1 = getEnsAvatar$1;
	const getEnsName_js_1 = getEnsName$1;
	const getEnsResolver_js_1 = getEnsResolver$1;
	const getEnsText_js_1 = getEnsText$1;
	const call_js_1 = requireCall();
	const createBlockFilter_js_1 = createBlockFilter$1;
	const createContractEventFilter_js_1 = createContractEventFilter$1;
	const createEventFilter_js_1 = createEventFilter$1;
	const createPendingTransactionFilter_js_1 = createPendingTransactionFilter$1;
	const estimateContractGas_js_1 = estimateContractGas$1;
	const estimateFeesPerGas_js_1 = estimateFeesPerGas$1;
	const estimateGas_js_1 = requireEstimateGas();
	const estimateMaxPriorityFeePerGas_js_1 = estimateMaxPriorityFeePerGas$1;
	const getBalance_js_1 = getBalance$1;
	const getBlobBaseFee_js_1 = getBlobBaseFee$1;
	const getBlock_js_1 = getBlock$1;
	const getBlockNumber_js_1 = getBlockNumber$1;
	const getBlockTransactionCount_js_1 = getBlockTransactionCount$1;
	const getChainId_js_1$2 = getChainId$1;
	const getCode_js_1 = getCode$1;
	const getContractEvents_js_1 = getContractEvents$2;
	const getEip712Domain_js_1 = getEip712Domain$1;
	const getFeeHistory_js_1 = getFeeHistory$1;
	const getFilterChanges_js_1 = getFilterChanges$1;
	const getFilterLogs_js_1 = getFilterLogs$1;
	const getGasPrice_js_1 = getGasPrice$3;
	const getLogs_js_1 = getLogs$1;
	const getProof_js_1 = getProof$1;
	const getStorageAt_js_1 = getStorageAt$1;
	const getTransaction_js_1 = getTransaction$1;
	const getTransactionConfirmations_js_1 = getTransactionConfirmations$1;
	const getTransactionCount_js_1 = getTransactionCount$1;
	const getTransactionReceipt_js_1 = getTransactionReceipt$1;
	const multicall_js_1 = multicall$1;
	const readContract_js_1 = readContract$3;
	const simulateContract_js_1 = simulateContract$1;
	const uninstallFilter_js_1 = uninstallFilter$1;
	const verifyMessage_js_1 = verifyMessage$1;
	const verifyTypedData_js_1 = verifyTypedData$3;
	const waitForTransactionReceipt_js_1 = waitForTransactionReceipt$1;
	const watchBlockNumber_js_1$1 = watchBlockNumber$1;
	const watchBlocks_js_1 = watchBlocks$1;
	const watchContractEvent_js_1 = watchContractEvent$1;
	const watchEvent_js_1 = watchEvent$1;
	const watchPendingTransactions_js_1 = watchPendingTransactions$1;
	const verifySiweMessage_js_1 = verifySiweMessage$1;
	const prepareTransactionRequest_js_1$1 = requirePrepareTransactionRequest();
	const sendRawTransaction_js_1$1 = sendRawTransaction$1;
	function publicActions(client) {
	    return {
	        call: (args) => (0, call_js_1.call)(client, args),
	        createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
	        createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
	        createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
	        createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
	        estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
	        estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
	        getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
	        getBlobBaseFee: () => (0, getBlobBaseFee_js_1.getBlobBaseFee)(client),
	        getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
	        getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
	        getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
	        getBytecode: (args) => (0, getCode_js_1.getCode)(client, args),
	        getChainId: () => (0, getChainId_js_1$2.getChainId)(client),
	        getCode: (args) => (0, getCode_js_1.getCode)(client, args),
	        getContractEvents: (args) => (0, getContractEvents_js_1.getContractEvents)(client, args),
	        getEip712Domain: (args) => (0, getEip712Domain_js_1.getEip712Domain)(client, args),
	        getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
	        getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
	        getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
	        getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
	        getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
	        getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
	        estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client, args),
	        getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
	        getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
	        getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
	        getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
	        getProof: (args) => (0, getProof_js_1.getProof)(client, args),
	        estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas)(client, args),
	        getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
	        getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
	        getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
	        getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
	        getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
	        multicall: (args) => (0, multicall_js_1.multicall)(client, args),
	        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1$1.prepareTransactionRequest)(client, args),
	        readContract: (args) => (0, readContract_js_1.readContract)(client, args),
	        sendRawTransaction: (args) => (0, sendRawTransaction_js_1$1.sendRawTransaction)(client, args),
	        simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
	        verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
	        verifySiweMessage: (args) => (0, verifySiweMessage_js_1.verifySiweMessage)(client, args),
	        verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
	        uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
	        waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
	        watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
	        watchBlockNumber: (args) => (0, watchBlockNumber_js_1$1.watchBlockNumber)(client, args),
	        watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
	        watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
	        watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args),
	    };
	}

	Object.defineProperty(createPublicClient$1, "__esModule", { value: true });
	createPublicClient$1.createPublicClient = createPublicClient;
	const createClient_js_1$2 = createClient$1;
	const public_js_1 = _public;
	function createPublicClient(parameters) {
	    const { key = 'public', name = 'Public Client' } = parameters;
	    const client = (0, createClient_js_1$2.createClient)({
	        ...parameters,
	        key,
	        name,
	        type: 'publicClient',
	    });
	    return client.extend(public_js_1.publicActions);
	}

	var createTestClient$1 = {};

	var test = {};

	var dropTransaction$1 = {};

	Object.defineProperty(dropTransaction$1, "__esModule", { value: true });
	dropTransaction$1.dropTransaction = dropTransaction;
	async function dropTransaction(client, { hash }) {
	    await client.request({
	        method: `${client.mode}_dropTransaction`,
	        params: [hash],
	    });
	}

	var dumpState$1 = {};

	Object.defineProperty(dumpState$1, "__esModule", { value: true });
	dumpState$1.dumpState = dumpState;
	async function dumpState(client) {
	    return client.request({
	        method: `${client.mode}_dumpState`,
	    });
	}

	var getAutomine$1 = {};

	Object.defineProperty(getAutomine$1, "__esModule", { value: true });
	getAutomine$1.getAutomine = getAutomine;
	async function getAutomine(client) {
	    if (client.mode === 'ganache')
	        return await client.request({
	            method: 'eth_mining',
	        });
	    return await client.request({
	        method: `${client.mode}_getAutomine`,
	    });
	}

	var getTxpoolContent$1 = {};

	Object.defineProperty(getTxpoolContent$1, "__esModule", { value: true });
	getTxpoolContent$1.getTxpoolContent = getTxpoolContent;
	async function getTxpoolContent(client) {
	    return await client.request({
	        method: 'txpool_content',
	    });
	}

	var getTxpoolStatus$1 = {};

	Object.defineProperty(getTxpoolStatus$1, "__esModule", { value: true });
	getTxpoolStatus$1.getTxpoolStatus = getTxpoolStatus;
	const fromHex_js_1$1 = requireFromHex();
	async function getTxpoolStatus(client) {
	    const { pending, queued } = await client.request({
	        method: 'txpool_status',
	    });
	    return {
	        pending: (0, fromHex_js_1$1.hexToNumber)(pending),
	        queued: (0, fromHex_js_1$1.hexToNumber)(queued),
	    };
	}

	var impersonateAccount$1 = {};

	Object.defineProperty(impersonateAccount$1, "__esModule", { value: true });
	impersonateAccount$1.impersonateAccount = impersonateAccount;
	async function impersonateAccount(client, { address }) {
	    await client.request({
	        method: `${client.mode}_impersonateAccount`,
	        params: [address],
	    });
	}

	var increaseTime$1 = {};

	Object.defineProperty(increaseTime$1, "__esModule", { value: true });
	increaseTime$1.increaseTime = increaseTime;
	const toHex_js_1$h = requireToHex();
	async function increaseTime(client, { seconds }) {
	    return await client.request({
	        method: 'evm_increaseTime',
	        params: [(0, toHex_js_1$h.numberToHex)(seconds)],
	    });
	}

	var inspectTxpool$1 = {};

	Object.defineProperty(inspectTxpool$1, "__esModule", { value: true });
	inspectTxpool$1.inspectTxpool = inspectTxpool;
	async function inspectTxpool(client) {
	    return await client.request({
	        method: 'txpool_inspect',
	    });
	}

	var loadState$1 = {};

	Object.defineProperty(loadState$1, "__esModule", { value: true });
	loadState$1.loadState = loadState;
	async function loadState(client, { state }) {
	    await client.request({
	        method: `${client.mode}_loadState`,
	        params: [state],
	    });
	}

	var mine$1 = {};

	Object.defineProperty(mine$1, "__esModule", { value: true });
	mine$1.mine = mine;
	const toHex_js_1$g = requireToHex();
	async function mine(client, { blocks, interval }) {
	    if (client.mode === 'ganache')
	        await client.request({
	            method: 'evm_mine',
	            params: [{ blocks: (0, toHex_js_1$g.numberToHex)(blocks) }],
	        });
	    else
	        await client.request({
	            method: `${client.mode}_mine`,
	            params: [(0, toHex_js_1$g.numberToHex)(blocks), (0, toHex_js_1$g.numberToHex)(interval || 0)],
	        });
	}

	var removeBlockTimestampInterval$1 = {};

	Object.defineProperty(removeBlockTimestampInterval$1, "__esModule", { value: true });
	removeBlockTimestampInterval$1.removeBlockTimestampInterval = removeBlockTimestampInterval;
	async function removeBlockTimestampInterval(client) {
	    await client.request({
	        method: `${client.mode}_removeBlockTimestampInterval`,
	    });
	}

	var reset$1 = {};

	Object.defineProperty(reset$1, "__esModule", { value: true });
	reset$1.reset = reset;
	async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
	    await client.request({
	        method: `${client.mode}_reset`,
	        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }],
	    });
	}

	var revert$1 = {};

	Object.defineProperty(revert$1, "__esModule", { value: true });
	revert$1.revert = revert;
	async function revert(client, { id }) {
	    await client.request({
	        method: 'evm_revert',
	        params: [id],
	    });
	}

	var sendUnsignedTransaction$1 = {};

	Object.defineProperty(sendUnsignedTransaction$1, "__esModule", { value: true });
	sendUnsignedTransaction$1.sendUnsignedTransaction = sendUnsignedTransaction;
	const extract_js_1 = extract$1;
	const transactionRequest_js_1$1 = transactionRequest;
	async function sendUnsignedTransaction(client, args) {
	    const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
	    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
	    const format = chainFormat || transactionRequest_js_1$1.formatTransactionRequest;
	    const request = format({
	        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
	        accessList,
	        data,
	        from,
	        gas,
	        gasPrice,
	        maxFeePerGas,
	        maxPriorityFeePerGas,
	        nonce,
	        to,
	        value,
	    });
	    const hash = await client.request({
	        method: 'eth_sendUnsignedTransaction',
	        params: [request],
	    });
	    return hash;
	}

	var setAutomine$1 = {};

	Object.defineProperty(setAutomine$1, "__esModule", { value: true });
	setAutomine$1.setAutomine = setAutomine;
	async function setAutomine(client, enabled) {
	    if (client.mode === 'ganache') {
	        if (enabled)
	            await client.request({ method: 'miner_start' });
	        else
	            await client.request({ method: 'miner_stop' });
	    }
	    else
	        await client.request({
	            method: 'evm_setAutomine',
	            params: [enabled],
	        });
	}

	var setBalance$1 = {};

	Object.defineProperty(setBalance$1, "__esModule", { value: true });
	setBalance$1.setBalance = setBalance;
	const toHex_js_1$f = requireToHex();
	async function setBalance(client, { address, value }) {
	    if (client.mode === 'ganache')
	        await client.request({
	            method: 'evm_setAccountBalance',
	            params: [address, (0, toHex_js_1$f.numberToHex)(value)],
	        });
	    else
	        await client.request({
	            method: `${client.mode}_setBalance`,
	            params: [address, (0, toHex_js_1$f.numberToHex)(value)],
	        });
	}

	var setBlockGasLimit$1 = {};

	Object.defineProperty(setBlockGasLimit$1, "__esModule", { value: true });
	setBlockGasLimit$1.setBlockGasLimit = setBlockGasLimit;
	const toHex_js_1$e = requireToHex();
	async function setBlockGasLimit(client, { gasLimit }) {
	    await client.request({
	        method: 'evm_setBlockGasLimit',
	        params: [(0, toHex_js_1$e.numberToHex)(gasLimit)],
	    });
	}

	var setBlockTimestampInterval$1 = {};

	Object.defineProperty(setBlockTimestampInterval$1, "__esModule", { value: true });
	setBlockTimestampInterval$1.setBlockTimestampInterval = setBlockTimestampInterval;
	async function setBlockTimestampInterval(client, { interval }) {
	    const interval_ = (() => {
	        if (client.mode === 'hardhat')
	            return interval * 1000;
	        return interval;
	    })();
	    await client.request({
	        method: `${client.mode}_setBlockTimestampInterval`,
	        params: [interval_],
	    });
	}

	var setCode$1 = {};

	Object.defineProperty(setCode$1, "__esModule", { value: true });
	setCode$1.setCode = setCode;
	async function setCode(client, { address, bytecode }) {
	    if (client.mode === 'ganache')
	        await client.request({
	            method: 'evm_setAccountCode',
	            params: [address, bytecode],
	        });
	    else
	        await client.request({
	            method: `${client.mode}_setCode`,
	            params: [address, bytecode],
	        });
	}

	var setCoinbase$1 = {};

	Object.defineProperty(setCoinbase$1, "__esModule", { value: true });
	setCoinbase$1.setCoinbase = setCoinbase;
	async function setCoinbase(client, { address }) {
	    await client.request({
	        method: `${client.mode}_setCoinbase`,
	        params: [address],
	    });
	}

	var setIntervalMining$1 = {};

	Object.defineProperty(setIntervalMining$1, "__esModule", { value: true });
	setIntervalMining$1.setIntervalMining = setIntervalMining;
	async function setIntervalMining(client, { interval }) {
	    const interval_ = (() => {
	        if (client.mode === 'hardhat')
	            return interval * 1000;
	        return interval;
	    })();
	    await client.request({
	        method: 'evm_setIntervalMining',
	        params: [interval_],
	    });
	}

	var setLoggingEnabled$1 = {};

	Object.defineProperty(setLoggingEnabled$1, "__esModule", { value: true });
	setLoggingEnabled$1.setLoggingEnabled = setLoggingEnabled;
	async function setLoggingEnabled(client, enabled) {
	    await client.request({
	        method: `${client.mode}_setLoggingEnabled`,
	        params: [enabled],
	    });
	}

	var setMinGasPrice$1 = {};

	Object.defineProperty(setMinGasPrice$1, "__esModule", { value: true });
	setMinGasPrice$1.setMinGasPrice = setMinGasPrice;
	const toHex_js_1$d = requireToHex();
	async function setMinGasPrice(client, { gasPrice }) {
	    await client.request({
	        method: `${client.mode}_setMinGasPrice`,
	        params: [(0, toHex_js_1$d.numberToHex)(gasPrice)],
	    });
	}

	var setNextBlockBaseFeePerGas$1 = {};

	Object.defineProperty(setNextBlockBaseFeePerGas$1, "__esModule", { value: true });
	setNextBlockBaseFeePerGas$1.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
	const toHex_js_1$c = requireToHex();
	async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
	    await client.request({
	        method: `${client.mode}_setNextBlockBaseFeePerGas`,
	        params: [(0, toHex_js_1$c.numberToHex)(baseFeePerGas)],
	    });
	}

	var setNextBlockTimestamp$1 = {};

	Object.defineProperty(setNextBlockTimestamp$1, "__esModule", { value: true });
	setNextBlockTimestamp$1.setNextBlockTimestamp = setNextBlockTimestamp;
	const toHex_js_1$b = requireToHex();
	async function setNextBlockTimestamp(client, { timestamp }) {
	    await client.request({
	        method: 'evm_setNextBlockTimestamp',
	        params: [(0, toHex_js_1$b.numberToHex)(timestamp)],
	    });
	}

	var setNonce$1 = {};

	Object.defineProperty(setNonce$1, "__esModule", { value: true });
	setNonce$1.setNonce = setNonce;
	const toHex_js_1$a = requireToHex();
	async function setNonce(client, { address, nonce }) {
	    await client.request({
	        method: `${client.mode}_setNonce`,
	        params: [address, (0, toHex_js_1$a.numberToHex)(nonce)],
	    });
	}

	var setRpcUrl$1 = {};

	Object.defineProperty(setRpcUrl$1, "__esModule", { value: true });
	setRpcUrl$1.setRpcUrl = setRpcUrl;
	async function setRpcUrl(client, jsonRpcUrl) {
	    await client.request({
	        method: `${client.mode}_setRpcUrl`,
	        params: [jsonRpcUrl],
	    });
	}

	var setStorageAt$1 = {};

	Object.defineProperty(setStorageAt$1, "__esModule", { value: true });
	setStorageAt$1.setStorageAt = setStorageAt;
	const toHex_js_1$9 = requireToHex();
	async function setStorageAt(client, { address, index, value }) {
	    await client.request({
	        method: `${client.mode}_setStorageAt`,
	        params: [
	            address,
	            typeof index === 'number' ? (0, toHex_js_1$9.numberToHex)(index) : index,
	            value,
	        ],
	    });
	}

	var snapshot$1 = {};

	Object.defineProperty(snapshot$1, "__esModule", { value: true });
	snapshot$1.snapshot = snapshot;
	async function snapshot(client) {
	    return await client.request({
	        method: 'evm_snapshot',
	    });
	}

	var stopImpersonatingAccount$1 = {};

	Object.defineProperty(stopImpersonatingAccount$1, "__esModule", { value: true });
	stopImpersonatingAccount$1.stopImpersonatingAccount = stopImpersonatingAccount;
	async function stopImpersonatingAccount(client, { address }) {
	    await client.request({
	        method: `${client.mode}_stopImpersonatingAccount`,
	        params: [address],
	    });
	}

	Object.defineProperty(test, "__esModule", { value: true });
	test.testActions = testActions;
	const dropTransaction_js_1 = dropTransaction$1;
	const dumpState_js_1 = dumpState$1;
	const getAutomine_js_1 = getAutomine$1;
	const getTxpoolContent_js_1 = getTxpoolContent$1;
	const getTxpoolStatus_js_1 = getTxpoolStatus$1;
	const impersonateAccount_js_1 = impersonateAccount$1;
	const increaseTime_js_1 = increaseTime$1;
	const inspectTxpool_js_1 = inspectTxpool$1;
	const loadState_js_1 = loadState$1;
	const mine_js_1 = mine$1;
	const removeBlockTimestampInterval_js_1 = removeBlockTimestampInterval$1;
	const reset_js_1 = reset$1;
	const revert_js_1 = revert$1;
	const sendUnsignedTransaction_js_1 = sendUnsignedTransaction$1;
	const setAutomine_js_1 = setAutomine$1;
	const setBalance_js_1 = setBalance$1;
	const setBlockGasLimit_js_1 = setBlockGasLimit$1;
	const setBlockTimestampInterval_js_1 = setBlockTimestampInterval$1;
	const setCode_js_1 = setCode$1;
	const setCoinbase_js_1 = setCoinbase$1;
	const setIntervalMining_js_1 = setIntervalMining$1;
	const setLoggingEnabled_js_1 = setLoggingEnabled$1;
	const setMinGasPrice_js_1 = setMinGasPrice$1;
	const setNextBlockBaseFeePerGas_js_1 = setNextBlockBaseFeePerGas$1;
	const setNextBlockTimestamp_js_1 = setNextBlockTimestamp$1;
	const setNonce_js_1 = setNonce$1;
	const setRpcUrl_js_1 = setRpcUrl$1;
	const setStorageAt_js_1 = setStorageAt$1;
	const snapshot_js_1 = snapshot$1;
	const stopImpersonatingAccount_js_1 = stopImpersonatingAccount$1;
	function testActions({ mode, }) {
	    return (client_) => {
	        const client = client_.extend(() => ({
	            mode,
	        }));
	        return {
	            dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
	            dumpState: () => (0, dumpState_js_1.dumpState)(client),
	            getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
	            getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
	            getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
	            impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
	            increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
	            inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
	            loadState: (args) => (0, loadState_js_1.loadState)(client, args),
	            mine: (args) => (0, mine_js_1.mine)(client, args),
	            removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
	            reset: (args) => (0, reset_js_1.reset)(client, args),
	            revert: (args) => (0, revert_js_1.revert)(client, args),
	            sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
	            setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
	            setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
	            setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
	            setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
	            setCode: (args) => (0, setCode_js_1.setCode)(client, args),
	            setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
	            setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
	            setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
	            setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
	            setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
	            setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
	            setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
	            setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
	            setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
	            snapshot: () => (0, snapshot_js_1.snapshot)(client),
	            stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args),
	        };
	    };
	}

	Object.defineProperty(createTestClient$1, "__esModule", { value: true });
	createTestClient$1.createTestClient = createTestClient;
	const createClient_js_1$1 = createClient$1;
	const test_js_1 = test;
	function createTestClient(parameters) {
	    const { key = 'test', name = 'Test Client', mode } = parameters;
	    const client = (0, createClient_js_1$1.createClient)({
	        ...parameters,
	        key,
	        name,
	        type: 'testClient',
	    });
	    return client.extend((config) => ({
	        mode,
	        ...(0, test_js_1.testActions)({ mode })(config),
	    }));
	}

	var wallet = {};

	var addChain$1 = {};

	Object.defineProperty(addChain$1, "__esModule", { value: true });
	addChain$1.addChain = addChain;
	const toHex_js_1$8 = requireToHex();
	async function addChain(client, { chain }) {
	    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
	    await client.request({
	        method: 'wallet_addEthereumChain',
	        params: [
	            {
	                chainId: (0, toHex_js_1$8.numberToHex)(id),
	                chainName: name,
	                nativeCurrency,
	                rpcUrls: rpcUrls.default.http,
	                blockExplorerUrls: blockExplorers
	                    ? Object.values(blockExplorers).map(({ url }) => url)
	                    : undefined,
	            },
	        ],
	    }, { dedupe: true, retryCount: 0 });
	}

	var deployContract$1 = {};

	Object.defineProperty(deployContract$1, "__esModule", { value: true });
	deployContract$1.deployContract = deployContract;
	const encodeDeployData_js_1 = encodeDeployData$1;
	const sendTransaction_js_1$1 = sendTransaction$3;
	function deployContract(walletClient, parameters) {
	    const { abi, args, bytecode, ...request } = parameters;
	    const calldata = (0, encodeDeployData_js_1.encodeDeployData)({ abi, args, bytecode });
	    return (0, sendTransaction_js_1$1.sendTransaction)(walletClient, {
	        ...request,
	        data: calldata,
	    });
	}

	var getAddresses$1 = {};

	Object.defineProperty(getAddresses$1, "__esModule", { value: true });
	getAddresses$1.getAddresses = getAddresses;
	const getAddress_js_1$1 = requireGetAddress();
	async function getAddresses(client) {
	    if (client.account?.type === 'local')
	        return [client.account.address];
	    const addresses = await client.request({ method: 'eth_accounts' }, { dedupe: true });
	    return addresses.map((address) => (0, getAddress_js_1$1.checksumAddress)(address));
	}

	var getPermissions$1 = {};

	Object.defineProperty(getPermissions$1, "__esModule", { value: true });
	getPermissions$1.getPermissions = getPermissions;
	async function getPermissions(client) {
	    const permissions = await client.request({ method: 'wallet_getPermissions' }, { dedupe: true });
	    return permissions;
	}

	var requestAddresses$1 = {};

	Object.defineProperty(requestAddresses$1, "__esModule", { value: true });
	requestAddresses$1.requestAddresses = requestAddresses;
	const getAddress_js_1 = requireGetAddress();
	async function requestAddresses(client) {
	    const addresses = await client.request({ method: 'eth_requestAccounts' }, { dedupe: true, retryCount: 0 });
	    return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
	}

	var requestPermissions$1 = {};

	Object.defineProperty(requestPermissions$1, "__esModule", { value: true });
	requestPermissions$1.requestPermissions = requestPermissions;
	async function requestPermissions(client, permissions) {
	    return client.request({
	        method: 'wallet_requestPermissions',
	        params: [permissions],
	    }, { retryCount: 0 });
	}

	var signMessage$1 = {};

	Object.defineProperty(signMessage$1, "__esModule", { value: true });
	signMessage$1.signMessage = signMessage;
	const parseAccount_js_1$2 = parseAccount$1;
	const account_js_1$2 = account;
	const toHex_js_1$7 = requireToHex();
	async function signMessage(client, { account: account_ = client.account, message, }) {
	    if (!account_)
	        throw new account_js_1$2.AccountNotFoundError({
	            docsPath: '/docs/actions/wallet/signMessage',
	        });
	    const account = (0, parseAccount_js_1$2.parseAccount)(account_);
	    if (account.signMessage)
	        return account.signMessage({ message });
	    const message_ = (() => {
	        if (typeof message === 'string')
	            return (0, toHex_js_1$7.stringToHex)(message);
	        if (message.raw instanceof Uint8Array)
	            return (0, toHex_js_1$7.toHex)(message.raw);
	        return message.raw;
	    })();
	    return client.request({
	        method: 'personal_sign',
	        params: [message_, account.address],
	    }, { retryCount: 0 });
	}

	var signTransaction$3 = {};

	Object.defineProperty(signTransaction$3, "__esModule", { value: true });
	signTransaction$3.signTransaction = signTransaction$2;
	const parseAccount_js_1$1 = parseAccount$1;
	const account_js_1$1 = account;
	const assertCurrentChain_js_1 = assertCurrentChain$1;
	const toHex_js_1$6 = requireToHex();
	const transactionRequest_js_1 = transactionRequest;
	const getAction_js_1 = getAction$1;
	const assertRequest_js_1 = assertRequest$1;
	const getChainId_js_1$1 = getChainId$1;
	async function signTransaction$2(client, parameters) {
	    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
	    if (!account_)
	        throw new account_js_1$1.AccountNotFoundError({
	            docsPath: '/docs/actions/wallet/signTransaction',
	        });
	    const account = (0, parseAccount_js_1$1.parseAccount)(account_);
	    (0, assertRequest_js_1.assertRequest)({
	        account,
	        ...parameters,
	    });
	    const chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1$1.getChainId, 'getChainId')({});
	    if (chain !== null)
	        (0, assertCurrentChain_js_1.assertCurrentChain)({
	            currentChainId: chainId,
	            chain,
	        });
	    const formatters = chain?.formatters || client.chain?.formatters;
	    const format = formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
	    if (account.signTransaction)
	        return account.signTransaction({
	            ...transaction,
	            chainId,
	        }, { serializer: client.chain?.serializers?.transaction });
	    return await client.request({
	        method: 'eth_signTransaction',
	        params: [
	            {
	                ...format(transaction),
	                chainId: (0, toHex_js_1$6.numberToHex)(chainId),
	                from: account.address,
	            },
	        ],
	    }, { retryCount: 0 });
	}

	var signTypedData$1 = {};

	Object.defineProperty(signTypedData$1, "__esModule", { value: true });
	signTypedData$1.signTypedData = signTypedData;
	const parseAccount_js_1 = parseAccount$1;
	const account_js_1 = account;
	const typedData_js_1 = requireTypedData();
	async function signTypedData(client, parameters) {
	    const { account: account_ = client.account, domain, message, primaryType, } = parameters;
	    if (!account_)
	        throw new account_js_1.AccountNotFoundError({
	            docsPath: '/docs/actions/wallet/signTypedData',
	        });
	    const account = (0, parseAccount_js_1.parseAccount)(account_);
	    const types = {
	        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
	        ...parameters.types,
	    };
	    (0, typedData_js_1.validateTypedData)({ domain, message, primaryType, types });
	    if (account.signTypedData)
	        return account.signTypedData({ domain, message, primaryType, types });
	    const typedData = (0, typedData_js_1.serializeTypedData)({ domain, message, primaryType, types });
	    return client.request({
	        method: 'eth_signTypedData_v4',
	        params: [account.address, typedData],
	    }, { retryCount: 0 });
	}

	var switchChain$1 = {};

	Object.defineProperty(switchChain$1, "__esModule", { value: true });
	switchChain$1.switchChain = switchChain;
	const toHex_js_1$5 = requireToHex();
	async function switchChain(client, { id }) {
	    await client.request({
	        method: 'wallet_switchEthereumChain',
	        params: [
	            {
	                chainId: (0, toHex_js_1$5.numberToHex)(id),
	            },
	        ],
	    }, { retryCount: 0 });
	}

	var watchAsset$1 = {};

	Object.defineProperty(watchAsset$1, "__esModule", { value: true });
	watchAsset$1.watchAsset = watchAsset;
	async function watchAsset(client, params) {
	    const added = await client.request({
	        method: 'wallet_watchAsset',
	        params,
	    }, { retryCount: 0 });
	    return added;
	}

	Object.defineProperty(wallet, "__esModule", { value: true });
	wallet.walletActions = walletActions;
	const getChainId_js_1 = getChainId$1;
	const addChain_js_1 = addChain$1;
	const deployContract_js_1 = deployContract$1;
	const getAddresses_js_1 = getAddresses$1;
	const getPermissions_js_1 = getPermissions$1;
	const prepareTransactionRequest_js_1 = requirePrepareTransactionRequest();
	const requestAddresses_js_1 = requestAddresses$1;
	const requestPermissions_js_1 = requestPermissions$1;
	const sendRawTransaction_js_1 = sendRawTransaction$1;
	const sendTransaction_js_1 = sendTransaction$3;
	const signMessage_js_1 = signMessage$1;
	const signTransaction_js_1 = signTransaction$3;
	const signTypedData_js_1 = signTypedData$1;
	const switchChain_js_1 = switchChain$1;
	const watchAsset_js_1 = watchAsset$1;
	const writeContract_js_1 = writeContract$1;
	function walletActions(client) {
	    return {
	        addChain: (args) => (0, addChain_js_1.addChain)(client, args),
	        deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
	        getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
	        getChainId: () => (0, getChainId_js_1.getChainId)(client),
	        getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
	        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
	        requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
	        requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
	        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
	        sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
	        signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
	        signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client, args),
	        signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
	        switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
	        watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
	        writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args),
	    };
	}

	var createWalletClient$1 = {};

	Object.defineProperty(createWalletClient$1, "__esModule", { value: true });
	createWalletClient$1.createWalletClient = createWalletClient;
	const createClient_js_1 = createClient$1;
	const wallet_js_1 = wallet;
	function createWalletClient(parameters) {
	    const { key = 'wallet', name = 'Wallet Client', transport } = parameters;
	    const client = (0, createClient_js_1.createClient)({
	        ...parameters,
	        key,
	        name,
	        transport,
	        type: 'walletClient',
	    });
	    return client.extend(wallet_js_1.walletActions);
	}

	var webSocket$1 = {};

	Object.defineProperty(webSocket$1, "__esModule", { value: true });
	webSocket$1.webSocket = webSocket;
	const request_js_1 = request;
	const transport_js_1 = transport;
	const compat_js_1 = compat;
	const webSocket_js_1 = webSocket$3;
	const createTransport_js_1 = createTransport$1;
	function webSocket(url, config = {}) {
	    const { keepAlive, key = 'webSocket', name = 'WebSocket JSON-RPC', reconnect, retryDelay, } = config;
	    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
	        const retryCount = config.retryCount ?? retryCount_;
	        const timeout = timeout_ ?? config.timeout ?? 10_000;
	        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
	        if (!url_)
	            throw new transport_js_1.UrlRequiredError();
	        return (0, createTransport_js_1.createTransport)({
	            key,
	            name,
	            async request({ method, params }) {
	                const body = { method, params };
	                const rpcClient = await (0, webSocket_js_1.getWebSocketRpcClient)(url_, {
	                    keepAlive,
	                    reconnect,
	                });
	                const { error, result } = await rpcClient.requestAsync({
	                    body,
	                    timeout,
	                });
	                if (error)
	                    throw new request_js_1.RpcRequestError({
	                        body,
	                        error,
	                        url: url_,
	                    });
	                return result;
	            },
	            retryCount,
	            retryDelay,
	            timeout,
	            type: 'webSocket',
	        }, {
	            getSocket() {
	                return (0, compat_js_1.getSocket)(url_);
	            },
	            getRpcClient() {
	                return (0, webSocket_js_1.getWebSocketRpcClient)(url_);
	            },
	            async subscribe({ params, onData, onError }) {
	                const rpcClient = await (0, webSocket_js_1.getWebSocketRpcClient)(url_);
	                const { result: subscriptionId } = await new Promise((resolve, reject) => rpcClient.request({
	                    body: {
	                        method: 'eth_subscribe',
	                        params,
	                    },
	                    onError(error) {
	                        reject(error);
	                        onError?.(error);
	                        return;
	                    },
	                    onResponse(response) {
	                        if (response.error) {
	                            reject(response.error);
	                            onError?.(response.error);
	                            return;
	                        }
	                        if (typeof response.id === 'number') {
	                            resolve(response);
	                            return;
	                        }
	                        if (response.method !== 'eth_subscription')
	                            return;
	                        onData(response.params);
	                    },
	                }));
	                return {
	                    subscriptionId,
	                    async unsubscribe() {
	                        return new Promise((resolve) => rpcClient.request({
	                            body: {
	                                method: 'eth_unsubscribe',
	                                params: [subscriptionId],
	                            },
	                            onResponse: resolve,
	                        }));
	                    },
	                };
	            },
	        });
	    };
	}

	var address$1 = {};

	Object.defineProperty(address$1, "__esModule", { value: true });
	address$1.zeroAddress = address$1.entryPoint07Address = address$1.entryPoint06Address = void 0;
	address$1.entryPoint06Address = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789';
	address$1.entryPoint07Address = '0x0000000071727De22E5E9d8BAf0edAc6f37da032';
	address$1.zeroAddress = '0x0000000000000000000000000000000000000000';

	var number = {};

	Object.defineProperty(number, "__esModule", { value: true });
	number.minInt144 = number.minInt136 = number.minInt128 = number.minInt120 = number.minInt112 = number.minInt104 = number.minInt96 = number.minInt88 = number.minInt80 = number.minInt72 = number.minInt64 = number.minInt56 = number.minInt48 = number.minInt40 = number.minInt32 = number.minInt24 = number.minInt16 = number.minInt8 = number.maxInt256 = number.maxInt248 = number.maxInt240 = number.maxInt232 = number.maxInt224 = number.maxInt216 = number.maxInt208 = number.maxInt200 = number.maxInt192 = number.maxInt184 = number.maxInt176 = number.maxInt168 = number.maxInt160 = number.maxInt152 = number.maxInt144 = number.maxInt136 = number.maxInt128 = number.maxInt120 = number.maxInt112 = number.maxInt104 = number.maxInt96 = number.maxInt88 = number.maxInt80 = number.maxInt72 = number.maxInt64 = number.maxInt56 = number.maxInt48 = number.maxInt40 = number.maxInt32 = number.maxInt24 = number.maxInt16 = number.maxInt8 = void 0;
	number.maxUint256 = number.maxUint248 = number.maxUint240 = number.maxUint232 = number.maxUint224 = number.maxUint216 = number.maxUint208 = number.maxUint200 = number.maxUint192 = number.maxUint184 = number.maxUint176 = number.maxUint168 = number.maxUint160 = number.maxUint152 = number.maxUint144 = number.maxUint136 = number.maxUint128 = number.maxUint120 = number.maxUint112 = number.maxUint104 = number.maxUint96 = number.maxUint88 = number.maxUint80 = number.maxUint72 = number.maxUint64 = number.maxUint56 = number.maxUint48 = number.maxUint40 = number.maxUint32 = number.maxUint24 = number.maxUint16 = number.maxUint8 = number.minInt256 = number.minInt248 = number.minInt240 = number.minInt232 = number.minInt224 = number.minInt216 = number.minInt208 = number.minInt200 = number.minInt192 = number.minInt184 = number.minInt176 = number.minInt168 = number.minInt160 = number.minInt152 = void 0;
	number.maxInt8 = 2n ** (8n - 1n) - 1n;
	number.maxInt16 = 2n ** (16n - 1n) - 1n;
	number.maxInt24 = 2n ** (24n - 1n) - 1n;
	number.maxInt32 = 2n ** (32n - 1n) - 1n;
	number.maxInt40 = 2n ** (40n - 1n) - 1n;
	number.maxInt48 = 2n ** (48n - 1n) - 1n;
	number.maxInt56 = 2n ** (56n - 1n) - 1n;
	number.maxInt64 = 2n ** (64n - 1n) - 1n;
	number.maxInt72 = 2n ** (72n - 1n) - 1n;
	number.maxInt80 = 2n ** (80n - 1n) - 1n;
	number.maxInt88 = 2n ** (88n - 1n) - 1n;
	number.maxInt96 = 2n ** (96n - 1n) - 1n;
	number.maxInt104 = 2n ** (104n - 1n) - 1n;
	number.maxInt112 = 2n ** (112n - 1n) - 1n;
	number.maxInt120 = 2n ** (120n - 1n) - 1n;
	number.maxInt128 = 2n ** (128n - 1n) - 1n;
	number.maxInt136 = 2n ** (136n - 1n) - 1n;
	number.maxInt144 = 2n ** (144n - 1n) - 1n;
	number.maxInt152 = 2n ** (152n - 1n) - 1n;
	number.maxInt160 = 2n ** (160n - 1n) - 1n;
	number.maxInt168 = 2n ** (168n - 1n) - 1n;
	number.maxInt176 = 2n ** (176n - 1n) - 1n;
	number.maxInt184 = 2n ** (184n - 1n) - 1n;
	number.maxInt192 = 2n ** (192n - 1n) - 1n;
	number.maxInt200 = 2n ** (200n - 1n) - 1n;
	number.maxInt208 = 2n ** (208n - 1n) - 1n;
	number.maxInt216 = 2n ** (216n - 1n) - 1n;
	number.maxInt224 = 2n ** (224n - 1n) - 1n;
	number.maxInt232 = 2n ** (232n - 1n) - 1n;
	number.maxInt240 = 2n ** (240n - 1n) - 1n;
	number.maxInt248 = 2n ** (248n - 1n) - 1n;
	number.maxInt256 = 2n ** (256n - 1n) - 1n;
	number.minInt8 = -(2n ** (8n - 1n));
	number.minInt16 = -(2n ** (16n - 1n));
	number.minInt24 = -(2n ** (24n - 1n));
	number.minInt32 = -(2n ** (32n - 1n));
	number.minInt40 = -(2n ** (40n - 1n));
	number.minInt48 = -(2n ** (48n - 1n));
	number.minInt56 = -(2n ** (56n - 1n));
	number.minInt64 = -(2n ** (64n - 1n));
	number.minInt72 = -(2n ** (72n - 1n));
	number.minInt80 = -(2n ** (80n - 1n));
	number.minInt88 = -(2n ** (88n - 1n));
	number.minInt96 = -(2n ** (96n - 1n));
	number.minInt104 = -(2n ** (104n - 1n));
	number.minInt112 = -(2n ** (112n - 1n));
	number.minInt120 = -(2n ** (120n - 1n));
	number.minInt128 = -(2n ** (128n - 1n));
	number.minInt136 = -(2n ** (136n - 1n));
	number.minInt144 = -(2n ** (144n - 1n));
	number.minInt152 = -(2n ** (152n - 1n));
	number.minInt160 = -(2n ** (160n - 1n));
	number.minInt168 = -(2n ** (168n - 1n));
	number.minInt176 = -(2n ** (176n - 1n));
	number.minInt184 = -(2n ** (184n - 1n));
	number.minInt192 = -(2n ** (192n - 1n));
	number.minInt200 = -(2n ** (200n - 1n));
	number.minInt208 = -(2n ** (208n - 1n));
	number.minInt216 = -(2n ** (216n - 1n));
	number.minInt224 = -(2n ** (224n - 1n));
	number.minInt232 = -(2n ** (232n - 1n));
	number.minInt240 = -(2n ** (240n - 1n));
	number.minInt248 = -(2n ** (248n - 1n));
	number.minInt256 = -(2n ** (256n - 1n));
	number.maxUint8 = 2n ** 8n - 1n;
	number.maxUint16 = 2n ** 16n - 1n;
	number.maxUint24 = 2n ** 24n - 1n;
	number.maxUint32 = 2n ** 32n - 1n;
	number.maxUint40 = 2n ** 40n - 1n;
	number.maxUint48 = 2n ** 48n - 1n;
	number.maxUint56 = 2n ** 56n - 1n;
	number.maxUint64 = 2n ** 64n - 1n;
	number.maxUint72 = 2n ** 72n - 1n;
	number.maxUint80 = 2n ** 80n - 1n;
	number.maxUint88 = 2n ** 88n - 1n;
	number.maxUint96 = 2n ** 96n - 1n;
	number.maxUint104 = 2n ** 104n - 1n;
	number.maxUint112 = 2n ** 112n - 1n;
	number.maxUint120 = 2n ** 120n - 1n;
	number.maxUint128 = 2n ** 128n - 1n;
	number.maxUint136 = 2n ** 136n - 1n;
	number.maxUint144 = 2n ** 144n - 1n;
	number.maxUint152 = 2n ** 152n - 1n;
	number.maxUint160 = 2n ** 160n - 1n;
	number.maxUint168 = 2n ** 168n - 1n;
	number.maxUint176 = 2n ** 176n - 1n;
	number.maxUint184 = 2n ** 184n - 1n;
	number.maxUint192 = 2n ** 192n - 1n;
	number.maxUint200 = 2n ** 200n - 1n;
	number.maxUint208 = 2n ** 208n - 1n;
	number.maxUint216 = 2n ** 216n - 1n;
	number.maxUint224 = 2n ** 224n - 1n;
	number.maxUint232 = 2n ** 232n - 1n;
	number.maxUint240 = 2n ** 240n - 1n;
	number.maxUint248 = 2n ** 248n - 1n;
	number.maxUint256 = 2n ** 256n - 1n;

	var eip1193 = {};

	Object.defineProperty(eip1193, "__esModule", { value: true });
	eip1193.ProviderRpcError = void 0;
	class ProviderRpcError extends Error {
	    constructor(code, message) {
	        super(message);
	        Object.defineProperty(this, "code", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        Object.defineProperty(this, "details", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.code = code;
	        this.details = message;
	    }
	}
	eip1193.ProviderRpcError = ProviderRpcError;

	var decodeDeployData$1 = {};

	Object.defineProperty(decodeDeployData$1, "__esModule", { value: true });
	decodeDeployData$1.decodeDeployData = decodeDeployData;
	const abi_js_1 = requireAbi();
	const decodeAbiParameters_js_1 = decodeAbiParameters$1;
	const docsPath = '/docs/contract/decodeDeployData';
	function decodeDeployData(parameters) {
	    const { abi, bytecode, data } = parameters;
	    if (data === bytecode)
	        return { bytecode };
	    const description = abi.find((x) => 'type' in x && x.type === 'constructor');
	    if (!description)
	        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
	    if (!('inputs' in description))
	        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
	    if (!description.inputs || description.inputs.length === 0)
	        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
	    const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, '')}`);
	    return { args, bytecode };
	}

	var compactSignatureToSignature$1 = {};

	Object.defineProperty(compactSignatureToSignature$1, "__esModule", { value: true });
	compactSignatureToSignature$1.compactSignatureToSignature = compactSignatureToSignature;
	const toBytes_js_1$2 = requireToBytes();
	const toHex_js_1$4 = requireToHex();
	function compactSignatureToSignature({ r, yParityAndS, }) {
	    const yParityAndS_bytes = (0, toBytes_js_1$2.hexToBytes)(yParityAndS);
	    const yParity = yParityAndS_bytes[0] & 0x80 ? 1 : 0;
	    const s = yParityAndS_bytes;
	    if (yParity === 1)
	        s[0] &= 0x7f;
	    return { r, s: (0, toHex_js_1$4.bytesToHex)(s), yParity };
	}

	var parseCompactSignature$1 = {};

	Object.defineProperty(parseCompactSignature$1, "__esModule", { value: true });
	parseCompactSignature$1.parseCompactSignature = parseCompactSignature;
	const secp256k1_1$3 = secp256k1;
	const toHex_js_1$3 = requireToHex();
	function parseCompactSignature(signatureHex) {
	    const { r, s } = secp256k1_1$3.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
	    return {
	        r: (0, toHex_js_1$3.numberToHex)(r, { size: 32 }),
	        yParityAndS: (0, toHex_js_1$3.numberToHex)(s, { size: 32 }),
	    };
	}

	var parseSignature$1 = {};

	Object.defineProperty(parseSignature$1, "__esModule", { value: true });
	parseSignature$1.parseSignature = parseSignature;
	const secp256k1_1$2 = secp256k1;
	const toHex_js_1$2 = requireToHex();
	function parseSignature(signatureHex) {
	    const { r, s } = secp256k1_1$2.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
	    const yParityOrV = Number(`0x${signatureHex.slice(130)}`);
	    const [v, yParity] = (() => {
	        if (yParityOrV === 0 || yParityOrV === 1)
	            return [undefined, yParityOrV];
	        if (yParityOrV === 27)
	            return [BigInt(yParityOrV), 0];
	        if (yParityOrV === 28)
	            return [BigInt(yParityOrV), 1];
	        throw new Error('Invalid yParityOrV value');
	    })();
	    if (typeof v !== 'undefined')
	        return {
	            r: (0, toHex_js_1$2.numberToHex)(r, { size: 32 }),
	            s: (0, toHex_js_1$2.numberToHex)(s, { size: 32 }),
	            v,
	            yParity,
	        };
	    return {
	        r: (0, toHex_js_1$2.numberToHex)(r, { size: 32 }),
	        s: (0, toHex_js_1$2.numberToHex)(s, { size: 32 }),
	        yParity,
	    };
	}

	var recoverTransactionAddress$1 = {};

	Object.defineProperty(recoverTransactionAddress$1, "__esModule", { value: true });
	recoverTransactionAddress$1.recoverTransactionAddress = recoverTransactionAddress;
	const keccak256_js_1$2 = keccak256$3;
	const parseTransaction_js_1 = parseTransaction$1;
	const serializeTransaction_js_1 = requireSerializeTransaction();
	const recoverAddress_js_1 = recoverAddress$1;
	async function recoverTransactionAddress(parameters) {
	    const { serializedTransaction, signature: signature_ } = parameters;
	    const transaction = (0, parseTransaction_js_1.parseTransaction)(serializedTransaction);
	    const signature = signature_ ?? {
	        r: transaction.r,
	        s: transaction.s,
	        v: transaction.v,
	        yParity: transaction.yParity,
	    };
	    const serialized = (0, serializeTransaction_js_1.serializeTransaction)({
	        ...transaction,
	        r: undefined,
	        s: undefined,
	        v: undefined,
	        yParity: undefined,
	        sidecars: undefined,
	    });
	    return await (0, recoverAddress_js_1.recoverAddress)({
	        hash: (0, keccak256_js_1$2.keccak256)(serialized),
	        signature,
	    });
	}

	var signatureToCompactSignature$1 = {};

	Object.defineProperty(signatureToCompactSignature$1, "__esModule", { value: true });
	signatureToCompactSignature$1.signatureToCompactSignature = signatureToCompactSignature;
	const toBytes_js_1$1 = requireToBytes();
	const toHex_js_1$1 = requireToHex();
	function signatureToCompactSignature(signature) {
	    const { r, s, v, yParity } = signature;
	    const yParity_ = Number(yParity ?? v - 27n);
	    let yParityAndS = s;
	    if (yParity_ === 1) {
	        const bytes = (0, toBytes_js_1$1.hexToBytes)(s);
	        bytes[0] |= 0x80;
	        yParityAndS = (0, toHex_js_1$1.bytesToHex)(bytes);
	    }
	    return { r, yParityAndS };
	}

	var serializeCompactSignature$1 = {};

	Object.defineProperty(serializeCompactSignature$1, "__esModule", { value: true });
	serializeCompactSignature$1.serializeCompactSignature = serializeCompactSignature;
	const secp256k1_1$1 = secp256k1;
	const fromHex_js_1 = requireFromHex();
	function serializeCompactSignature({ r, yParityAndS, }) {
	    return `0x${new secp256k1_1$1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(yParityAndS)).toCompactHex()}`;
	}

	var sidecarsToVersionedHashes$1 = {};

	Object.defineProperty(sidecarsToVersionedHashes$1, "__esModule", { value: true });
	sidecarsToVersionedHashes$1.sidecarsToVersionedHashes = sidecarsToVersionedHashes;
	const commitmentToVersionedHash_js_1 = commitmentToVersionedHash$1;
	function sidecarsToVersionedHashes(parameters) {
	    const { sidecars, version } = parameters;
	    const to = parameters.to ?? (typeof sidecars[0].blob === 'string' ? 'hex' : 'bytes');
	    const hashes = [];
	    for (const { commitment } of sidecars) {
	        hashes.push((0, commitmentToVersionedHash_js_1.commitmentToVersionedHash)({
	            commitment,
	            to,
	            version,
	        }));
	    }
	    return hashes;
	}

	var fromBlobs$1 = {};

	Object.defineProperty(fromBlobs$1, "__esModule", { value: true });
	fromBlobs$1.fromBlobs = fromBlobs;
	const cursor_js_1 = cursor$1;
	const toBytes_js_1 = requireToBytes();
	const toHex_js_1 = requireToHex();
	function fromBlobs(parameters) {
	    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
	    const blobs = (typeof parameters.blobs[0] === 'string'
	        ? parameters.blobs.map((x) => (0, toBytes_js_1.hexToBytes)(x))
	        : parameters.blobs);
	    const length = blobs.reduce((length, blob) => length + blob.length, 0);
	    const data = (0, cursor_js_1.createCursor)(new Uint8Array(length));
	    let active = true;
	    for (const blob of blobs) {
	        const cursor = (0, cursor_js_1.createCursor)(blob);
	        while (active && cursor.position < blob.length) {
	            cursor.incrementPosition(1);
	            let consume = 31;
	            if (blob.length - cursor.position < 31)
	                consume = blob.length - cursor.position;
	            for (const _ in Array.from({ length: consume })) {
	                const byte = cursor.readByte();
	                const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);
	                if (isTerminator) {
	                    active = false;
	                    break;
	                }
	                data.pushByte(byte);
	            }
	        }
	    }
	    const trimmedData = data.bytes.slice(0, data.position);
	    return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(trimmedData) : trimmedData);
	}

	var defineKzg$1 = {};

	Object.defineProperty(defineKzg$1, "__esModule", { value: true });
	defineKzg$1.defineKzg = defineKzg;
	function defineKzg({ blobToKzgCommitment, computeBlobKzgProof, }) {
	    return {
	        blobToKzgCommitment,
	        computeBlobKzgProof,
	    };
	}

	var setupKzg$1 = {};

	Object.defineProperty(setupKzg$1, "__esModule", { value: true });
	setupKzg$1.setupKzg = setupKzg;
	const defineKzg_js_1 = defineKzg$1;
	function setupKzg(parameters, path) {
	    try {
	        parameters.loadTrustedSetup(path);
	    }
	    catch (e) {
	        const error = e;
	        if (!error.message.includes('trusted setup is already loaded'))
	            throw error;
	    }
	    return (0, defineKzg_js_1.defineKzg)(parameters);
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.universalSignatureValidatorByteCode = exports.deploylessCallViaFactoryBytecode = exports.deploylessCallViaBytecodeBytecode = exports.zeroAddress = exports.universalSignatureValidatorAbi = exports.erc4626Abi = exports.erc721Abi = exports.erc20Abi_bytes32 = exports.erc20Abi = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.rpcSchema = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = void 0;
		exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = void 0;
		exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.presignMessagePrefix = exports.zeroHash = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = void 0;
		exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.TransactionRejectedRpcError = exports.SwitchChainError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = exports.CounterfactualDeploymentFailedError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.setErrorConfig = exports.BaseError = exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingBytesSizeMismatchError = void 0;
		exports.EIP1193ProviderRpcError = exports.StateAssignmentConflictError = exports.AccountStateConflictError = exports.UrlRequiredError = exports.SliceOffsetOutOfBoundsError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.SocketClosedError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarUriResolutionError = exports.SizeOverflowError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = exports.InvalidBytesBooleanError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = void 0;
		exports.serializeSignature = exports.signatureToHex = exports.serializeCompactSignature = exports.compactSignatureToHex = exports.signatureToCompactSignature = exports.recoverTypedDataAddress = exports.recoverTransactionAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.parseSignature = exports.hexToSignature = exports.parseCompactSignature = exports.hexToCompactSignature = exports.compactSignatureToSignature = exports.hashTypedData = exports.hashDomain = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.rpcTransactionType = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.formatTransactionReceipt = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.parseEventLogs = exports.encodeFunctionResult = exports.prepareEncodeFunctionData = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = void 0;
		exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.setupKzg = exports.defineKzg = exports.toBlobs = exports.toBlobSidecars = exports.fromBlobs = exports.blobsToProofs = exports.sidecarsToVersionedHashes = exports.commitmentsToVersionedHashes = exports.commitmentToVersionedHash = exports.blobsToCommitments = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.ccipRequest = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigInt = exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.serializeErc6492Signature = exports.isErc6492Signature = exports.parseErc6492Signature = exports.verifyTypedData = exports.verifyMessage = exports.verifyHash = exports.toRlp = exports.hexToRlp = exports.bytesToRlp = void 0;
		exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = exports.isAddressEqual = exports.isAddress = exports.toPrefixedMessage = exports.hashMessage = exports.toFunctionHash = exports.toEventHash = exports.getFunctionSignature = exports.toFunctionSignature = exports.getEventSignature = exports.toEventSignature = exports.getFunctionSelector = exports.toFunctionSelector = exports.getEventSelector = exports.toEventSelector = exports.getContractError = exports.getAddress = exports.checksumAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.withTimeout = exports.withRetry = exports.encodePacked = void 0;
		exports.nonceManager = exports.createNonceManager = exports.getTypesForEIP712Domain = exports.domainSeparator = exports.validateTypedData = exports.serializeTypedData = void 0;
		var abitype_1 = exports$1;
		Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function () { return abitype_1.CircularReferenceError; } });
		Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function () { return abitype_1.InvalidAbiParameterError; } });
		Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function () { return abitype_1.InvalidAbiParametersError; } });
		Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function () { return abitype_1.InvalidAbiItemError; } });
		Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function () { return abitype_1.InvalidAbiTypeParameterError; } });
		Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function () { return abitype_1.InvalidFunctionModifierError; } });
		Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function () { return abitype_1.InvalidModifierError; } });
		Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function () { return abitype_1.InvalidParameterError; } });
		Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function () { return abitype_1.InvalidParenthesisError; } });
		Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function () { return abitype_1.InvalidSignatureError; } });
		Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function () { return abitype_1.InvalidStructSignatureError; } });
		Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function () { return abitype_1.SolidityProtectedKeywordError; } });
		Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function () { return abitype_1.UnknownTypeError; } });
		Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function () { return abitype_1.UnknownSignatureError; } });
		Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function () { return abitype_1.parseAbi; } });
		Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function () { return abitype_1.parseAbiItem; } });
		Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function () { return abitype_1.parseAbiParameter; } });
		Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function () { return abitype_1.parseAbiParameters; } });
		var getContract_js_1 = getContract$2;
		Object.defineProperty(exports, "getContract", { enumerable: true, get: function () { return getContract_js_1.getContract; } });
		var createClient_js_1 = createClient$1;
		Object.defineProperty(exports, "createClient", { enumerable: true, get: function () { return createClient_js_1.createClient; } });
		Object.defineProperty(exports, "rpcSchema", { enumerable: true, get: function () { return createClient_js_1.rpcSchema; } });
		var custom_js_1 = custom$1;
		Object.defineProperty(exports, "custom", { enumerable: true, get: function () { return custom_js_1.custom; } });
		var fallback_js_1 = fallback$1;
		Object.defineProperty(exports, "fallback", { enumerable: true, get: function () { return fallback_js_1.fallback; } });
		var http_js_1 = http$2;
		Object.defineProperty(exports, "http", { enumerable: true, get: function () { return http_js_1.http; } });
		var createPublicClient_js_1 = createPublicClient$1;
		Object.defineProperty(exports, "createPublicClient", { enumerable: true, get: function () { return createPublicClient_js_1.createPublicClient; } });
		var createTestClient_js_1 = createTestClient$1;
		Object.defineProperty(exports, "createTestClient", { enumerable: true, get: function () { return createTestClient_js_1.createTestClient; } });
		var public_js_1 = _public;
		Object.defineProperty(exports, "publicActions", { enumerable: true, get: function () { return public_js_1.publicActions; } });
		var test_js_1 = test;
		Object.defineProperty(exports, "testActions", { enumerable: true, get: function () { return test_js_1.testActions; } });
		var wallet_js_1 = wallet;
		Object.defineProperty(exports, "walletActions", { enumerable: true, get: function () { return wallet_js_1.walletActions; } });
		var createTransport_js_1 = createTransport$1;
		Object.defineProperty(exports, "createTransport", { enumerable: true, get: function () { return createTransport_js_1.createTransport; } });
		var createWalletClient_js_1 = createWalletClient$1;
		Object.defineProperty(exports, "createWalletClient", { enumerable: true, get: function () { return createWalletClient_js_1.createWalletClient; } });
		var webSocket_js_1 = webSocket$1;
		Object.defineProperty(exports, "webSocket", { enumerable: true, get: function () { return webSocket_js_1.webSocket; } });
		var abis_js_1 = abis;
		Object.defineProperty(exports, "multicall3Abi", { enumerable: true, get: function () { return abis_js_1.multicall3Abi; } });
		Object.defineProperty(exports, "erc20Abi", { enumerable: true, get: function () { return abis_js_1.erc20Abi; } });
		Object.defineProperty(exports, "erc20Abi_bytes32", { enumerable: true, get: function () { return abis_js_1.erc20Abi_bytes32; } });
		Object.defineProperty(exports, "erc721Abi", { enumerable: true, get: function () { return abis_js_1.erc721Abi; } });
		Object.defineProperty(exports, "erc4626Abi", { enumerable: true, get: function () { return abis_js_1.erc4626Abi; } });
		Object.defineProperty(exports, "universalSignatureValidatorAbi", { enumerable: true, get: function () { return abis_js_1.universalSignatureValidatorAbi; } });
		var address_js_1 = address$1;
		Object.defineProperty(exports, "zeroAddress", { enumerable: true, get: function () { return address_js_1.zeroAddress; } });
		var contracts_js_1 = contracts;
		Object.defineProperty(exports, "deploylessCallViaBytecodeBytecode", { enumerable: true, get: function () { return contracts_js_1.deploylessCallViaBytecodeBytecode; } });
		Object.defineProperty(exports, "deploylessCallViaFactoryBytecode", { enumerable: true, get: function () { return contracts_js_1.deploylessCallViaFactoryBytecode; } });
		Object.defineProperty(exports, "universalSignatureValidatorByteCode", { enumerable: true, get: function () { return contracts_js_1.universalSignatureValidatorByteCode; } });
		var unit_js_1 = unit;
		Object.defineProperty(exports, "etherUnits", { enumerable: true, get: function () { return unit_js_1.etherUnits; } });
		Object.defineProperty(exports, "gweiUnits", { enumerable: true, get: function () { return unit_js_1.gweiUnits; } });
		Object.defineProperty(exports, "weiUnits", { enumerable: true, get: function () { return unit_js_1.weiUnits; } });
		var number_js_1 = number;
		Object.defineProperty(exports, "maxInt8", { enumerable: true, get: function () { return number_js_1.maxInt8; } });
		Object.defineProperty(exports, "maxInt16", { enumerable: true, get: function () { return number_js_1.maxInt16; } });
		Object.defineProperty(exports, "maxInt24", { enumerable: true, get: function () { return number_js_1.maxInt24; } });
		Object.defineProperty(exports, "maxInt32", { enumerable: true, get: function () { return number_js_1.maxInt32; } });
		Object.defineProperty(exports, "maxInt40", { enumerable: true, get: function () { return number_js_1.maxInt40; } });
		Object.defineProperty(exports, "maxInt48", { enumerable: true, get: function () { return number_js_1.maxInt48; } });
		Object.defineProperty(exports, "maxInt56", { enumerable: true, get: function () { return number_js_1.maxInt56; } });
		Object.defineProperty(exports, "maxInt64", { enumerable: true, get: function () { return number_js_1.maxInt64; } });
		Object.defineProperty(exports, "maxInt72", { enumerable: true, get: function () { return number_js_1.maxInt72; } });
		Object.defineProperty(exports, "maxInt80", { enumerable: true, get: function () { return number_js_1.maxInt80; } });
		Object.defineProperty(exports, "maxInt88", { enumerable: true, get: function () { return number_js_1.maxInt88; } });
		Object.defineProperty(exports, "maxInt96", { enumerable: true, get: function () { return number_js_1.maxInt96; } });
		Object.defineProperty(exports, "maxInt104", { enumerable: true, get: function () { return number_js_1.maxInt104; } });
		Object.defineProperty(exports, "maxInt112", { enumerable: true, get: function () { return number_js_1.maxInt112; } });
		Object.defineProperty(exports, "maxInt120", { enumerable: true, get: function () { return number_js_1.maxInt120; } });
		Object.defineProperty(exports, "maxInt128", { enumerable: true, get: function () { return number_js_1.maxInt128; } });
		Object.defineProperty(exports, "maxInt136", { enumerable: true, get: function () { return number_js_1.maxInt136; } });
		Object.defineProperty(exports, "maxInt144", { enumerable: true, get: function () { return number_js_1.maxInt144; } });
		Object.defineProperty(exports, "maxInt152", { enumerable: true, get: function () { return number_js_1.maxInt152; } });
		Object.defineProperty(exports, "maxInt160", { enumerable: true, get: function () { return number_js_1.maxInt160; } });
		Object.defineProperty(exports, "maxInt168", { enumerable: true, get: function () { return number_js_1.maxInt168; } });
		Object.defineProperty(exports, "maxInt176", { enumerable: true, get: function () { return number_js_1.maxInt176; } });
		Object.defineProperty(exports, "maxInt184", { enumerable: true, get: function () { return number_js_1.maxInt184; } });
		Object.defineProperty(exports, "maxInt192", { enumerable: true, get: function () { return number_js_1.maxInt192; } });
		Object.defineProperty(exports, "maxInt200", { enumerable: true, get: function () { return number_js_1.maxInt200; } });
		Object.defineProperty(exports, "maxInt208", { enumerable: true, get: function () { return number_js_1.maxInt208; } });
		Object.defineProperty(exports, "maxInt216", { enumerable: true, get: function () { return number_js_1.maxInt216; } });
		Object.defineProperty(exports, "maxInt224", { enumerable: true, get: function () { return number_js_1.maxInt224; } });
		Object.defineProperty(exports, "maxInt232", { enumerable: true, get: function () { return number_js_1.maxInt232; } });
		Object.defineProperty(exports, "maxInt240", { enumerable: true, get: function () { return number_js_1.maxInt240; } });
		Object.defineProperty(exports, "maxInt248", { enumerable: true, get: function () { return number_js_1.maxInt248; } });
		Object.defineProperty(exports, "maxInt256", { enumerable: true, get: function () { return number_js_1.maxInt256; } });
		Object.defineProperty(exports, "maxUint8", { enumerable: true, get: function () { return number_js_1.maxUint8; } });
		Object.defineProperty(exports, "maxUint16", { enumerable: true, get: function () { return number_js_1.maxUint16; } });
		Object.defineProperty(exports, "maxUint24", { enumerable: true, get: function () { return number_js_1.maxUint24; } });
		Object.defineProperty(exports, "maxUint32", { enumerable: true, get: function () { return number_js_1.maxUint32; } });
		Object.defineProperty(exports, "maxUint40", { enumerable: true, get: function () { return number_js_1.maxUint40; } });
		Object.defineProperty(exports, "maxUint48", { enumerable: true, get: function () { return number_js_1.maxUint48; } });
		Object.defineProperty(exports, "maxUint56", { enumerable: true, get: function () { return number_js_1.maxUint56; } });
		Object.defineProperty(exports, "maxUint64", { enumerable: true, get: function () { return number_js_1.maxUint64; } });
		Object.defineProperty(exports, "maxUint72", { enumerable: true, get: function () { return number_js_1.maxUint72; } });
		Object.defineProperty(exports, "maxUint80", { enumerable: true, get: function () { return number_js_1.maxUint80; } });
		Object.defineProperty(exports, "maxUint88", { enumerable: true, get: function () { return number_js_1.maxUint88; } });
		Object.defineProperty(exports, "maxUint96", { enumerable: true, get: function () { return number_js_1.maxUint96; } });
		Object.defineProperty(exports, "maxUint104", { enumerable: true, get: function () { return number_js_1.maxUint104; } });
		Object.defineProperty(exports, "maxUint112", { enumerable: true, get: function () { return number_js_1.maxUint112; } });
		Object.defineProperty(exports, "maxUint120", { enumerable: true, get: function () { return number_js_1.maxUint120; } });
		Object.defineProperty(exports, "maxUint128", { enumerable: true, get: function () { return number_js_1.maxUint128; } });
		Object.defineProperty(exports, "maxUint136", { enumerable: true, get: function () { return number_js_1.maxUint136; } });
		Object.defineProperty(exports, "maxUint144", { enumerable: true, get: function () { return number_js_1.maxUint144; } });
		Object.defineProperty(exports, "maxUint152", { enumerable: true, get: function () { return number_js_1.maxUint152; } });
		Object.defineProperty(exports, "maxUint160", { enumerable: true, get: function () { return number_js_1.maxUint160; } });
		Object.defineProperty(exports, "maxUint168", { enumerable: true, get: function () { return number_js_1.maxUint168; } });
		Object.defineProperty(exports, "maxUint176", { enumerable: true, get: function () { return number_js_1.maxUint176; } });
		Object.defineProperty(exports, "maxUint184", { enumerable: true, get: function () { return number_js_1.maxUint184; } });
		Object.defineProperty(exports, "maxUint192", { enumerable: true, get: function () { return number_js_1.maxUint192; } });
		Object.defineProperty(exports, "maxUint200", { enumerable: true, get: function () { return number_js_1.maxUint200; } });
		Object.defineProperty(exports, "maxUint208", { enumerable: true, get: function () { return number_js_1.maxUint208; } });
		Object.defineProperty(exports, "maxUint216", { enumerable: true, get: function () { return number_js_1.maxUint216; } });
		Object.defineProperty(exports, "maxUint224", { enumerable: true, get: function () { return number_js_1.maxUint224; } });
		Object.defineProperty(exports, "maxUint232", { enumerable: true, get: function () { return number_js_1.maxUint232; } });
		Object.defineProperty(exports, "maxUint240", { enumerable: true, get: function () { return number_js_1.maxUint240; } });
		Object.defineProperty(exports, "maxUint248", { enumerable: true, get: function () { return number_js_1.maxUint248; } });
		Object.defineProperty(exports, "maxUint256", { enumerable: true, get: function () { return number_js_1.maxUint256; } });
		Object.defineProperty(exports, "minInt8", { enumerable: true, get: function () { return number_js_1.minInt8; } });
		Object.defineProperty(exports, "minInt16", { enumerable: true, get: function () { return number_js_1.minInt16; } });
		Object.defineProperty(exports, "minInt24", { enumerable: true, get: function () { return number_js_1.minInt24; } });
		Object.defineProperty(exports, "minInt32", { enumerable: true, get: function () { return number_js_1.minInt32; } });
		Object.defineProperty(exports, "minInt40", { enumerable: true, get: function () { return number_js_1.minInt40; } });
		Object.defineProperty(exports, "minInt48", { enumerable: true, get: function () { return number_js_1.minInt48; } });
		Object.defineProperty(exports, "minInt56", { enumerable: true, get: function () { return number_js_1.minInt56; } });
		Object.defineProperty(exports, "minInt64", { enumerable: true, get: function () { return number_js_1.minInt64; } });
		Object.defineProperty(exports, "minInt72", { enumerable: true, get: function () { return number_js_1.minInt72; } });
		Object.defineProperty(exports, "minInt80", { enumerable: true, get: function () { return number_js_1.minInt80; } });
		Object.defineProperty(exports, "minInt88", { enumerable: true, get: function () { return number_js_1.minInt88; } });
		Object.defineProperty(exports, "minInt96", { enumerable: true, get: function () { return number_js_1.minInt96; } });
		Object.defineProperty(exports, "minInt104", { enumerable: true, get: function () { return number_js_1.minInt104; } });
		Object.defineProperty(exports, "minInt112", { enumerable: true, get: function () { return number_js_1.minInt112; } });
		Object.defineProperty(exports, "minInt120", { enumerable: true, get: function () { return number_js_1.minInt120; } });
		Object.defineProperty(exports, "minInt128", { enumerable: true, get: function () { return number_js_1.minInt128; } });
		Object.defineProperty(exports, "minInt136", { enumerable: true, get: function () { return number_js_1.minInt136; } });
		Object.defineProperty(exports, "minInt144", { enumerable: true, get: function () { return number_js_1.minInt144; } });
		Object.defineProperty(exports, "minInt152", { enumerable: true, get: function () { return number_js_1.minInt152; } });
		Object.defineProperty(exports, "minInt160", { enumerable: true, get: function () { return number_js_1.minInt160; } });
		Object.defineProperty(exports, "minInt168", { enumerable: true, get: function () { return number_js_1.minInt168; } });
		Object.defineProperty(exports, "minInt176", { enumerable: true, get: function () { return number_js_1.minInt176; } });
		Object.defineProperty(exports, "minInt184", { enumerable: true, get: function () { return number_js_1.minInt184; } });
		Object.defineProperty(exports, "minInt192", { enumerable: true, get: function () { return number_js_1.minInt192; } });
		Object.defineProperty(exports, "minInt200", { enumerable: true, get: function () { return number_js_1.minInt200; } });
		Object.defineProperty(exports, "minInt208", { enumerable: true, get: function () { return number_js_1.minInt208; } });
		Object.defineProperty(exports, "minInt216", { enumerable: true, get: function () { return number_js_1.minInt216; } });
		Object.defineProperty(exports, "minInt224", { enumerable: true, get: function () { return number_js_1.minInt224; } });
		Object.defineProperty(exports, "minInt232", { enumerable: true, get: function () { return number_js_1.minInt232; } });
		Object.defineProperty(exports, "minInt240", { enumerable: true, get: function () { return number_js_1.minInt240; } });
		Object.defineProperty(exports, "minInt248", { enumerable: true, get: function () { return number_js_1.minInt248; } });
		Object.defineProperty(exports, "minInt256", { enumerable: true, get: function () { return number_js_1.minInt256; } });
		var bytes_js_1 = bytes;
		Object.defineProperty(exports, "zeroHash", { enumerable: true, get: function () { return bytes_js_1.zeroHash; } });
		var strings_js_1 = strings;
		Object.defineProperty(exports, "presignMessagePrefix", { enumerable: true, get: function () { return strings_js_1.presignMessagePrefix; } });
		var abi_js_1 = requireAbi();
		Object.defineProperty(exports, "AbiConstructorNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiConstructorNotFoundError; } });
		Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiConstructorParamsNotFoundError; } });
		Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function () { return abi_js_1.AbiDecodingDataSizeInvalidError; } });
		Object.defineProperty(exports, "AbiDecodingDataSizeTooSmallError", { enumerable: true, get: function () { return abi_js_1.AbiDecodingDataSizeTooSmallError; } });
		Object.defineProperty(exports, "AbiDecodingZeroDataError", { enumerable: true, get: function () { return abi_js_1.AbiDecodingZeroDataError; } });
		Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function () { return abi_js_1.AbiEncodingArrayLengthMismatchError; } });
		Object.defineProperty(exports, "AbiEncodingLengthMismatchError", { enumerable: true, get: function () { return abi_js_1.AbiEncodingLengthMismatchError; } });
		Object.defineProperty(exports, "AbiEncodingBytesSizeMismatchError", { enumerable: true, get: function () { return abi_js_1.AbiEncodingBytesSizeMismatchError; } });
		Object.defineProperty(exports, "AbiErrorInputsNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiErrorInputsNotFoundError; } });
		Object.defineProperty(exports, "AbiErrorNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiErrorNotFoundError; } });
		Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiErrorSignatureNotFoundError; } });
		Object.defineProperty(exports, "AbiEventNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiEventNotFoundError; } });
		Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function () { return abi_js_1.AbiEventSignatureEmptyTopicsError; } });
		Object.defineProperty(exports, "AbiEventSignatureNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiEventSignatureNotFoundError; } });
		Object.defineProperty(exports, "AbiFunctionNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiFunctionNotFoundError; } });
		Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiFunctionOutputsNotFoundError; } });
		Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function () { return abi_js_1.AbiFunctionSignatureNotFoundError; } });
		Object.defineProperty(exports, "BytesSizeMismatchError", { enumerable: true, get: function () { return abi_js_1.BytesSizeMismatchError; } });
		Object.defineProperty(exports, "DecodeLogDataMismatch", { enumerable: true, get: function () { return abi_js_1.DecodeLogDataMismatch; } });
		Object.defineProperty(exports, "DecodeLogTopicsMismatch", { enumerable: true, get: function () { return abi_js_1.DecodeLogTopicsMismatch; } });
		Object.defineProperty(exports, "InvalidAbiDecodingTypeError", { enumerable: true, get: function () { return abi_js_1.InvalidAbiDecodingTypeError; } });
		Object.defineProperty(exports, "InvalidAbiEncodingTypeError", { enumerable: true, get: function () { return abi_js_1.InvalidAbiEncodingTypeError; } });
		Object.defineProperty(exports, "InvalidArrayError", { enumerable: true, get: function () { return abi_js_1.InvalidArrayError; } });
		Object.defineProperty(exports, "InvalidDefinitionTypeError", { enumerable: true, get: function () { return abi_js_1.InvalidDefinitionTypeError; } });
		Object.defineProperty(exports, "UnsupportedPackedAbiType", { enumerable: true, get: function () { return abi_js_1.UnsupportedPackedAbiType; } });
		var base_js_1 = base$1;
		Object.defineProperty(exports, "BaseError", { enumerable: true, get: function () { return base_js_1.BaseError; } });
		Object.defineProperty(exports, "setErrorConfig", { enumerable: true, get: function () { return base_js_1.setErrorConfig; } });
		var block_js_1 = block$1;
		Object.defineProperty(exports, "BlockNotFoundError", { enumerable: true, get: function () { return block_js_1.BlockNotFoundError; } });
		var contract_js_1 = contract$2;
		Object.defineProperty(exports, "CallExecutionError", { enumerable: true, get: function () { return contract_js_1.CallExecutionError; } });
		Object.defineProperty(exports, "ContractFunctionExecutionError", { enumerable: true, get: function () { return contract_js_1.ContractFunctionExecutionError; } });
		Object.defineProperty(exports, "ContractFunctionRevertedError", { enumerable: true, get: function () { return contract_js_1.ContractFunctionRevertedError; } });
		Object.defineProperty(exports, "ContractFunctionZeroDataError", { enumerable: true, get: function () { return contract_js_1.ContractFunctionZeroDataError; } });
		Object.defineProperty(exports, "RawContractError", { enumerable: true, get: function () { return contract_js_1.RawContractError; } });
		Object.defineProperty(exports, "CounterfactualDeploymentFailedError", { enumerable: true, get: function () { return contract_js_1.CounterfactualDeploymentFailedError; } });
		var fee_js_1 = fee;
		Object.defineProperty(exports, "BaseFeeScalarError", { enumerable: true, get: function () { return fee_js_1.BaseFeeScalarError; } });
		Object.defineProperty(exports, "Eip1559FeesNotSupportedError", { enumerable: true, get: function () { return fee_js_1.Eip1559FeesNotSupportedError; } });
		Object.defineProperty(exports, "MaxFeePerGasTooLowError", { enumerable: true, get: function () { return fee_js_1.MaxFeePerGasTooLowError; } });
		var rpc_js_1 = rpc;
		Object.defineProperty(exports, "ChainDisconnectedError", { enumerable: true, get: function () { return rpc_js_1.ChainDisconnectedError; } });
		Object.defineProperty(exports, "InternalRpcError", { enumerable: true, get: function () { return rpc_js_1.InternalRpcError; } });
		Object.defineProperty(exports, "InvalidInputRpcError", { enumerable: true, get: function () { return rpc_js_1.InvalidInputRpcError; } });
		Object.defineProperty(exports, "InvalidParamsRpcError", { enumerable: true, get: function () { return rpc_js_1.InvalidParamsRpcError; } });
		Object.defineProperty(exports, "InvalidRequestRpcError", { enumerable: true, get: function () { return rpc_js_1.InvalidRequestRpcError; } });
		Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function () { return rpc_js_1.JsonRpcVersionUnsupportedError; } });
		Object.defineProperty(exports, "LimitExceededRpcError", { enumerable: true, get: function () { return rpc_js_1.LimitExceededRpcError; } });
		Object.defineProperty(exports, "MethodNotFoundRpcError", { enumerable: true, get: function () { return rpc_js_1.MethodNotFoundRpcError; } });
		Object.defineProperty(exports, "MethodNotSupportedRpcError", { enumerable: true, get: function () { return rpc_js_1.MethodNotSupportedRpcError; } });
		Object.defineProperty(exports, "ParseRpcError", { enumerable: true, get: function () { return rpc_js_1.ParseRpcError; } });
		Object.defineProperty(exports, "ProviderDisconnectedError", { enumerable: true, get: function () { return rpc_js_1.ProviderDisconnectedError; } });
		Object.defineProperty(exports, "ProviderRpcError", { enumerable: true, get: function () { return rpc_js_1.ProviderRpcError; } });
		Object.defineProperty(exports, "ResourceNotFoundRpcError", { enumerable: true, get: function () { return rpc_js_1.ResourceNotFoundRpcError; } });
		Object.defineProperty(exports, "ResourceUnavailableRpcError", { enumerable: true, get: function () { return rpc_js_1.ResourceUnavailableRpcError; } });
		Object.defineProperty(exports, "RpcError", { enumerable: true, get: function () { return rpc_js_1.RpcError; } });
		Object.defineProperty(exports, "SwitchChainError", { enumerable: true, get: function () { return rpc_js_1.SwitchChainError; } });
		Object.defineProperty(exports, "TransactionRejectedRpcError", { enumerable: true, get: function () { return rpc_js_1.TransactionRejectedRpcError; } });
		Object.defineProperty(exports, "UnauthorizedProviderError", { enumerable: true, get: function () { return rpc_js_1.UnauthorizedProviderError; } });
		Object.defineProperty(exports, "UnknownRpcError", { enumerable: true, get: function () { return rpc_js_1.UnknownRpcError; } });
		Object.defineProperty(exports, "UnsupportedProviderMethodError", { enumerable: true, get: function () { return rpc_js_1.UnsupportedProviderMethodError; } });
		Object.defineProperty(exports, "UserRejectedRequestError", { enumerable: true, get: function () { return rpc_js_1.UserRejectedRequestError; } });
		var chain_js_1 = chain;
		Object.defineProperty(exports, "ChainDoesNotSupportContract", { enumerable: true, get: function () { return chain_js_1.ChainDoesNotSupportContract; } });
		Object.defineProperty(exports, "ChainMismatchError", { enumerable: true, get: function () { return chain_js_1.ChainMismatchError; } });
		Object.defineProperty(exports, "ChainNotFoundError", { enumerable: true, get: function () { return chain_js_1.ChainNotFoundError; } });
		Object.defineProperty(exports, "ClientChainNotConfiguredError", { enumerable: true, get: function () { return chain_js_1.ClientChainNotConfiguredError; } });
		Object.defineProperty(exports, "InvalidChainIdError", { enumerable: true, get: function () { return chain_js_1.InvalidChainIdError; } });
		var encoding_js_1 = encoding;
		Object.defineProperty(exports, "InvalidBytesBooleanError", { enumerable: true, get: function () { return encoding_js_1.InvalidBytesBooleanError; } });
		Object.defineProperty(exports, "IntegerOutOfRangeError", { enumerable: true, get: function () { return encoding_js_1.IntegerOutOfRangeError; } });
		Object.defineProperty(exports, "InvalidHexBooleanError", { enumerable: true, get: function () { return encoding_js_1.InvalidHexBooleanError; } });
		Object.defineProperty(exports, "InvalidHexValueError", { enumerable: true, get: function () { return encoding_js_1.InvalidHexValueError; } });
		Object.defineProperty(exports, "SizeOverflowError", { enumerable: true, get: function () { return encoding_js_1.SizeOverflowError; } });
		var ens_js_1 = ens;
		Object.defineProperty(exports, "EnsAvatarUriResolutionError", { enumerable: true, get: function () { return ens_js_1.EnsAvatarUriResolutionError; } });
		Object.defineProperty(exports, "EnsAvatarInvalidNftUriError", { enumerable: true, get: function () { return ens_js_1.EnsAvatarInvalidNftUriError; } });
		Object.defineProperty(exports, "EnsAvatarUnsupportedNamespaceError", { enumerable: true, get: function () { return ens_js_1.EnsAvatarUnsupportedNamespaceError; } });
		var estimateGas_js_1 = estimateGas$2;
		Object.defineProperty(exports, "EstimateGasExecutionError", { enumerable: true, get: function () { return estimateGas_js_1.EstimateGasExecutionError; } });
		var node_js_1 = node;
		Object.defineProperty(exports, "ExecutionRevertedError", { enumerable: true, get: function () { return node_js_1.ExecutionRevertedError; } });
		Object.defineProperty(exports, "FeeCapTooHighError", { enumerable: true, get: function () { return node_js_1.FeeCapTooHighError; } });
		Object.defineProperty(exports, "FeeCapTooLowError", { enumerable: true, get: function () { return node_js_1.FeeCapTooLowError; } });
		Object.defineProperty(exports, "InsufficientFundsError", { enumerable: true, get: function () { return node_js_1.InsufficientFundsError; } });
		Object.defineProperty(exports, "IntrinsicGasTooHighError", { enumerable: true, get: function () { return node_js_1.IntrinsicGasTooHighError; } });
		Object.defineProperty(exports, "IntrinsicGasTooLowError", { enumerable: true, get: function () { return node_js_1.IntrinsicGasTooLowError; } });
		Object.defineProperty(exports, "NonceMaxValueError", { enumerable: true, get: function () { return node_js_1.NonceMaxValueError; } });
		Object.defineProperty(exports, "NonceTooHighError", { enumerable: true, get: function () { return node_js_1.NonceTooHighError; } });
		Object.defineProperty(exports, "NonceTooLowError", { enumerable: true, get: function () { return node_js_1.NonceTooLowError; } });
		Object.defineProperty(exports, "TipAboveFeeCapError", { enumerable: true, get: function () { return node_js_1.TipAboveFeeCapError; } });
		Object.defineProperty(exports, "TransactionTypeNotSupportedError", { enumerable: true, get: function () { return node_js_1.TransactionTypeNotSupportedError; } });
		Object.defineProperty(exports, "UnknownNodeError", { enumerable: true, get: function () { return node_js_1.UnknownNodeError; } });
		var log_js_1 = log$1;
		Object.defineProperty(exports, "FilterTypeNotSupportedError", { enumerable: true, get: function () { return log_js_1.FilterTypeNotSupportedError; } });
		var request_js_1 = request;
		Object.defineProperty(exports, "HttpRequestError", { enumerable: true, get: function () { return request_js_1.HttpRequestError; } });
		Object.defineProperty(exports, "RpcRequestError", { enumerable: true, get: function () { return request_js_1.RpcRequestError; } });
		Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return request_js_1.TimeoutError; } });
		Object.defineProperty(exports, "SocketClosedError", { enumerable: true, get: function () { return request_js_1.SocketClosedError; } });
		Object.defineProperty(exports, "WebSocketRequestError", { enumerable: true, get: function () { return request_js_1.WebSocketRequestError; } });
		var address_js_2 = address$2;
		Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function () { return address_js_2.InvalidAddressError; } });
		var transaction_js_1 = transaction$1;
		Object.defineProperty(exports, "FeeConflictError", { enumerable: true, get: function () { return transaction_js_1.FeeConflictError; } });
		Object.defineProperty(exports, "InvalidLegacyVError", { enumerable: true, get: function () { return transaction_js_1.InvalidLegacyVError; } });
		Object.defineProperty(exports, "InvalidSerializableTransactionError", { enumerable: true, get: function () { return transaction_js_1.InvalidSerializableTransactionError; } });
		Object.defineProperty(exports, "InvalidSerializedTransactionError", { enumerable: true, get: function () { return transaction_js_1.InvalidSerializedTransactionError; } });
		Object.defineProperty(exports, "InvalidSerializedTransactionTypeError", { enumerable: true, get: function () { return transaction_js_1.InvalidSerializedTransactionTypeError; } });
		Object.defineProperty(exports, "InvalidStorageKeySizeError", { enumerable: true, get: function () { return transaction_js_1.InvalidStorageKeySizeError; } });
		Object.defineProperty(exports, "TransactionExecutionError", { enumerable: true, get: function () { return transaction_js_1.TransactionExecutionError; } });
		Object.defineProperty(exports, "TransactionNotFoundError", { enumerable: true, get: function () { return transaction_js_1.TransactionNotFoundError; } });
		Object.defineProperty(exports, "TransactionReceiptNotFoundError", { enumerable: true, get: function () { return transaction_js_1.TransactionReceiptNotFoundError; } });
		Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function () { return transaction_js_1.WaitForTransactionReceiptTimeoutError; } });
		var data_js_1 = data;
		Object.defineProperty(exports, "SizeExceedsPaddingSizeError", { enumerable: true, get: function () { return data_js_1.SizeExceedsPaddingSizeError; } });
		Object.defineProperty(exports, "SliceOffsetOutOfBoundsError", { enumerable: true, get: function () { return data_js_1.SliceOffsetOutOfBoundsError; } });
		var transport_js_1 = transport;
		Object.defineProperty(exports, "UrlRequiredError", { enumerable: true, get: function () { return transport_js_1.UrlRequiredError; } });
		var stateOverride_js_1 = stateOverride$1;
		Object.defineProperty(exports, "AccountStateConflictError", { enumerable: true, get: function () { return stateOverride_js_1.AccountStateConflictError; } });
		Object.defineProperty(exports, "StateAssignmentConflictError", { enumerable: true, get: function () { return stateOverride_js_1.StateAssignmentConflictError; } });
		var eip1193_js_1 = eip1193;
		Object.defineProperty(exports, "EIP1193ProviderRpcError", { enumerable: true, get: function () { return eip1193_js_1.ProviderRpcError; } });
		var labelhash_js_1 = labelhash$1;
		Object.defineProperty(exports, "labelhash", { enumerable: true, get: function () { return labelhash_js_1.labelhash; } });
		var namehash_js_1 = namehash$1;
		Object.defineProperty(exports, "namehash", { enumerable: true, get: function () { return namehash_js_1.namehash; } });
		var block_js_2 = block;
		Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function () { return block_js_2.defineBlock; } });
		Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function () { return block_js_2.formatBlock; } });
		var log_js_2 = log;
		Object.defineProperty(exports, "formatLog", { enumerable: true, get: function () { return log_js_2.formatLog; } });
		var decodeAbiParameters_js_1 = decodeAbiParameters$1;
		Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function () { return decodeAbiParameters_js_1.decodeAbiParameters; } });
		var decodeDeployData_js_1 = decodeDeployData$1;
		Object.defineProperty(exports, "decodeDeployData", { enumerable: true, get: function () { return decodeDeployData_js_1.decodeDeployData; } });
		var decodeErrorResult_js_1 = decodeErrorResult$1;
		Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function () { return decodeErrorResult_js_1.decodeErrorResult; } });
		var decodeEventLog_js_1 = decodeEventLog$1;
		Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function () { return decodeEventLog_js_1.decodeEventLog; } });
		var decodeFunctionData_js_1 = decodeFunctionData$1;
		Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function () { return decodeFunctionData_js_1.decodeFunctionData; } });
		var decodeFunctionResult_js_1 = decodeFunctionResult$1;
		Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function () { return decodeFunctionResult_js_1.decodeFunctionResult; } });
		var encodeAbiParameters_js_1 = encodeAbiParameters$3;
		Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function () { return encodeAbiParameters_js_1.encodeAbiParameters; } });
		var encodeDeployData_js_1 = encodeDeployData$1;
		Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function () { return encodeDeployData_js_1.encodeDeployData; } });
		var encodeErrorResult_js_1 = encodeErrorResult$1;
		Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function () { return encodeErrorResult_js_1.encodeErrorResult; } });
		var encodeEventTopics_js_1 = encodeEventTopics$1;
		Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function () { return encodeEventTopics_js_1.encodeEventTopics; } });
		var encodeFunctionData_js_1 = encodeFunctionData$1;
		Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function () { return encodeFunctionData_js_1.encodeFunctionData; } });
		var prepareEncodeFunctionData_js_1 = prepareEncodeFunctionData$1;
		Object.defineProperty(exports, "prepareEncodeFunctionData", { enumerable: true, get: function () { return prepareEncodeFunctionData_js_1.prepareEncodeFunctionData; } });
		var encodeFunctionResult_js_1 = encodeFunctionResult$1;
		Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function () { return encodeFunctionResult_js_1.encodeFunctionResult; } });
		var parseEventLogs_js_1 = parseEventLogs$2;
		Object.defineProperty(exports, "parseEventLogs", { enumerable: true, get: function () { return parseEventLogs_js_1.parseEventLogs; } });
		var transaction_js_2 = transaction;
		Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function () { return transaction_js_2.defineTransaction; } });
		Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function () { return transaction_js_2.formatTransaction; } });
		Object.defineProperty(exports, "transactionType", { enumerable: true, get: function () { return transaction_js_2.transactionType; } });
		var transactionReceipt_js_1 = transactionReceipt;
		Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function () { return transactionReceipt_js_1.defineTransactionReceipt; } });
		Object.defineProperty(exports, "formatTransactionReceipt", { enumerable: true, get: function () { return transactionReceipt_js_1.formatTransactionReceipt; } });
		var transactionRequest_js_1 = transactionRequest;
		Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function () { return transactionRequest_js_1.defineTransactionRequest; } });
		Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function () { return transactionRequest_js_1.formatTransactionRequest; } });
		Object.defineProperty(exports, "rpcTransactionType", { enumerable: true, get: function () { return transactionRequest_js_1.rpcTransactionType; } });
		var getAbiItem_js_1 = getAbiItem$1;
		Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function () { return getAbiItem_js_1.getAbiItem; } });
		var getContractAddress_js_1 = getContractAddress$1;
		Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function () { return getContractAddress_js_1.getContractAddress; } });
		Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function () { return getContractAddress_js_1.getCreate2Address; } });
		Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function () { return getContractAddress_js_1.getCreateAddress; } });
		var getSerializedTransactionType_js_1 = getSerializedTransactionType$1;
		Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function () { return getSerializedTransactionType_js_1.getSerializedTransactionType; } });
		var getTransactionType_js_1 = getTransactionType$1;
		Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function () { return getTransactionType_js_1.getTransactionType; } });
		var hashTypedData_js_1 = requireHashTypedData();
		Object.defineProperty(exports, "hashDomain", { enumerable: true, get: function () { return hashTypedData_js_1.hashDomain; } });
		Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function () { return hashTypedData_js_1.hashTypedData; } });
		var compactSignatureToSignature_js_1 = compactSignatureToSignature$1;
		Object.defineProperty(exports, "compactSignatureToSignature", { enumerable: true, get: function () { return compactSignatureToSignature_js_1.compactSignatureToSignature; } });
		var parseCompactSignature_js_1 = parseCompactSignature$1;
		Object.defineProperty(exports, "hexToCompactSignature", { enumerable: true, get: function () { return parseCompactSignature_js_1.parseCompactSignature; } });
		Object.defineProperty(exports, "parseCompactSignature", { enumerable: true, get: function () { return parseCompactSignature_js_1.parseCompactSignature; } });
		var parseSignature_js_1 = parseSignature$1;
		Object.defineProperty(exports, "hexToSignature", { enumerable: true, get: function () { return parseSignature_js_1.parseSignature; } });
		Object.defineProperty(exports, "parseSignature", { enumerable: true, get: function () { return parseSignature_js_1.parseSignature; } });
		var recoverAddress_js_1 = recoverAddress$1;
		Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function () { return recoverAddress_js_1.recoverAddress; } });
		var recoverMessageAddress_js_1 = recoverMessageAddress$1;
		Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function () { return recoverMessageAddress_js_1.recoverMessageAddress; } });
		var recoverPublicKey_js_1 = recoverPublicKey$1;
		Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function () { return recoverPublicKey_js_1.recoverPublicKey; } });
		var recoverTransactionAddress_js_1 = recoverTransactionAddress$1;
		Object.defineProperty(exports, "recoverTransactionAddress", { enumerable: true, get: function () { return recoverTransactionAddress_js_1.recoverTransactionAddress; } });
		var recoverTypedDataAddress_js_1 = recoverTypedDataAddress$1;
		Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function () { return recoverTypedDataAddress_js_1.recoverTypedDataAddress; } });
		var signatureToCompactSignature_js_1 = signatureToCompactSignature$1;
		Object.defineProperty(exports, "signatureToCompactSignature", { enumerable: true, get: function () { return signatureToCompactSignature_js_1.signatureToCompactSignature; } });
		var serializeCompactSignature_js_1 = serializeCompactSignature$1;
		Object.defineProperty(exports, "compactSignatureToHex", { enumerable: true, get: function () { return serializeCompactSignature_js_1.serializeCompactSignature; } });
		Object.defineProperty(exports, "serializeCompactSignature", { enumerable: true, get: function () { return serializeCompactSignature_js_1.serializeCompactSignature; } });
		var serializeSignature_js_1 = serializeSignature$1;
		Object.defineProperty(exports, "signatureToHex", { enumerable: true, get: function () { return serializeSignature_js_1.serializeSignature; } });
		Object.defineProperty(exports, "serializeSignature", { enumerable: true, get: function () { return serializeSignature_js_1.serializeSignature; } });
		var toRlp_js_1 = toRlp$1;
		Object.defineProperty(exports, "bytesToRlp", { enumerable: true, get: function () { return toRlp_js_1.bytesToRlp; } });
		Object.defineProperty(exports, "hexToRlp", { enumerable: true, get: function () { return toRlp_js_1.hexToRlp; } });
		Object.defineProperty(exports, "toRlp", { enumerable: true, get: function () { return toRlp_js_1.toRlp; } });
		var verifyHash_js_1 = verifyHash$5;
		Object.defineProperty(exports, "verifyHash", { enumerable: true, get: function () { return verifyHash_js_1.verifyHash; } });
		var verifyMessage_js_1 = verifyMessage$3;
		Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function () { return verifyMessage_js_1.verifyMessage; } });
		var verifyTypedData_js_1 = verifyTypedData$5;
		Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function () { return verifyTypedData_js_1.verifyTypedData; } });
		var parseErc6492Signature_js_1 = parseErc6492Signature$1;
		Object.defineProperty(exports, "parseErc6492Signature", { enumerable: true, get: function () { return parseErc6492Signature_js_1.parseErc6492Signature; } });
		var isErc6492Signature_js_1 = isErc6492Signature$3;
		Object.defineProperty(exports, "isErc6492Signature", { enumerable: true, get: function () { return isErc6492Signature_js_1.isErc6492Signature; } });
		var serializeErc6492Signature_js_1 = serializeErc6492Signature$3;
		Object.defineProperty(exports, "serializeErc6492Signature", { enumerable: true, get: function () { return serializeErc6492Signature_js_1.serializeErc6492Signature; } });
		var assertRequest_js_1 = assertRequest$1;
		Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function () { return assertRequest_js_1.assertRequest; } });
		var assertTransaction_js_1 = assertTransaction;
		Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP1559; } });
		Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP2930; } });
		Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionLegacy; } });
		var toBytes_js_1 = requireToBytes();
		Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function () { return toBytes_js_1.boolToBytes; } });
		Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function () { return toBytes_js_1.hexToBytes; } });
		Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function () { return toBytes_js_1.numberToBytes; } });
		Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function () { return toBytes_js_1.stringToBytes; } });
		Object.defineProperty(exports, "toBytes", { enumerable: true, get: function () { return toBytes_js_1.toBytes; } });
		var toHex_js_1 = requireToHex();
		Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function () { return toHex_js_1.boolToHex; } });
		Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return toHex_js_1.bytesToHex; } });
		Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function () { return toHex_js_1.numberToHex; } });
		Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function () { return toHex_js_1.stringToHex; } });
		Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return toHex_js_1.toHex; } });
		var fromBytes_js_1 = fromBytes$3;
		Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } });
		Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function () { return fromBytes_js_1.bytesToBool; } });
		Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function () { return fromBytes_js_1.bytesToNumber; } });
		Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function () { return fromBytes_js_1.bytesToString; } });
		Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function () { return fromBytes_js_1.fromBytes; } });
		var ccip_js_1 = requireCcip();
		Object.defineProperty(exports, "ccipRequest", { enumerable: true, get: function () { return ccip_js_1.ccipRequest; } });
		Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function () { return ccip_js_1.ccipRequest; } });
		Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function () { return ccip_js_1.offchainLookup; } });
		Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function () { return ccip_js_1.offchainLookupAbiItem; } });
		Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function () { return ccip_js_1.offchainLookupSignature; } });
		var blobsToCommitments_js_1 = blobsToCommitments$1;
		Object.defineProperty(exports, "blobsToCommitments", { enumerable: true, get: function () { return blobsToCommitments_js_1.blobsToCommitments; } });
		var commitmentToVersionedHash_js_1 = commitmentToVersionedHash$1;
		Object.defineProperty(exports, "commitmentToVersionedHash", { enumerable: true, get: function () { return commitmentToVersionedHash_js_1.commitmentToVersionedHash; } });
		var commitmentsToVersionedHashes_js_1 = commitmentsToVersionedHashes$1;
		Object.defineProperty(exports, "commitmentsToVersionedHashes", { enumerable: true, get: function () { return commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes; } });
		var sidecarsToVersionedHashes_js_1 = sidecarsToVersionedHashes$1;
		Object.defineProperty(exports, "sidecarsToVersionedHashes", { enumerable: true, get: function () { return sidecarsToVersionedHashes_js_1.sidecarsToVersionedHashes; } });
		var blobsToProofs_js_1 = blobsToProofs$1;
		Object.defineProperty(exports, "blobsToProofs", { enumerable: true, get: function () { return blobsToProofs_js_1.blobsToProofs; } });
		var fromBlobs_js_1 = fromBlobs$1;
		Object.defineProperty(exports, "fromBlobs", { enumerable: true, get: function () { return fromBlobs_js_1.fromBlobs; } });
		var toBlobSidecars_js_1 = toBlobSidecars$1;
		Object.defineProperty(exports, "toBlobSidecars", { enumerable: true, get: function () { return toBlobSidecars_js_1.toBlobSidecars; } });
		var toBlobs_js_1 = toBlobs$1;
		Object.defineProperty(exports, "toBlobs", { enumerable: true, get: function () { return toBlobs_js_1.toBlobs; } });
		var defineKzg_js_1 = defineKzg$1;
		Object.defineProperty(exports, "defineKzg", { enumerable: true, get: function () { return defineKzg_js_1.defineKzg; } });
		var setupKzg_js_1 = setupKzg$1;
		Object.defineProperty(exports, "setupKzg", { enumerable: true, get: function () { return setupKzg_js_1.setupKzg; } });
		var concat_js_1 = concat$1;
		Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_js_1.concat; } });
		Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return concat_js_1.concatBytes; } });
		Object.defineProperty(exports, "concatHex", { enumerable: true, get: function () { return concat_js_1.concatHex; } });
		var assertCurrentChain_js_1 = assertCurrentChain$1;
		Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function () { return assertCurrentChain_js_1.assertCurrentChain; } });
		var defineChain_js_1 = defineChain$1;
		Object.defineProperty(exports, "defineChain", { enumerable: true, get: function () { return defineChain_js_1.defineChain; } });
		var extractChain_js_1 = extractChain$1;
		Object.defineProperty(exports, "extractChain", { enumerable: true, get: function () { return extractChain_js_1.extractChain; } });
		var getChainContractAddress_js_1 = getChainContractAddress$1;
		Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function () { return getChainContractAddress_js_1.getChainContractAddress; } });
		var encodePacked_js_1 = encodePacked$1;
		Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function () { return encodePacked_js_1.encodePacked; } });
		var withRetry_js_1 = withRetry$1;
		Object.defineProperty(exports, "withRetry", { enumerable: true, get: function () { return withRetry_js_1.withRetry; } });
		var withTimeout_js_1 = withTimeout$1;
		Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function () { return withTimeout_js_1.withTimeout; } });
		var formatEther_js_1 = formatEther$1;
		Object.defineProperty(exports, "formatEther", { enumerable: true, get: function () { return formatEther_js_1.formatEther; } });
		var formatGwei_js_1 = formatGwei$1;
		Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function () { return formatGwei_js_1.formatGwei; } });
		var formatUnits_js_1 = formatUnits$1;
		Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function () { return formatUnits_js_1.formatUnits; } });
		var fromHex_js_1 = requireFromHex();
		Object.defineProperty(exports, "fromHex", { enumerable: true, get: function () { return fromHex_js_1.fromHex; } });
		Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function () { return fromHex_js_1.hexToBigInt; } });
		Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function () { return fromHex_js_1.hexToBool; } });
		Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function () { return fromHex_js_1.hexToNumber; } });
		Object.defineProperty(exports, "hexToString", { enumerable: true, get: function () { return fromHex_js_1.hexToString; } });
		var fromRlp_js_1 = fromRlp$1;
		Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function () { return fromRlp_js_1.fromRlp; } });
		var getAddress_js_1 = requireGetAddress();
		Object.defineProperty(exports, "checksumAddress", { enumerable: true, get: function () { return getAddress_js_1.checksumAddress; } });
		Object.defineProperty(exports, "getAddress", { enumerable: true, get: function () { return getAddress_js_1.getAddress; } });
		var getContractError_js_1 = getContractError$1;
		Object.defineProperty(exports, "getContractError", { enumerable: true, get: function () { return getContractError_js_1.getContractError; } });
		var toEventSelector_js_1 = toEventSelector;
		Object.defineProperty(exports, "toEventSelector", { enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } });
		Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } });
		var toFunctionSelector_js_1 = toFunctionSelector$1;
		Object.defineProperty(exports, "toFunctionSelector", { enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } });
		Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } });
		var toEventSignature_js_1 = toEventSignature;
		Object.defineProperty(exports, "toEventSignature", { enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } });
		Object.defineProperty(exports, "getEventSignature", { enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } });
		var toFunctionSignature_js_1 = toFunctionSignature;
		Object.defineProperty(exports, "toFunctionSignature", { enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } });
		Object.defineProperty(exports, "getFunctionSignature", { enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } });
		var toEventHash_js_1 = toEventHash;
		Object.defineProperty(exports, "toEventHash", { enumerable: true, get: function () { return toEventHash_js_1.toEventHash; } });
		var toFunctionHash_js_1 = toFunctionHash;
		Object.defineProperty(exports, "toFunctionHash", { enumerable: true, get: function () { return toFunctionHash_js_1.toFunctionHash; } });
		var hashMessage_js_1 = hashMessage$1;
		Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function () { return hashMessage_js_1.hashMessage; } });
		var toPrefixedMessage_js_1 = toPrefixedMessage$1;
		Object.defineProperty(exports, "toPrefixedMessage", { enumerable: true, get: function () { return toPrefixedMessage_js_1.toPrefixedMessage; } });
		var isAddress_js_1 = requireIsAddress();
		Object.defineProperty(exports, "isAddress", { enumerable: true, get: function () { return isAddress_js_1.isAddress; } });
		var isAddressEqual_js_1 = isAddressEqual$1;
		Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function () { return isAddressEqual_js_1.isAddressEqual; } });
		var isBytes_js_1 = isBytes$1;
		Object.defineProperty(exports, "isBytes", { enumerable: true, get: function () { return isBytes_js_1.isBytes; } });
		var isHash_js_1 = isHash$1;
		Object.defineProperty(exports, "isHash", { enumerable: true, get: function () { return isHash_js_1.isHash; } });
		var isHex_js_1 = isHex$1;
		Object.defineProperty(exports, "isHex", { enumerable: true, get: function () { return isHex_js_1.isHex; } });
		var keccak256_js_1 = keccak256$3;
		Object.defineProperty(exports, "keccak256", { enumerable: true, get: function () { return keccak256_js_1.keccak256; } });
		var sha256_js_1 = sha256$1;
		Object.defineProperty(exports, "sha256", { enumerable: true, get: function () { return sha256_js_1.sha256; } });
		var ripemd160_js_1 = ripemd160$2;
		Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } });
		var pad_js_1 = pad$1;
		Object.defineProperty(exports, "pad", { enumerable: true, get: function () { return pad_js_1.pad; } });
		Object.defineProperty(exports, "padBytes", { enumerable: true, get: function () { return pad_js_1.padBytes; } });
		Object.defineProperty(exports, "padHex", { enumerable: true, get: function () { return pad_js_1.padHex; } });
		var parseEther_js_1 = parseEther$1;
		Object.defineProperty(exports, "parseEther", { enumerable: true, get: function () { return parseEther_js_1.parseEther; } });
		var parseGwei_js_1 = parseGwei$1;
		Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function () { return parseGwei_js_1.parseGwei; } });
		var parseTransaction_js_1 = parseTransaction$1;
		Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function () { return parseTransaction_js_1.parseTransaction; } });
		var parseUnits_js_1 = parseUnits$1;
		Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function () { return parseUnits_js_1.parseUnits; } });
		var serializeAccessList_js_1 = serializeAccessList$1;
		Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function () { return serializeAccessList_js_1.serializeAccessList; } });
		var serializeTransaction_js_1 = requireSerializeTransaction();
		Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function () { return serializeTransaction_js_1.serializeTransaction; } });
		var size_js_1 = size$2;
		Object.defineProperty(exports, "size", { enumerable: true, get: function () { return size_js_1.size; } });
		var slice_js_1 = slice$1;
		Object.defineProperty(exports, "slice", { enumerable: true, get: function () { return slice_js_1.slice; } });
		Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function () { return slice_js_1.sliceBytes; } });
		Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function () { return slice_js_1.sliceHex; } });
		var stringify_js_1 = stringify$1;
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return stringify_js_1.stringify; } });
		var trim_js_1 = trim$3;
		Object.defineProperty(exports, "trim", { enumerable: true, get: function () { return trim_js_1.trim; } });
		var typedData_js_1 = requireTypedData();
		Object.defineProperty(exports, "serializeTypedData", { enumerable: true, get: function () { return typedData_js_1.serializeTypedData; } });
		Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function () { return typedData_js_1.validateTypedData; } });
		Object.defineProperty(exports, "domainSeparator", { enumerable: true, get: function () { return typedData_js_1.domainSeparator; } });
		Object.defineProperty(exports, "getTypesForEIP712Domain", { enumerable: true, get: function () { return typedData_js_1.getTypesForEIP712Domain; } });
		var nonceManager_js_1 = nonceManager;
		Object.defineProperty(exports, "createNonceManager", { enumerable: true, get: function () { return nonceManager_js_1.createNonceManager; } });
		Object.defineProperty(exports, "nonceManager", { enumerable: true, get: function () { return nonceManager_js_1.nonceManager; } });
		
	} (_cjs));

	Object.defineProperty(eth_getBlockByHash$1, "__esModule", { value: true });
	eth_getBlockByHash$1.eth_getBlockByHash = eth_getBlockByHash;
	const viem_1$f = _cjs;
	/**
	 * Retrieves a block by its hash.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for the block retrieval.
	 * @returns A promise that resolves to the retrieved block.
	 * @throws An error if the block is not found.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getBlockByHash } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const block = await eth_getBlockByHash(rpcRequest, {
	 * blockHash: "0x...",
	 * includeTransactions: true,
	 * });
	 * ```
	 */
	async function eth_getBlockByHash(request, params) {
	    const includeTransactions = params.includeTransactions ?? false;
	    const block = await request({
	        method: "eth_getBlockByHash",
	        params: [params.blockHash, includeTransactions],
	    });
	    if (!block) {
	        throw new Error("Block not found");
	    }
	    return (0, viem_1$f.formatBlock)(block);
	}

	var eth_getBlockByNumber$1 = {};

	Object.defineProperty(eth_getBlockByNumber$1, "__esModule", { value: true });
	eth_getBlockByNumber$1.eth_getBlockByNumber = eth_getBlockByNumber;
	const viem_1$e = _cjs;
	const hex_js_1$9 = hex;
	/**
	 * Retrieves a block by its number or tag from the Ethereum blockchain.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for retrieving the block.
	 * @returns A promise that resolves to the requested block.
	 * @throws An error if the block is not found.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getBlockByNumber } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const block = await eth_getBlockByNumber(rpcRequest, {
	 *  blockNumber: 123456,
	 *  includeTransactions: true,
	 * });
	 * ```
	 */
	async function eth_getBlockByNumber(request, params) {
	    const blockTag = params.blockTag ?? "latest";
	    const includeTransactions = params.includeTransactions ?? false;
	    const blockNumberHex = params.blockNumber !== undefined
	        ? (0, hex_js_1$9.numberToHex)(params.blockNumber)
	        : undefined;
	    const block = await request({
	        method: "eth_getBlockByNumber",
	        params: [blockNumberHex || blockTag, includeTransactions],
	    });
	    if (!block) {
	        throw new Error("Block not found");
	    }
	    return (0, viem_1$e.formatBlock)(block);
	}

	var eth_getCode$1 = {};

	Object.defineProperty(eth_getCode$1, "__esModule", { value: true });
	eth_getCode$1.eth_getCode = eth_getCode;
	/**
	 * Retrieves the bytecode of a smart contract at the specified address.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for the eth_getCode method.
	 * @returns A promise that resolves to the bytecode of the smart contract.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getCode } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const bytecode = await eth_getCode(rpcRequest, {
	 *  address: "0x...",
	 * });
	 * ```
	 */
	async function eth_getCode(request, params) {
	    return request({
	        method: "eth_getCode",
	        params: [params.address, params.blockTag || "latest"],
	    });
	}

	var eth_getLogs$1 = {};

	Object.defineProperty(eth_getLogs$1, "__esModule", { value: true });
	eth_getLogs$1.eth_getLogs = eth_getLogs;
	const viem_1$d = _cjs;
	const hex_js_1$8 = hex;
	/**
	 * Retrieves logs from the Ethereum blockchain based on the specified parameters.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for retrieving logs.
	 * @returns A promise that resolves to the retrieved logs.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getLogs } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const logs = await eth_getLogs(rpcRequest, {
	 *  address: "0x...",
	 *  fromBlock: 123456n,
	 *  toBlock: 123456n,
	 * });
	 * ```
	 */
	async function eth_getLogs(request, params = {}) {
	    const topics = params.topics ?? [];
	    let logs;
	    // in the case we have a blockHash
	    if (params.blockHash) {
	        const param = {
	            topics,
	            blockHash: params.blockHash,
	        };
	        if (params.address) {
	            param.address = params.address;
	        }
	        logs = await request({
	            method: "eth_getLogs",
	            params: [param],
	        });
	    }
	    // otherwise
	    else {
	        const param = { topics };
	        if (params.address) {
	            param.address = params.address;
	        }
	        if (params.fromBlock) {
	            param.fromBlock =
	                typeof params.fromBlock === "bigint"
	                    ? (0, hex_js_1$8.numberToHex)(params.fromBlock)
	                    : params.fromBlock;
	        }
	        if (params.toBlock) {
	            param.toBlock =
	                typeof params.toBlock === "bigint"
	                    ? (0, hex_js_1$8.numberToHex)(params.toBlock)
	                    : params.toBlock;
	        }
	        logs = await request({
	            method: "eth_getLogs",
	            params: [param],
	        });
	    }
	    return logs.map((log) => (0, viem_1$d.formatLog)(log));
	}

	var eth_getStorageAt$1 = {};

	Object.defineProperty(eth_getStorageAt$1, "__esModule", { value: true });
	eth_getStorageAt$1.eth_getStorageAt = eth_getStorageAt;
	/**
	 * Retrieves the value stored at a specific position in the storage of a contract.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for the eth_getStorageAt method.
	 * @returns A promise that resolves to the value stored at the specified position.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getStorageAt } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const storageValue = await eth_getStorageAt(rpcRequest, {
	 * address: "0x...",
	 *  position: 0n,
	 * });
	 * ```
	 */
	async function eth_getStorageAt(request, params) {
	    return await request({
	        method: "eth_getStorageAt",
	        params: [params.address, params.position, params.blockTag ?? "latest"],
	    });
	}

	var eth_getTransactionByHash$1 = {};

	Object.defineProperty(eth_getTransactionByHash$1, "__esModule", { value: true });
	eth_getTransactionByHash$1.eth_getTransactionByHash = eth_getTransactionByHash;
	const viem_1$c = _cjs;
	/**
	 * Retrieves a transaction by its hash.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for retrieving the transaction.
	 * @returns A promise that resolves to the transaction.
	 * @throws An error if the transaction is not found.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getTransactionByHash } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 *  const transaction = await eth_getTransactionByHash(rpcRequest, {
	 *  hash: "0x...",
	 * });
	 * ```
	 */
	async function eth_getTransactionByHash(request, params) {
	    const receipt = await request({
	        method: "eth_getTransactionByHash",
	        params: [params.hash],
	    });
	    if (!receipt) {
	        throw new Error("Transaction not found.");
	    }
	    return (0, viem_1$c.formatTransaction)(receipt);
	}

	var eth_getTransactionCount$1 = {};

	Object.defineProperty(eth_getTransactionCount$1, "__esModule", { value: true });
	eth_getTransactionCount$1.eth_getTransactionCount = eth_getTransactionCount;
	const hex_js_1$7 = hex;
	/**
	 * Retrieves the transaction count (nonce) for a given Ethereum address.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for retrieving the transaction count.
	 * @returns A promise that resolves to the transaction count as a number.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getTransactionCount } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const transactionCount = await eth_getTransactionCount(rpcRequest, {
	 *  address: "0x...",
	 * });
	 * ```
	 */
	async function eth_getTransactionCount(request, params) {
	    const count = await request({
	        method: "eth_getTransactionCount",
	        params: [
	            params.address,
	            // makes sense to default to `pending` here, since we're asking for a transaction count (nonce)
	            params.blockNumber
	                ? (0, hex_js_1$7.numberToHex)(params.blockNumber)
	                : params.blockTag || "pending",
	        ],
	    });
	    return (0, hex_js_1$7.hexToNumber)(count);
	}

	var eth_getTransactionReceipt$1 = {};

	Object.defineProperty(eth_getTransactionReceipt$1, "__esModule", { value: true });
	eth_getTransactionReceipt$1.eth_getTransactionReceipt = eth_getTransactionReceipt;
	const viem_1$b = _cjs;
	/**
	 * Retrieves the transaction receipt for a given transaction hash.
	 * Throws an error if the receipt is not found.
	 * @param request - The EIP1193 request function.
	 * @param params - The parameters for retrieving the transaction receipt.
	 * @returns A promise that resolves to the transaction receipt.
	 * @throws An error if the transaction receipt is not found.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_getTransactionReceipt } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const transactionReceipt = await eth_getTransactionReceipt(rpcRequest, {
	 *  hash: "0x...",
	 * });
	 * ```
	 */
	async function eth_getTransactionReceipt(request, params) {
	    const receipt = await request({
	        method: "eth_getTransactionReceipt",
	        params: [params.hash],
	    });
	    if (!receipt) {
	        throw new Error("Transaction receipt not found.");
	    }
	    return (0, viem_1$b.formatTransactionReceipt)(receipt);
	}

	var eth_maxPriorityFeePerGas$1 = {};

	Object.defineProperty(eth_maxPriorityFeePerGas$1, "__esModule", { value: true });
	eth_maxPriorityFeePerGas$1.eth_maxPriorityFeePerGas = eth_maxPriorityFeePerGas;
	const hex_js_1$6 = hex;
	/**
	 * Retrieves the maximum priority fee per gas from the Ethereum network.
	 * @param request - The EIP1193 request function.
	 * @returns A promise that resolves to a bigint representing the maximum priority fee per gas.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_maxPriorityFeePerGas } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const maxPriorityFeePerGas = await eth_maxPriorityFeePerGas(rpcRequest);
	 * ```
	 */
	async function eth_maxPriorityFeePerGas(request) {
	    const result = await request({
	        method: "eth_maxPriorityFeePerGas",
	    });
	    return (0, hex_js_1$6.hexToBigInt)(result);
	}

	var eth_sendRawTransaction$1 = {};

	Object.defineProperty(eth_sendRawTransaction$1, "__esModule", { value: true });
	eth_sendRawTransaction$1.eth_sendRawTransaction = eth_sendRawTransaction;
	/**
	 * Sends a raw transaction to the Ethereum network.
	 * @param request - The EIP1193 request function.
	 * @param signedTransaction - The signed transaction in hex format.
	 * @returns A promise that resolves to the transaction hash.
	 * @rpc
	 * @example
	 * ```ts
	 * import { getRpcClient, eth_sendRawTransaction } from "thirdweb/rpc";
	 * const rpcRequest = getRpcClient({ client, chain });
	 * const transactionHash = await eth_sendRawTransaction(rpcRequest, "0x...");
	 * ```
	 */
	async function eth_sendRawTransaction(request, signedTransaction) {
	    return await request({
	        method: "eth_sendRawTransaction",
	        params: [signedTransaction],
	    });
	}

	var contract = {};

	Object.defineProperty(contract, "__esModule", { value: true });
	contract.getContract = getContract;
	/**
	 * Creates a Thirdweb contract by combining the Thirdweb client and contract options.
	 * @param options - The options for creating the contract.
	 * @returns The Thirdweb contract.
	 * @example
	 * ```ts
	 * import { createThirdwebClient, getContract } from "thirdweb";
	 * import { sepolia } from "thirdweb/chains";
	 *
	 * const client = createThirdwebClient({ clientId: "..." });
	 * const contract = getContract({
	 *  client,
	 *  chain: sepolia,
	 *  address: "0x123...",
	 *  // optional ABI
	 *  abi: [...],
	 * });
	 * ```
	 * @contract
	 */
	function getContract(options) {
	    return options;
	}

	var prepareTransaction$1 = {};

	Object.defineProperty(prepareTransaction$1, "__esModule", { value: true });
	prepareTransaction$1.prepareTransaction = prepareTransaction;
	/**
	 * Prepares a transaction with the given options.
	 * @param options - The options for preparing the transaction.
	 * @param info - Additional information about the ABI function.
	 * @returns The prepared transaction.
	 * @transaction
	 * @example
	 * ```ts
	 * import { prepareTransaction, toWei } from "thirdweb";
	 * import { ethereum } from "thirdweb/chains";
	 * const transaction = prepareTransaction({
	 *  to: "0x1234567890123456789012345678901234567890",
	 *  chain: ethereum,
	 *  client: thirdwebClient,
	 *  value: toWei("1.0"),
	 *  gasPrice: 30n
	 * });
	 * ```
	 */
	function prepareTransaction(options, info) {
	    if (info) {
	        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
	        options.__preparedMethod = info.preparedMethod;
	        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
	        options.__contract = info.contract;
	    }
	    return options;
	}

	var types = {};

	var typeGuards = {};

	Object.defineProperty(typeGuards, "__esModule", { value: true });
	typeGuards.isObjectWithKeys = isObjectWithKeys;
	/**
	 * Checks if a value is an object.
	 * @param value - The value to check.
	 * @returns True if the value is an object, false otherwise.
	 * @internal
	 */
	function isObject(value) {
	    return typeof value === "object" && value !== null;
	}
	/**
	 * Checks if a value is an object with specified keys.
	 * @param value - The value to check.
	 * @param keys - The keys to check for in the object. Defaults to an empty array.
	 * @returns True if the value is an object with the specified keys, false otherwise.
	 * @internal
	 */
	function isObjectWithKeys(value, keys = []) {
	    return isObject(value) && keys.every((key) => key in value);
	}

	Object.defineProperty(types, "__esModule", { value: true });
	types.isBaseTransactionOptions = isBaseTransactionOptions;
	const type_guards_js_1$1 = typeGuards;
	// type-guard
	/**
	 * Checks if the given value is of type TxOpts.
	 * @param value - The value to check.
	 * @returns True if the value is of type TxOpts, false otherwise.
	 * @internal
	 */
	function isBaseTransactionOptions(value) {
	    return ((0, type_guards_js_1$1.isObjectWithKeys)(value, ["__contract"]) &&
	        (0, type_guards_js_1$1.isObjectWithKeys)(value.__contract, ["address", "chain"]) &&
	        typeof value.__contract.address === "string");
	}

	var prepareContractCall$1 = {};

	var encodeAbiParameters$1 = {};

	var address = {};

	var keccak256$1 = {};

	Object.defineProperty(keccak256$1, "__esModule", { value: true });
	keccak256$1.keccak256 = keccak256;
	const sha3_1 = sha3;
	const hex_js_1$5 = hex;
	/**
	 * Calculates the Keccak-256 hash of the given value.
	 * @param value - The value to hash, either as a hexadecimal string or a Uint8Array.
	 * @param to - The desired output format of the hash (optional). Defaults to 'hex'.
	 * @returns The Keccak-256 hash of the value in the specified format.
	 * @example
	 * ```ts
	 * import { keccak256 } from "thirdweb/utils";
	 * const hash = keccak256("0x1234");
	 * ```
	 * @utils
	 */
	function keccak256(value, to) {
	    const bytes = (0, sha3_1.keccak_256)((0, hex_js_1$5.isHex)(value, { strict: false }) ? (0, hex_js_1$5.hexToUint8Array)(value) : value);
	    if (to === "bytes") {
	        return bytes;
	    }
	    // default fall through to hex
	    return (0, hex_js_1$5.uint8ArrayToHex)(bytes);
	}

	Object.defineProperty(address, "__esModule", { value: true });
	address.isAddress = isAddress;
	address.checksumAddress = checksumAddress;
	address.getAddress = getAddress;
	address.shortenAddress = shortenAddress;
	address.shortenHex = shortenHex;
	const lru_js_1$1 = lru$1;
	const to_bytes_js_1$2 = toBytes$2;
	const keccak256_js_1$1 = keccak256$1;
	const ADRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
	const IS_ADDRESS_CACHE = new lru_js_1$1.LruMap(4096);
	/**
	 * Checks if a given string is a valid address.
	 * @param address The address to check.
	 * @returns True if the address is valid, false otherwise.
	 * @example
	 * ```ts
	 * import { isAddress } from 'thirdweb/utils';
	 *
	 * isAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');
	 * //=> true
	 * ```
	 * @utils
	 */
	function isAddress(address) {
	    if (IS_ADDRESS_CACHE.has(address)) {
	        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
	        return IS_ADDRESS_CACHE.get(address);
	    }
	    const result = (() => {
	        if (!ADRESS_REGEX.test(address)) {
	            return false;
	        }
	        if (address.toLowerCase() === address) {
	            return true;
	        }
	        return checksumAddress(address) === address;
	    })();
	    IS_ADDRESS_CACHE.set(address, result);
	    return result;
	}
	/**
	 * Calculates the checksum address for the given address.
	 * @param address - The address to calculate the checksum for.
	 * @returns The checksum address.
	 * @example
	 * ```ts
	 * import { checksumAddress } from 'thirdweb/utils';
	 *
	 * checksumAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');
	 * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'
	 * ```
	 * @utils
	 */
	function checksumAddress(address) {
	    const hexAddress = address.substring(2).toLowerCase();
	    const hash = (0, keccak256_js_1$1.keccak256)((0, to_bytes_js_1$2.stringToBytes)(hexAddress), "bytes");
	    const address_ = hexAddress.split("");
	    for (let i = 0; i < 40; i += 2) {
	        // biome-ignore lint/style/noNonNullAssertion: <explanation>
	        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
	            // biome-ignore lint/style/noNonNullAssertion: <explanation>
	            address_[i] = address_[i].toUpperCase();
	        }
	        // biome-ignore lint/style/noNonNullAssertion: <explanation>
	        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
	            // biome-ignore lint/style/noNonNullAssertion: <explanation>
	            address_[i + 1] = address_[i + 1].toUpperCase();
	        }
	    }
	    return `0x${address_.join("")}`;
	}
	/**
	 * Retrieves the address after performing validation and checksumming.
	 * @param address - The address to be validated and checksummed.
	 * @returns The validated and checksummed address.
	 * @throws Error if the address is invalid.
	 * @example
	 * ```ts
	 * import { getAddress } from 'thirdweb/utils';
	 *
	 * getAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');
	 * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'
	 * ```
	 * @utils
	 */
	function getAddress(address) {
	    if (!isAddress(address)) {
	        throw new Error(`Invalid address: ${address}`);
	    }
	    return checksumAddress(address);
	}
	/**
	 * Checksums and formats an address if valid. Note this function does not check if the provided address is an ENS.
	 * @param address - The address to shorten.
	 * @param length - The number of characters to keep from the start and end of the address.
	 * @returns The shortened address.
	 * @example
	 * ```ts
	 * import { shortenAddress } from 'thirdweb/utils';
	 *
	 * shortenAddress('0xa0cf798816d4b9b9866b5330eea46a18382f251e');
	 * //=> '0xA0Cf...251e'
	 * ```
	 * @utils
	 */
	function shortenAddress(address, length = 4) {
	    const _address = getAddress(address);
	    return shortenHex(_address, length);
	}
	/**
	 * Shortens a hexadecimal string without performing any validation or checksumming.
	 * @param hex - The hexadecimal string to shorten.
	 * @param length - The number of characters to keep from the start and end of the string.
	 * @returns The shortened hexadecimal string.
	 * @example
	 * ```ts
	 * import { shortenHex } from 'thirdweb/utils';
	 *
	 * shortenHex('0xa0cf798816d4b9b9866b5330eea46a18382f251e');
	 * //=> '0xa0cf...251e'
	 * ```
	 * @utils
	 */
	function shortenHex(hex, length = 4) {
	    return `${hex.slice(0, length + 2)}...${hex.slice(-length)}`;
	}

	Object.defineProperty(encodeAbiParameters$1, "__esModule", { value: true });
	encodeAbiParameters$1.encodeAbiParameters = encodeAbiParameters;
	encodeAbiParameters$1.prepareParam = prepareParam;
	encodeAbiParameters$1.encodeAddress = encodeAddress;
	const utils_1$1 = utils$2;
	const address_js_1 = address;
	const byte_size_js_1 = byteSize$1;
	const hex_js_1$4 = hex;
	/**
	 * Encodes the given ABI parameters and values into a hexadecimal string.
	 * @template TParams - The type of the ABI parameters.
	 * @param params - The ABI parameters.
	 * @param values - The corresponding values for the ABI parameters.
	 * @returns - The encoded ABI parameters as a hexadecimal string.
	 * @throws {Error} - If the number of parameters and values do not match.
	 * @example
	 * ```ts
	 * import { encodeAbiParameters } from "viem";
	 *
	 * const params = [
	 *  { name: "param1", type: "uint256" },
	 *  { name: "param2", type: "string" },
	 * ];
	 * const values = [123, "hello"];
	 *
	 * const data = encodeAbiParameters(params, values);
	 * console.log(data);
	 * ```
	 * @utils
	 */
	function encodeAbiParameters(params, values) {
	    if (params.length !== values.length) {
	        throw new Error("The number of parameters and values must match.");
	    }
	    // Prepare the parameters to determine dynamic types to encode.
	    const preparedParams = prepareParams({
	        params: params,
	        values,
	    });
	    const data = encodeParams(preparedParams);
	    if (data.length === 0) {
	        return "0x";
	    }
	    return data;
	}
	function prepareParams({ params, values, }) {
	    const preparedParams = [];
	    for (let i = 0; i < params.length; i++) {
	        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
	        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
	    }
	    return preparedParams;
	}
	/**
	 * @internal Export for unit test
	 */
	function prepareParam({ param, value, }) {
	    const arrayComponents = getArrayComponents(param.type);
	    if (arrayComponents) {
	        const [length, type] = arrayComponents;
	        return encodeArray(value, { length, param: { ...param, type } });
	    }
	    if (param.type === "tuple") {
	        return encodeTuple(value, {
	            param: param,
	        });
	    }
	    if (param.type === "address") {
	        return encodeAddress(value);
	    }
	    if (param.type === "bool") {
	        return encodeBool(value);
	    }
	    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
	        const signed = param.type.startsWith("int");
	        return encodeNumber(value, { signed });
	    }
	    if (param.type.startsWith("bytes")) {
	        return encodeBytes(value, { param });
	    }
	    if (param.type === "string") {
	        return encodeString(value);
	    }
	    throw new Error(`Unsupported parameter type: ${param.type}`);
	}
	function encodeParams(preparedParams) {
	    // 1. Compute the size of the static part of the parameters.
	    let staticSize = 0;
	    for (let i = 0; i < preparedParams.length; i++) {
	        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
	        const { dynamic, encoded } = preparedParams[i];
	        if (dynamic) {
	            staticSize += 32;
	        }
	        else {
	            staticSize += (0, byte_size_js_1.byteSize)(encoded);
	        }
	    }
	    // 2. Split the parameters into static and dynamic parts.
	    const staticParams = [];
	    const dynamicParams = [];
	    let dynamicSize = 0;
	    for (let i = 0; i < preparedParams.length; i++) {
	        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
	        const { dynamic, encoded } = preparedParams[i];
	        if (dynamic) {
	            staticParams.push((0, hex_js_1$4.numberToHex)(staticSize + dynamicSize, { size: 32 }));
	            dynamicParams.push(encoded);
	            dynamicSize += (0, byte_size_js_1.byteSize)(encoded);
	        }
	        else {
	            staticParams.push(encoded);
	        }
	    }
	    // 3. Concatenate static and dynamic parts.
	    return (0, utils_1$1.concat)([...staticParams, ...dynamicParams]);
	}
	/////////////////////////////////////////////////////////////////
	/**
	 * @internal Export for unit test
	 */
	function encodeAddress(value) {
	    // We allow empty strings for deployment transactions where there is no to address
	    if (value !== "" && value !== undefined && !(0, address_js_1.isAddress)(value)) {
	        throw new Error("Invalid address.");
	    }
	    return { dynamic: false, encoded: (0, hex_js_1$4.padHex)(value.toLowerCase()) };
	}
	function encodeArray(value, { length, param, }) {
	    const dynamic = length === null;
	    if (!Array.isArray(value)) {
	        throw new Error("Invalid array value.");
	    }
	    if (!dynamic && value.length !== length) {
	        throw new Error("Invalid array length.");
	    }
	    let dynamicChild = false;
	    const preparedParams = [];
	    for (let i = 0; i < value.length; i++) {
	        const preparedParam = prepareParam({ param, value: value[i] });
	        if (preparedParam.dynamic) {
	            dynamicChild = true;
	        }
	        preparedParams.push(preparedParam);
	    }
	    if (dynamic || dynamicChild) {
	        const data = encodeParams(preparedParams);
	        if (dynamic) {
	            const length_ = (0, hex_js_1$4.numberToHex)(preparedParams.length, { size: 32 });
	            return {
	                dynamic: true,
	                encoded: preparedParams.length > 0 ? (0, utils_1$1.concat)([length_, data]) : length_,
	            };
	        }
	        if (dynamicChild) {
	            return { dynamic: true, encoded: data };
	        }
	    }
	    return {
	        dynamic: false,
	        encoded: (0, utils_1$1.concat)(preparedParams.map(({ encoded }) => encoded)),
	    };
	}
	function encodeBytes(value, { param }) {
	    const [, paramSize] = param.type.split("bytes");
	    const bytesSize = (0, byte_size_js_1.byteSize)(value);
	    if (!paramSize) {
	        let value_ = value;
	        // If the size is not divisible by 32 bytes, pad the end
	        // with empty bytes to the ceiling 32 bytes.
	        if (bytesSize % 32 !== 0) {
	            value_ = (0, hex_js_1$4.padHex)(value_, {
	                dir: "right",
	                size: Math.ceil((value.length - 2) / 2 / 32) * 32,
	            });
	        }
	        return {
	            dynamic: true,
	            encoded: (0, utils_1$1.concat)([(0, hex_js_1$4.padHex)((0, hex_js_1$4.numberToHex)(bytesSize, { size: 32 })), value_]),
	        };
	    }
	    if (bytesSize !== Number.parseInt(paramSize)) {
	        throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);
	    }
	    return { dynamic: false, encoded: (0, hex_js_1$4.padHex)(value, { dir: "right" }) };
	}
	function encodeBool(value) {
	    return { dynamic: false, encoded: (0, hex_js_1$4.padHex)((0, hex_js_1$4.boolToHex)(value)) };
	}
	function encodeNumber(value, { signed }) {
	    return {
	        dynamic: false,
	        encoded: (0, hex_js_1$4.numberToHex)(value, {
	            size: 32,
	            signed,
	        }),
	    };
	}
	function encodeString(value) {
	    const hexValue = (0, hex_js_1$4.stringToHex)(value);
	    const partsLength = Math.ceil((0, byte_size_js_1.byteSize)(hexValue) / 32);
	    const parts = [];
	    for (let i = 0; i < partsLength; i++) {
	        parts.push((0, hex_js_1$4.padHex)((0, utils_1$1.slice)(hexValue, i * 32, (i + 1) * 32), {
	            dir: "right",
	        }));
	    }
	    return {
	        dynamic: true,
	        encoded: (0, utils_1$1.concat)([
	            (0, hex_js_1$4.padHex)((0, hex_js_1$4.numberToHex)((0, byte_size_js_1.byteSize)(hexValue), { size: 32 })),
	            ...parts,
	        ]),
	    };
	}
	function encodeTuple(value, { param }) {
	    let dynamic = false;
	    const preparedParams = [];
	    for (let i = 0; i < param.components.length; i++) {
	        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
	        const param_ = param.components[i];
	        const index = Array.isArray(value) ? i : param_.name;
	        const preparedParam = prepareParam({
	            param: param_,
	            // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
	            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	            value: value[index],
	        });
	        preparedParams.push(preparedParam);
	        if (preparedParam.dynamic) {
	            dynamic = true;
	        }
	    }
	    return {
	        dynamic,
	        encoded: dynamic
	            ? encodeParams(preparedParams)
	            : (0, utils_1$1.concat)(preparedParams.map(({ encoded }) => encoded)),
	    };
	}
	function getArrayComponents(type) {
	    const matches = type.match(/^(.*)\[(\d+)?\]$/);
	    return matches
	        ? // Return `null` if the array is dynamic.
	            // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
	            [matches[2] ? Number(matches[2]) : null, matches[1]]
	        : undefined;
	}

	var prepareMethod$1 = {};

	Object.defineProperty(prepareMethod$1, "__esModule", { value: true });
	prepareMethod$1.prepareMethod = prepareMethod;
	const abitype_1$4 = exports$1;
	const viem_1$a = _cjs;
	const lru_js_1 = lru$1;
	const json_js_1$1 = json;
	const prepareMethodCache = new lru_js_1.LruMap(4096);
	/**
	 * Prepares a method for usage by converting it into a prepared method object.
	 * @param method The method to prepare.
	 * @returns The prepared method object.
	 * @example
	 * ```ts
	 * import { prepareMethod } from "thirdweb/utils";
	 * const method = "function transfer(address to, uint256 value)";
	 * const preparedMethod = prepareMethod(method);
	 * ```
	 * @contract
	 */
	function prepareMethod(method) {
	    const key = typeof method === "string" ? method : (0, json_js_1$1.stringify)(method);
	    if (prepareMethodCache.has(key)) {
	        return prepareMethodCache.get(key);
	    }
	    const abiFn = typeof method === "string"
	        ? // @ts-expect-error - we're sure it's a string...
	            (0, abitype_1$4.parseAbiItem)(method)
	        : method;
	    // encode the method signature
	    const sig = (0, viem_1$a.toFunctionSelector)(abiFn);
	    const ret = [sig, abiFn.inputs, abiFn.outputs];
	    prepareMethodCache.set(key, ret);
	    return ret;
	}

	var resolvePromisedValue$1 = {};

	Object.defineProperty(resolvePromisedValue$1, "__esModule", { value: true });
	resolvePromisedValue$1.resolvePromisedValue = resolvePromisedValue;
	/**
	 * Resolves a possibly asynchronous value.
	 * If the value is a function that returns a promise, it will be awaited and the resolved value will be returned.
	 * Otherwise, the value itself will be returned.
	 *
	 * @param value - The value to resolve.
	 * @returns A promise that resolves to the resolved value.
	 * @internal
	 */
	async function resolvePromisedValue(value) {
	    return typeof value === "function" ? await value() : value;
	}

	var utils$1 = {};

	Object.defineProperty(utils$1, "__esModule", { value: true });
	utils$1.isAbiFunction = isAbiFunction;
	/**
	 * @internal
	 */
	function isAbiFunction(item) {
	    return !!(item &&
	        typeof item === "object" &&
	        "type" in item &&
	        item.type === "function");
	}

	Object.defineProperty(prepareContractCall$1, "__esModule", { value: true });
	prepareContractCall$1.prepareContractCall = prepareContractCall;
	const abitype_1$3 = exports$1;
	const encodeAbiParameters_js_1$2 = encodeAbiParameters$1;
	const prepare_method_js_1$1 = prepareMethod$1;
	const resolve_promised_value_js_1$6 = resolvePromisedValue$1;
	const prepare_transaction_js_1 = prepareTransaction$1;
	const utils_js_1$b = utils$1;
	/**
	 * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.
	 * @param options - The options for preparing the contract call.
	 * @returns A promise that resolves to the prepared transaction.
	 * @transaction
	 * @example
	 *
	 * ### Usage with a human-readable method signature:
	 *
	 * ```ts
	 * import { prepareContractCall } from "thirdweb";
	 *
	 * const transaction = prepareContractCall({
	 *  contract,
	 *  method: "function transfer(address to, uint256 value)",
	 *  params: [to, value],
	 * });
	 * ```
	 *
	 * ### Usage with explicit gas price and/or value:
	 *
	 * ```ts
	 * import { prepareContractCall } from "thirdweb";
	 * import { toWei } from "thirdweb/utils";
	 *
	 * const transaction = prepareContractCall({
	 *  contract,
	 *  method: "function transfer(address to, uint256 value)",
	 *  params: [to, value],
	 *  maxFeePerGas: 30n,
	 *  maxPriorityFeePerGas: 1n,
	 *  value: toWei("0.01"),
	 * });
	 * ```
	 *
	 * ### Usage with a JSON ABI function object:
	 *
	 * ```ts
	 * import { prepareContractCall } from "thirdweb";
	 *
	 * const transaction = prepareContractCall({
	 *  contract,
	 *  method: {
	 *    name: "transfer",
	 *    type: "function",
	 *    inputs: [
	 *      { name: "to", type: "address" },
	 *      { name: "value", type: "uint256" },
	 *    ],
	 *    outputs: [],
	 *    stateMutability: "payable"
	 *   },
	 *  params: [to, value],
	 * });
	 * ```
	 *
	 * ### Usage with the ABI defined on the contract:
	 *
	 * ```ts
	 * import { getContract, prepareContractCall } from "thirdweb";
	 * const contract = getContract({
	 *  ..., // chain, address, client
	 *  abi: [...] // ABI with a "transfer" method
	 * });
	 * const transaction = prepareContractCall({
	 *  contract,
	 *  method: "transfer", // <- this gets inferred from the contract
	 *  params: [to, value],
	 * });
	 * ```
	 *
	 * ### Passing extra call data to the transaction
	 * ```ts
	 * import { getContract, prepareContractCall } from "thirdweb";
	 * const contract = getContract({
	 *   ..., // chain, address, client
	 * });
	 *
	 * const transaction = prepareContractCall({
	 *   contract,
	 *   method: "function transfer(address to, uint256 value)",
	 *   params: [...],
	 *   // The extra call data MUST be encoded to hex before passing
	 *   extraCallData: "0x......."
	 * });
	 * ```
	 */
	function prepareContractCall(options) {
	    const { contract, method, params, ...rest } = options;
	    const preparedMethodPromise = () => (async () => {
	        if (Array.isArray(method)) {
	            return method;
	        }
	        if ((0, utils_js_1$b.isAbiFunction)(method)) {
	            return (0, prepare_method_js_1$1.prepareMethod)(method);
	        }
	        if (typeof method === "function") {
	            return (0, prepare_method_js_1$1.prepareMethod)(
	            // @ts-expect-error - method *is* function in this case
	            (await method(contract)));
	        }
	        // if the method starts with the string `function ` we always will want to try to parse it
	        if (typeof method === "string" && method.startsWith("function ")) {
	            // @ts-expect-error - method *is* string in this case
	            const abiItem = (0, abitype_1$3.parseAbiItem)(method);
	            if (abiItem.type === "function") {
	                return (0, prepare_method_js_1$1.prepareMethod)(abiItem);
	            }
	            throw new Error(`"method" passed is not of type "function"`);
	        }
	        // check if we have a "abi" on the contract
	        if (contract.abi && contract.abi?.length > 0) {
	            // extract the abiFunction from it
	            const abiFunction = contract.abi?.find((item) => item.type === "function" && item.name === method);
	            // if we were able to find it -> return it
	            if (abiFunction) {
	                return (0, prepare_method_js_1$1.prepareMethod)(abiFunction);
	            }
	        }
	        throw new Error(`Could not resolve method "${method}".`);
	    })();
	    return (0, prepare_transaction_js_1.prepareTransaction)({
	        ...rest,
	        // these always inferred from the contract
	        to: contract.address,
	        chain: contract.chain,
	        client: contract.client,
	        data: async () => {
	            let preparedM;
	            if (Array.isArray(method)) {
	                preparedM = method;
	            }
	            else {
	                preparedM = await preparedMethodPromise();
	            }
	            if (preparedM[1].length === 0) {
	                // just return the fn sig directly -> no params
	                return preparedM[0];
	            }
	            // we do a "manual" concat here to avoid the overhead of the "concatHex" function
	            // we can do this because we know the specific formats of the values
	            return (preparedM[0] +
	                (0, encodeAbiParameters_js_1$2.encodeAbiParameters)(preparedM[1], 
	                // @ts-expect-error - TODO: fix this type issue
	                await (0, resolve_promised_value_js_1$6.resolvePromisedValue)(params ?? [])).slice(2));
	        },
	    }, {
	        preparedMethod: preparedMethodPromise,
	        contract: contract,
	    });
	}

	var readContract$1 = {};

	Object.defineProperty(readContract$1, "__esModule", { value: true });
	readContract$1.readContract = readContract;
	const abitype_1$2 = exports$1;
	const viem_1$9 = _cjs;
	const utils_js_1$a = utils$1;
	const eth_call_js_1$2 = eth_call$1;
	const rpc_js_1$7 = rpc$1;
	const encodeAbiParameters_js_1$1 = encodeAbiParameters$1;
	const prepare_method_js_1 = prepareMethod$1;
	/**
	 * ### Reads state from a deployed smart contract.
	 *
	 * You can use raw read calls or read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) to read from a contract.
	 *
	 * @param options - The transaction options.
	 * @returns A promise that resolves with the result of the read call.
	 * @transaction
	 * @example
	 *
	 * ### Using a contract read extension
	 *
	 * ```ts
	 * import { getContract } from "thirdweb";
	 * import { sepolia } from "thirdweb/chains";
	 * import { useReadContract } from "thirdweb/react";
	 * import { getOwnedNFTs } form "thirdweb/extensions/erc721";
	 *
	 * const contract = getContract({
	 *   client,
	 *   address: "0x...",
	 *   chain: sepolia,
	 * });
	 *
	 * const { data, isLoading } = useReadContract(getOwnedNFTs, { contract, owner: address });
	 * ```
	 *
	 * ### Using a raw contract call
	 *
	 * ```ts
	 * import { getContract } from "thirdweb";
	 * import { sepolia } from "thirdweb/chains";
	 * import { useReadContract } from "thirdweb/react";
	 *
	 * const contract = getContract({
	 *   client,
	 *   address: "0x...",
	 *   chain: sepolia,
	 * });
	 *
	 * const { data, isLoading } = useReadContract({
	 *   contract,
	 *   method: "function tokenURI(uint256 tokenId) returns (string)"}),
	 *   params: [1n],
	 * });
	 * ```
	 *
	 * ### Using `resolveMethod`
	 * ```ts
	 * import { getContract, resolveMethod } from "thirdweb";
	 * import { sepolia } from "thirdweb/chains";
	 * import { useReadContract } from "thirdweb/react";
	 *
	 * const contract = getContract({
	 *   client,
	 *   address: "0x...",
	 *   chain: sepolia,
	 * });
	 *
	 * const { data, isLoading } = useReadContract({
	 *   contract,
	 *   method: resolveMethod("tokenURI"),
	 *   params: [1n],
	 * });
	 * ```
	 */
	async function readContract(options) {
	    const { contract, method, params } = options;
	    const resolvePreparedMethod = async () => {
	        if (Array.isArray(method)) {
	            return method;
	        }
	        if ((0, utils_js_1$a.isAbiFunction)(method)) {
	            return (0, prepare_method_js_1.prepareMethod)(method);
	        }
	        if (typeof method === "function") {
	            return (0, prepare_method_js_1.prepareMethod)(
	            // @ts-expect-error - we're sure it's a function
	            (await method(contract)));
	        }
	        // if the method starts with the string `function ` we always will want to try to parse it
	        if (typeof method === "string" && method.startsWith("function ")) {
	            // @ts-expect-error - method *is* string in this case
	            const abiItem = (0, abitype_1$2.parseAbiItem)(method);
	            if (abiItem.type === "function") {
	                return (0, prepare_method_js_1.prepareMethod)(abiItem);
	            }
	            throw new Error(`"method" passed is not of type "function"`);
	        }
	        // check if we have a "abi" on the contract
	        if (contract.abi && contract.abi?.length > 0) {
	            // extract the abiFunction from it
	            const abiFunction = contract.abi?.find((item) => item.type === "function" && item.name === method);
	            // if we were able to find it -> return it
	            if (abiFunction) {
	                return (0, prepare_method_js_1.prepareMethod)(abiFunction);
	            }
	        }
	        throw new Error(`Could not resolve method "${method}".`);
	    };
	    // resolve in parallel
	    const [resolvedPreparedMethod, resolvedParams] = await Promise.all([
	        resolvePreparedMethod(),
	        typeof params === "function" ? params() : params,
	    ]);
	    let encodedData;
	    // if we have no inputs, we know it's just the signature
	    if (resolvedPreparedMethod[1].length === 0) {
	        encodedData = resolvedPreparedMethod[0];
	    }
	    else {
	        // we do a "manual" concat here to avoid the overhead of the "concatHex" function
	        // we can do this because we know the specific formats of the values
	        encodedData = (resolvedPreparedMethod[0] +
	            (0, encodeAbiParameters_js_1$1.encodeAbiParameters)(resolvedPreparedMethod[1], 
	            // @ts-expect-error - TODO: fix this type issue
	            resolvedParams).slice(2));
	    }
	    const rpcRequest = (0, rpc_js_1$7.getRpcClient)({
	        chain: contract.chain,
	        client: contract.client,
	    });
	    const result = await (0, eth_call_js_1$2.eth_call)(rpcRequest, {
	        data: encodedData,
	        to: contract.address,
	        from: options.from,
	    });
	    // use the prepared method to decode the result
	    const decoded = (0, viem_1$9.decodeAbiParameters)(resolvedPreparedMethod[2], result);
	    if (Array.isArray(decoded) && decoded.length === 1) {
	        return decoded[0];
	    }
	    return decoded;
	}

	var resolveMethod$1 = {};

	var resolveAbi = {};

	var getInstalledModules = {};

	var detectExtension = {};

	Object.defineProperty(detectExtension, "__esModule", { value: true });
	detectExtension.detectMethod = detectMethod;
	const viem_1$8 = _cjs;
	/**
	 * Detects if the specified method is present in the contract bytecode.
	 * @param options - The options for detecting the extension.
	 * @returns A promise that resolves to a boolean indicating if the extension is detected.
	 * @example
	 * ```ts
	 * import { detectMethod } from "thirdweb/utils/extensions/detect.js";
	 * const hasDecimals = await detectMethod({
	 *  contract,
	 *  method: "function decimals() view returns (uint8)",
	 * });
	 * ```
	 * @contract
	 */
	function detectMethod(options) {
	    const fnSelector = Array.isArray(options.method)
	        ? options.method[0]
	        : (0, viem_1$8.toFunctionSelector)(options.method);
	    return options.availableSelectors.includes(fnSelector);
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FN_SELECTOR = void 0;
		exports.isGetInstalledModulesSupported = isGetInstalledModulesSupported;
		exports.decodeGetInstalledModulesResult = decodeGetInstalledModulesResult;
		exports.getInstalledModules = getInstalledModules;
		const read_contract_js_1 = readContract$1;
		const viem_1 = _cjs;
		const detectExtension_js_1 = detectExtension;
		exports.FN_SELECTOR = "0x3e429396";
		const FN_INPUTS = [];
		const FN_OUTPUTS = [
		    {
		        name: "_installedModules",
		        type: "tuple[]",
		        internalType: "struct IModularCore.InstalledModule[]",
		        components: [
		            {
		                name: "implementation",
		                type: "address",
		                internalType: "address",
		            },
		            {
		                name: "config",
		                type: "tuple",
		                internalType: "struct IModuleConfig.ModuleConfig",
		                components: [
		                    {
		                        name: "registerInstallationCallback",
		                        type: "bool",
		                        internalType: "bool",
		                    },
		                    {
		                        name: "requiredInterfaces",
		                        type: "bytes4[]",
		                        internalType: "bytes4[]",
		                    },
		                    {
		                        name: "supportedInterfaces",
		                        type: "bytes4[]",
		                        internalType: "bytes4[]",
		                    },
		                    {
		                        name: "callbackFunctions",
		                        type: "tuple[]",
		                        internalType: "struct IModuleConfig.CallbackFunction[]",
		                        components: [
		                            {
		                                name: "selector",
		                                type: "bytes4",
		                                internalType: "bytes4",
		                            },
		                        ],
		                    },
		                    {
		                        name: "fallbackFunctions",
		                        type: "tuple[]",
		                        internalType: "struct IModuleConfig.FallbackFunction[]",
		                        components: [
		                            {
		                                name: "selector",
		                                type: "bytes4",
		                                internalType: "bytes4",
		                            },
		                            {
		                                name: "permissionBits",
		                                type: "uint256",
		                                internalType: "uint256",
		                            },
		                        ],
		                    },
		                ],
		            },
		        ],
		    },
		];
		/**
		 * Checks if the `getInstalledModules` method is supported by the given contract.
		 * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using "whatsabi" or if you have the ABI of the contract available you can use it to generate the selectors.
		 * @returns A boolean indicating if the `getInstalledModules` method is supported.
		 * @extension MODULAR
		 * @example
		 * ```ts
		 * import { isGetInstalledModulesSupported } from "thirdweb/extensions/modular";
		 *
		 * const supported = isGetInstalledModulesSupported(["0x..."]);
		 * ```
		 */
		function isGetInstalledModulesSupported(availableSelectors) {
		    return (0, detectExtension_js_1.detectMethod)({
		        availableSelectors,
		        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
		    });
		}
		/**
		 * Decodes the result of the getInstalledModules function call.
		 * @param result - The hexadecimal result to decode.
		 * @returns The decoded result as per the FN_OUTPUTS definition.
		 * @extension MODULAR
		 * @example
		 * ```ts
		 * import { decodeGetInstalledModulesResult } from "thirdweb/extensions/modular";
		 * const result = decodeGetInstalledModulesResult("...");
		 * ```
		 */
		function decodeGetInstalledModulesResult(result) {
		    return (0, viem_1.decodeAbiParameters)(FN_OUTPUTS, result)[0];
		}
		/**
		 * Calls the "getInstalledModules" function on the contract.
		 * @param options - The options for the getInstalledModules function.
		 * @returns The parsed result of the function call.
		 * @extension MODULAR
		 * @example
		 * ```ts
		 * import { getInstalledModules } from "thirdweb/extensions/modular";
		 *
		 * const result = await getInstalledModules({
		 *  contract,
		 * });
		 *
		 * ```
		 */
		async function getInstalledModules(options) {
		    return (0, read_contract_js_1.readContract)({
		        contract: options.contract,
		        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
		        params: [],
		    });
		}
		
	} (getInstalledModules));

	var download$1 = {};

	var ipfs = {};

	var upload$1 = {};

	var helpers = {};

	var uint8Array = {};

	Object.defineProperty(uint8Array, "__esModule", { value: true });
	uint8Array.isUint8Array = isUint8Array;
	uint8Array.areUint8ArraysEqual = areUint8ArraysEqual;
	uint8Array.uint8ArrayToString = uint8ArrayToString;
	uint8Array.base64UrlToBase64 = base64UrlToBase64;
	uint8Array.base64ToUint8Array = base64ToUint8Array;
	uint8Array.base64ToString = base64ToString;
	uint8Array.uint8ArrayToBase64 = uint8ArrayToBase64;
	uint8Array.concatUint8Arrays = concatUint8Arrays;
	uint8Array.compareUint8Arrays = compareUint8Arrays;
	const text_decoder_js_1 = textDecoder$1;
	const uint8ArrayStringified = "[object Uint8Array]";
	/**
	 * Throw a `TypeError` if the given value is not an instance of `Uint8Array`.
	 * @example
	 * ```ts
	 * import {assertUint8Array} from 'uint8array-extras';
	 *
	 * try {
	 * assertUint8Array(new ArrayBuffer(10)); // Throws a TypeError
	 * } catch (error) {
	 * console.error(error.message);
	 * }
	 * ```
	 */
	function assertUint8Array(value) {
	    if (!isUint8Array(value)) {
	        throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
	    }
	}
	/**
	 * Check if the given value is an instance of `Uint8Array`.
	 *
	 * Replacement for [`Buffer.isBuffer()`](https://nodejs.org/api/buffer.html#static-method-bufferisbufferobj).
	 * @example
	 * ```ts
	 * import {isUint8Array} from 'uint8array-extras';
	 *
	 * console.log(isUint8Array(new Uint8Array()));
	 * //=> true
	 *
	 * console.log(isUint8Array(Buffer.from('x')));
	 * //=> true
	 *
	 * console.log(isUint8Array(new ArrayBuffer(10)));
	 * //=> false
	 * ```
	 */
	function isUint8Array(value) {
	    if (!value) {
	        return false;
	    }
	    if (value.constructor === Uint8Array) {
	        return true;
	    }
	    return Object.prototype.toString.call(value) === uint8ArrayStringified;
	}
	/**
	 * Check if two arrays are identical by verifying that they contain the same bytes in the same sequence.
	 *
	 * Replacement for [`Buffer#equals()`](https://nodejs.org/api/buffer.html#bufequalsotherbuffer).
	 * @example
	 * ```ts
	 * import {areUint8ArraysEqual} from 'uint8array-extras';
	 *
	 * const a = new Uint8Array([1, 2, 3]);
	 * const b = new Uint8Array([1, 2, 3]);
	 * const c = new Uint8Array([4, 5, 6]);
	 *
	 * console.log(areUint8ArraysEqual(a, b));
	 * //=> true
	 *
	 * console.log(areUint8ArraysEqual(a, c));
	 * //=> false
	 * ```
	 */
	function areUint8ArraysEqual(a, b) {
	    assertUint8Array(a);
	    assertUint8Array(b);
	    if (a === b) {
	        return true;
	    }
	    if (a.length !== b.length) {
	        return false;
	    }
	    for (let index = 0; index < a.length; index++) {
	        if (a[index] !== b[index]) {
	            return false;
	        }
	    }
	    return true;
	}
	/**
	 * Convert a `Uint8Array` (containing a UTF-8 string) to a string.
	 *
	 * Replacement for [`Buffer#toString()`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).
	 * @example
	 * ```ts
	 * import {uint8ArrayToString} from 'uint8array-extras';
	 *
	 * const byteArray = new Uint8Array([72, 101, 108, 108, 111]);
	 *
	 * console.log(uint8ArrayToString(byteArray));
	 * //=> 'Hello'
	 * ```
	 */
	function uint8ArrayToString(array) {
	    assertUint8Array(array);
	    return (0, text_decoder_js_1.cachedTextDecoder)().decode(array);
	}
	function assertString(value) {
	    if (typeof value !== "string") {
	        throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
	    }
	}
	function base64UrlToBase64(base64url) {
	    // Replace Base64URL characters with Base64 characters
	    let base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
	    // Add padding if necessary
	    const padding = base64.length % 4;
	    if (padding !== 0) {
	        base64 += "=".repeat(4 - padding);
	    }
	    return base64;
	}
	/**
	 * Convert a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a `Uint8Array`.
	 *
	 * Replacement for [`Buffer.from('SGVsbG8=', 'base64')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).
	 * @example
	 * ```ts
	 * import {base64ToUint8Array} from 'uint8array-extras';
	 *
	 * console.log(base64ToUint8Array('SGVsbG8='));
	 * //=> Uint8Array [72, 101, 108, 108, 111]
	 * ```
	 */
	function base64ToUint8Array(base64String) {
	    assertString(base64String);
	    return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), 
	    // biome-ignore lint/style/noNonNullAssertion: we know that the code points exist
	    (x) => x.codePointAt(0));
	}
	/**
	 * Decode a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a string.
	 *
	 * Replacement for `Buffer.from('SGVsbG8=', 'base64').toString()` and [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob).
	 * @example
	 * ```ts
	 * import {base64ToString} from 'uint8array-extras';
	 *
	 * console.log(base64ToString('SGVsbG8='));
	 * //=> 'Hello'
	 * ```
	 */
	function base64ToString(base64String) {
	    assertString(base64String);
	    return uint8ArrayToString(base64ToUint8Array(base64String));
	}
	function base64ToBase64Url(base64) {
	    return base64.replaceAll("+", "-").replaceAll("/", "_").replace(/=+$/, "");
	}
	// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/
	const MAX_BLOCK_SIZE = 65_535;
	function uint8ArrayToBase64(array, { urlSafe = false } = {}) {
	    assertUint8Array(array);
	    let base64;
	    if (array.length < MAX_BLOCK_SIZE) {
	        // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem
	        // @ts-expect-error - TS doesn't know about `String#fromCodePoint`
	        base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));
	    }
	    else {
	        base64 = "";
	        for (const value of array) {
	            base64 += String.fromCodePoint(value);
	        }
	        base64 = globalThis.btoa(base64);
	    }
	    return urlSafe ? base64ToBase64Url(base64) : base64;
	}
	function concatUint8Arrays(arrays, totalLength) {
	    if (arrays.length === 0) {
	        return new Uint8Array(0);
	    }
	    const calculatedTotalLength = totalLength ??
	        arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);
	    const returnValue = new Uint8Array(calculatedTotalLength);
	    let offset = 0;
	    for (const array of arrays) {
	        assertUint8Array(array);
	        returnValue.set(array, offset);
	        offset += array.length;
	    }
	    return returnValue;
	}
	function compareUint8Arrays(a, b) {
	    assertUint8Array(a);
	    assertUint8Array(b);
	    const length = Math.min(a.length, b.length);
	    for (let index = 0; index < length; index++) {
	        // biome-ignore lint/style/noNonNullAssertion: we check the length above so the index is always in bounds
	        const diff = a[index] - b[index];
	        if (diff !== 0) {
	            return Math.sign(diff);
	        }
	    }
	    // At this point, all the compared elements are equal.
	    // The shorter array should come first if the arrays are of different lengths.
	    return Math.sign(a.length - b.length);
	}

	Object.defineProperty(helpers, "__esModule", { value: true });
	helpers.isFileBufferOrStringEqual = isFileBufferOrStringEqual;
	helpers.buildFormData = buildFormData$1;
	helpers.isFileOrUint8Array = isFileOrUint8Array;
	helpers.extractObjectFiles = extractObjectFiles;
	helpers.replaceObjectFilesWithUris = replaceObjectFilesWithUris;
	helpers.replaceGatewayUrlWithScheme = replaceGatewayUrlWithScheme;
	helpers.replaceObjectGatewayUrlsWithSchemes = replaceObjectGatewayUrlsWithSchemes;
	const type_guards_js_1 = typeGuards;
	const uint8_array_js_1 = uint8Array;
	/**
	 * @internal
	 */
	function isFileInstance(data) {
	    return globalThis.File && data instanceof File;
	}
	/**
	 * @internal
	 */
	function isBufferOrStringWithName(data) {
	    if (!data) {
	        return false;
	    }
	    if (!(0, type_guards_js_1.isObjectWithKeys)(data, ["data", "name"])) {
	        return false;
	    }
	    return !!(typeof data.name === "string" &&
	        (typeof data.data === "string" || (0, uint8_array_js_1.isUint8Array)(data.data)));
	}
	function isFileBufferOrStringEqual(input1, input2) {
	    if (isFileInstance(input1) && isFileInstance(input2)) {
	        // if both are File types, compare the name, size, and last modified date (best guess that these are the same files)
	        if (input1.name === input2.name &&
	            input1.lastModified === input2.lastModified &&
	            input1.size === input2.size) {
	            return true;
	        }
	    }
	    else if ((0, uint8_array_js_1.isUint8Array)(input1) && (0, uint8_array_js_1.isUint8Array)(input2)) {
	        // buffer gives us an easy way to compare the contents!
	        return (0, uint8_array_js_1.areUint8ArraysEqual)(input1, input2);
	    }
	    else if (isBufferOrStringWithName(input1) &&
	        isBufferOrStringWithName(input2)) {
	        // first check the names
	        if (input1.name === input2.name) {
	            // if the data for both is a string, compare the strings
	            if (typeof input1.data === "string" && typeof input2.data === "string") {
	                return input1.data === input2.data;
	            }
	            if ((0, uint8_array_js_1.isUint8Array)(input1.data) && (0, uint8_array_js_1.isUint8Array)(input2.data)) {
	                // otherwise we know it's buffers, so compare the buffers
	                return (0, uint8_array_js_1.areUint8ArraysEqual)(input1.data, input2.data);
	            }
	        }
	    }
	    // otherwise if we have not found a match, return false
	    return false;
	}
	function buildFormData$1(form, files, options) {
	    const fileNameToFileMap = new Map();
	    const fileNames = [];
	    for (let i = 0; i < files.length; i++) {
	        // biome-ignore lint/style/noNonNullAssertion: we know that files[i] is not null or undefined because we are iterating over the array
	        const file = files[i];
	        let fileName = "";
	        let fileData = file;
	        if (isFileInstance(file)) {
	            if (options?.rewriteFileNames) {
	                let extensions = "";
	                if (file.name) {
	                    const extensionStartIndex = file.name.lastIndexOf(".");
	                    if (extensionStartIndex > -1) {
	                        extensions = file.name.substring(extensionStartIndex);
	                    }
	                }
	                fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;
	            }
	            else {
	                fileName = `${file.name}`;
	            }
	        }
	        else if (isBufferOrStringWithName(file)) {
	            fileData = file.data;
	            if (options?.rewriteFileNames) {
	                fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
	            }
	            else {
	                fileName = `${file.name}`;
	            }
	        }
	        else {
	            if (options?.rewriteFileNames) {
	                fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
	            }
	            else {
	                fileName = `${i}`;
	            }
	        }
	        // If we don't want to wrap with directory, adjust the filepath
	        const filepath = options?.uploadWithoutDirectory
	            ? "files"
	            : `files/${fileName}`;
	        if (fileNameToFileMap.has(fileName)) {
	            // if the file in the map is the same as the file we are already looking at then just skip and continue
	            if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {
	                // we add it to the filenames array so that we can return the correct number of urls,
	                fileNames.push(fileName);
	                // but then we skip because we don't need to upload it multiple times
	                continue;
	            }
	            // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to differnt files but with the same names)
	            throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);
	        }
	        // add it to the map so that we can check for duplicates
	        fileNameToFileMap.set(fileName, file);
	        // add it to the filenames array so that we can return the correct number of urls
	        fileNames.push(fileName);
	        form.append("file", new Blob([fileData]), filepath);
	    }
	    const metadata = {
	        name: "Storage SDK",
	        keyvalues: { ...options?.metadata },
	    };
	    form.append("pinataMetadata", JSON.stringify(metadata));
	    if (options?.uploadWithoutDirectory) {
	        form.append("pinataOptions", JSON.stringify({
	            wrapWithDirectory: false,
	        }));
	    }
	    return {
	        form,
	        // encode the file names on the way out (which is what the upload backend expects)
	        fileNames: fileNames.map((fName) => encodeURIComponent(fName)),
	    };
	}
	function isFileOrUint8Array(data) {
	    return (isFileInstance(data) || (0, uint8_array_js_1.isUint8Array)(data) || isBufferOrStringWithName(data));
	}
	/**
	 * @internal
	 */
	function extractObjectFiles(data, files = []) {
	    // If item is a FileOrBuffer add it to our list of files
	    if (isFileOrUint8Array(data)) {
	        files.push(data);
	        return files;
	    }
	    if (typeof data === "object") {
	        if (!data) {
	            return files;
	        }
	        if (Array.isArray(data)) {
	            for (const entry of data) {
	                extractObjectFiles(entry, files);
	            }
	        }
	        else {
	            Object.keys(data).map((key) => extractObjectFiles(data[key], files));
	        }
	    }
	    return files;
	}
	/**
	 * @internal
	 */
	function replaceObjectFilesWithUris(data, uris) {
	    if (isFileOrUint8Array(data)) {
	        if (uris.length) {
	            return uris.shift();
	        }
	        console.warn("Not enough URIs to replace all files in object.");
	    }
	    if (typeof data === "object") {
	        if (!data) {
	            return data;
	        }
	        if (Array.isArray(data)) {
	            return data.map((entry) => replaceObjectFilesWithUris(entry, uris));
	        }
	        return Object.fromEntries(Object.entries(data).map(([key, value]) => [
	            key,
	            replaceObjectFilesWithUris(value, uris),
	        ]));
	    }
	    return data;
	}
	/**
	 * @internal
	 */
	function replaceGatewayUrlWithScheme(url) {
	    if (url.includes("/ipfs/")) {
	        const hash = url.split("/ipfs/")[1];
	        return `ipfs://${hash}`;
	    }
	    return url;
	}
	/**
	 * @internal
	 */
	function replaceObjectGatewayUrlsWithSchemes(data) {
	    if (typeof data === "string") {
	        return replaceGatewayUrlWithScheme(data);
	    }
	    if (typeof data === "object") {
	        if (!data) {
	            return data;
	        }
	        if (isFileOrUint8Array(data)) {
	            return data;
	        }
	        if (Array.isArray(data)) {
	            return data.map((entry) => replaceObjectGatewayUrlsWithSchemes(entry));
	        }
	        return Object.fromEntries(Object.entries(data).map(([key, value]) => [
	            key,
	            replaceObjectGatewayUrlsWithSchemes(value),
	        ]));
	    }
	    return data;
	}

	var webNode = {};

	var hasRequiredWebNode;

	function requireWebNode () {
		if (hasRequiredWebNode) return webNode;
		hasRequiredWebNode = 1;
		Object.defineProperty(webNode, "__esModule", { value: true });
		webNode.uploadBatch = uploadBatch;
		const domains_js_1 = domains;
		const fetch_js_1 = fetch$1;
		async function uploadBatch(client, form, fileNames, options) {
		    const headers = {};
		    const res = await (0, fetch_js_1.getClientFetch)(client)(`https://${(0, domains_js_1.getThirdwebDomains)().storage}/ipfs/upload`, {
		        method: "POST",
		        headers: {
		            ...headers,
		            // ...form.getHeaders(),
		        },
		        body: form,
		    });
		    if (!res.ok) {
		        res.body?.cancel();
		        if (res.status === 401) {
		            throw new Error("Unauthorized - You don't have permission to use this service.");
		        }
		        throw new Error(`Failed to upload files to IPFS - ${res.status} - ${res.statusText}`);
		    }
		    const body = await res.json();
		    const cid = body.IpfsHash;
		    if (!cid) {
		        throw new Error("Failed to upload files to IPFS - Bad CID");
		    }
		    if (options?.uploadWithoutDirectory) {
		        return [`ipfs://${cid}`];
		    }
		    return fileNames.map((name) => `ipfs://${cid}/${name}`);
		}
		
		return webNode;
	}

	Object.defineProperty(upload$1, "__esModule", { value: true });
	upload$1.upload = upload;
	const detect_platform_js_1 = detectPlatform$1;
	const json_js_1 = json;
	const helpers_js_1$1 = helpers;
	/**
	 * Uploads files based on the provided options.
	 * @param options - The upload options.
	 * @returns A promise that resolves to the uploaded file URI or URIs (when passing multiple files).
	 * @throws An error if the upload fails.
	 * @example
	 * ```ts
	 * import { upload } from "thirdweb/storage";
	 * const uri = await upload({
	 *  client,
	 *  files: [
	 *    new File(["hello world"], "hello.txt"),
	 *  ],
	 * });
	 * ```
	 * @storage
	 */
	async function upload(options) {
	    // deal with the differnt file types
	    // if there are no files, return an empty array immediately
	    if (options.files.length === 0) {
	        return null;
	    }
	    // handle file arrays
	    const isFileArray = options.files
	        .map((item) => (0, helpers_js_1$1.isFileOrUint8Array)(item) || typeof item === "string")
	        .every((item) => !!item);
	    let uris;
	    if (isFileArray) {
	        // if we already have an array of files, we can just pass it through
	        uris = options.files;
	    }
	    else {
	        // otherwise we have to process them first
	        let cleaned = options.files;
	        // Replace any gateway URLs with their hashes
	        cleaned = (0, helpers_js_1$1.replaceObjectGatewayUrlsWithSchemes)(cleaned);
	        // Recurse through data and extract files to upload
	        const files = (0, helpers_js_1$1.extractObjectFiles)(cleaned);
	        if (files.length) {
	            // Upload all files that came from the object
	            const uris_ = await upload({ ...options, files });
	            // Recurse through data and replace files with hashes
	            cleaned = (0, helpers_js_1$1.replaceObjectFilesWithUris)(cleaned, 
	            // always pass an array even if the underlying upload returns a single uri
	            Array.isArray(uris_) ? uris_ : [uris_]);
	        }
	        uris = cleaned.map((item) => {
	            if (typeof item === "string") {
	                return item;
	            }
	            return (0, json_js_1.stringify)(item);
	        });
	    }
	    // end deal with the differnt file types
	    const form_ = new FormData();
	    const { fileNames, form } = (0, helpers_js_1$1.buildFormData)(form_, uris, options);
	    const platform = (0, detect_platform_js_1.detectPlatform)();
	    if (platform === "browser" || platform === "node") {
	        const { uploadBatch } = await Promise.resolve().then(() => requireWebNode());
	        const uris = await uploadBatch(options.client, form, fileNames, options);
	        // if we only passed a single file, return its URI directly
	        if (options.files.length === 1) {
	            return uris[0];
	        }
	        return uris;
	    }
	    throw new Error("Please, use the uploadMobile function in mobile environments.");
	}

	Object.defineProperty(ipfs, "__esModule", { value: true });
	ipfs.resolveScheme = resolveScheme;
	ipfs.findIPFSCidFromUri = findIPFSCidFromUri;
	ipfs.uploadOrExtractURIs = uploadOrExtractURIs;
	ipfs.getBaseUriFromBatch = getBaseUriFromBatch;
	const DEFAULT_GATEWAY$1 = "https://{clientId}.ipfscdn.io/ipfs/{cid}";
	/**
	 * Resolves the scheme of a given URI and returns the corresponding URL.
	 * If the URI starts with "ipfs://", it constructs a URL using the IPFS client ID and the IPFS gateway.
	 * If the URI starts with "http", it returns the URI as is.
	 * Otherwise, it throws an error indicating an invalid URI scheme.
	 * @param options - The options object containing the URI and the IPFS client.
	 * @returns The resolved URL.
	 * @throws Error if the URI scheme is invalid.
	 * @example
	 * ```ts
	 * import { resolveScheme } from "thirdweb/storage";
	 * const url = resolveScheme({
	 *  client,
	 *  uri: "ipfs://Qm...",
	 * });
	 * ```
	 * @storage
	 */
	function resolveScheme(options) {
	    if (options.uri.startsWith("ipfs://")) {
	        const gateway = options.client.config?.storage?.gatewayUrl ?? DEFAULT_GATEWAY$1;
	        const clientId = options.client.clientId;
	        const cid = findIPFSCidFromUri(options.uri);
	        let bundleId = undefined;
	        if (typeof globalThis !== "undefined" && "Application" in globalThis) {
	            // shims use wallet connect RN module which injects Application info in globalThis
	            // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
	            bundleId = globalThis.Application.applicationId;
	        }
	        // purposefully using SPLIT here and not replace for CID to avoid cases where users don't know the schema
	        // also only splitting on `/ipfs` to avoid cases where people pass non `/` terminated gateway urls
	        return `${gateway.replace("{clientId}", clientId).split("/ipfs")[0]}/ipfs/${cid}${bundleId ? `?bundleId=${bundleId}` : ""}`;
	    }
	    if (options.uri.startsWith("http")) {
	        return options.uri;
	    }
	    throw new Error(`Invalid URI scheme, expected "ipfs://" or "http(s)://"`);
	}
	/**
	 * @internal
	 */
	function findIPFSCidFromUri(uri) {
	    if (!uri.startsWith("ipfs://")) {
	        // do not touch URIs that are not ipfs URIs
	        return uri;
	    }
	    // first index of `/Qm` or `/bafy` in the uri (case insensitive)
	    const firstIndex = uri.search(/\/(Qm|baf)/i);
	    // we start one character after the first `/` to avoid including it in the CID
	    return uri.slice(firstIndex + 1);
	}
	/**
	 * Uploads or extracts URIs from the given files.
	 * @template T - The type of the files (File, Buffer, String).
	 * @param files - The files to upload or extract URIs from.
	 * @param client - The Thirdweb client.
	 * @param [startNumber] - The starting number for rewriting file names.
	 * @returns - A promise that resolves to an array of URIs.
	 * @throws {Error} - If the files are not all of the same type (all URI or all FileOrBufferOrString).
	 * @internal
	 *
	 */
	async function uploadOrExtractURIs(files, client, startNumber) {
	    if (isUriList(files)) {
	        return files;
	    }
	    if (isMetadataList(files)) {
	        const { upload } = await Promise.resolve().then(() => upload$1);
	        const uris = await upload({
	            client,
	            files,
	            rewriteFileNames: {
	                fileStartNumber: startNumber || 0,
	            },
	        });
	        return Array.isArray(uris) ? uris : [uris];
	    }
	    throw new Error("Files must all be of the same type (all URI or all FileOrBufferOrString)");
	}
	/**
	 * Retrieves the base URI from a batch of URIs.
	 *
	 * @param uris - An array of URIs.
	 * @returns The base URI shared by all URIs in the batch.
	 * @throws If the batch contains URIs with different base URIs or if no base URI is found.
	 * @internal
	 */
	function getBaseUriFromBatch(uris) {
	    const baseUri = uris[0]?.substring(0, uris[0].lastIndexOf("/"));
	    for (let i = 0; i < uris.length; i++) {
	        const uri = uris[i]?.substring(0, uris[i]?.lastIndexOf("/"));
	        if (baseUri !== uri) {
	            throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
	        }
	    }
	    if (!baseUri) {
	        throw new Error("No base URI found in the batch");
	    }
	    // Ensure that baseUri ends with trailing slash
	    return `${baseUri.replace(/\/$/, "")}/`;
	}
	function isUriList(metadatas) {
	    return metadatas.every((m) => typeof m === "string");
	}
	function isMetadataList(metadatas) {
	    return metadatas.every((m) => typeof m !== "string");
	}

	var arweave = {};

	Object.defineProperty(arweave, "__esModule", { value: true });
	arweave.resolveArweaveScheme = resolveArweaveScheme;
	const DEFAULT_GATEWAY = "https://arweave.net/{fileId}";
	/**
	 * Resolves the scheme of a given Arweave URI and returns the corresponding URL.
	 * @param options - The options object containing the Arweave URI
	 * @returns The resolved URL
	 * @throws Error if the URI scheme is invalid.
	 * @example
	 * ```ts
	 * import { resolveArweaveScheme } from "thirdweb/storage";
	 * const url = resolveArweaveScheme({ uri: "ar://<fileId>" });
	 * ```
	 * @storage
	 */
	function resolveArweaveScheme(options) {
	    if (options.uri.startsWith("ar://")) {
	        const fileId = options.uri.replace("ar://", "");
	        if (options.gatewayUrl) {
	            const separator = options.gatewayUrl.endsWith("/") ? "" : "/";
	            return `${options.gatewayUrl}${separator}${fileId}`;
	        }
	        return DEFAULT_GATEWAY.replace("{fileId}", fileId);
	    }
	    if (options.uri.startsWith("http")) {
	        return options.uri;
	    }
	    throw new Error(`Invalid URI scheme, expected "ar://" or "http(s)://"`);
	}

	Object.defineProperty(download$1, "__esModule", { value: true });
	download$1.download = download;
	const fetch_js_1$7 = fetch$1;
	const ipfs_js_1 = ipfs;
	/**
	 * @description Downloads a file from the specified IPFS, Arweave, or HTTP URI.
	 *
	 * `download` will parse the provided URI based on its scheme (ipfs://, ar://, https://) and convert it to a URL to fetch the file from thirdweb's storage service.
	 *
	 * @param options - The download options.
	 * @param options.client - The Thirdweb client. See [createThirdwebClient](https://portal.thirdweb.com/references/typescript/v5/createThirdwebClient).
	 * @param options.uri - The URI of the file to download. Can be IPFS, Arweave, or HTTP.
	 * @param [options.requestTimeoutMs] - The maximum time in milliseconds to wait for the request to complete. Defaults to 60 seconds (60,000 milliseconds).
	 *
	 * @returns Asynchronously returns the network response from fetching the file.
	 * @throws An error if the URI scheme is invalid or if the request fails.
	 *
	 * @example
	 * Download a file from IPFS:
	 * ```ts
	 * import { download } from "thirdweb/storage";
	 * import { createThirdwebClient } from "@thirdweb-dev/sdk";
	 *
	 * const client = createThirdwebClient({ clientId: "YOUR_CLIENT_ID" });
	 *
	 * const file = await download({
	 *  client,
	 *  uri: "ipfs://Qm...",
	 * });
	 * ```
	 *
	 * Download a file from Arweave:
	 * ```ts
	 * import { download } from "thirdweb/storage";
	 * import { createThirdwebClient } from "@thirdweb-dev/sdk";
	 *
	 * const client = createThirdwebClient({ clientId: "YOUR_CLIENT_ID" });
	 *
	 * const file = await download({
	 *  client,
	 *  uri: "ar://{arweave-transaction-id}",
	 * });
	 * ```
	 *
	 * Download a file from HTTP:
	 * ```ts
	 * import { download } from "thirdweb/storage";
	 * import { createThirdwebClient } from "@thirdweb-dev/sdk";
	 *
	 * const client = createThirdwebClient({ clientId: "YOUR_CLIENT_ID" });
	 *
	 * const file = await download({
	 *  client,
	 *  uri: "https://example.com/file.txt",
	 * });
	 * ```
	 *
	 * @storage
	 */
	async function download(options) {
	    let url;
	    if (options.uri.startsWith("ar://")) {
	        const { resolveArweaveScheme } = await Promise.resolve().then(() => arweave);
	        url = resolveArweaveScheme(options);
	    }
	    else {
	        url = (0, ipfs_js_1.resolveScheme)(options);
	    }
	    const res = await (0, fetch_js_1$7.getClientFetch)(options.client)(url, {
	        keepalive: options.client.config?.storage?.fetch?.keepalive,
	        headers: options.client.config?.storage?.fetch?.headers,
	        requestTimeoutMs: options.client.config?.storage?.fetch?.requestTimeoutMs ?? 60000,
	    });
	    if (!res.ok) {
	        res.body?.cancel();
	        throw new Error(`Failed to download file: ${res.statusText}`);
	    }
	    return res;
	}

	var extractIPFS = {};

	var encode$2 = {};

	var alphabet = {};

	Object.defineProperty(alphabet, "__esModule", { value: true });
	alphabet.ALPHABET = void 0;
	alphabet.ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

	Object.defineProperty(encode$2, "__esModule", { value: true });
	encode$2.base58Encode = base58Encode;
	const alphabet_js_1 = alphabet;
	const BASE = alphabet_js_1.ALPHABET.length;
	const LEADER = /* @__PURE__ */ (() => alphabet_js_1.ALPHABET.charAt(0))();
	const iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up
	/**
	 * Encodes a Uint8Array into a base58 string.
	 * @param source - The Uint8Array to encode.
	 * @returns The base58 encoded string.
	 * @throws {TypeError} If the source is not a Uint8Array.
	 * @throws {Error} If there is a non-zero carry during the encoding process.
	 * @example
	 * ```ts
	 * import { base58Encode } from "thirdweb/utils;
	 * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);
	 * const encoded = base58Encode(source);
	 * console.log(encoded);
	 * ```
	 */
	function base58Encode(source) {
	    if (!(source instanceof Uint8Array)) {
	        throw new TypeError("Expected Uint8Array");
	    }
	    if (source.length === 0) {
	        return "";
	    }
	    // Skip & count leading zeroes.
	    let zeroes = 0;
	    let length = 0;
	    let pbegin = 0;
	    const pend = source.length;
	    while (pbegin !== pend && source[pbegin] === 0) {
	        pbegin++;
	        zeroes++;
	    }
	    // Allocate enough space in big-endian base58 representation.
	    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
	    const b58 = new Uint8Array(size);
	    // Process the bytes.
	    while (pbegin !== pend) {
	        let carry = source[pbegin] || 0;
	        // Apply "b58 = b58 * 256 + ch".
	        let i = 0;
	        for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
	            carry += (256 * (b58[it1] || 0)) >>> 0;
	            b58[it1] = (carry % BASE) >>> 0;
	            carry = (carry / BASE) >>> 0;
	        }
	        if (carry !== 0) {
	            throw new Error("Non-zero carry");
	        }
	        length = i;
	        pbegin++;
	    }
	    // Skip leading zeroes in base58 result.
	    let it2 = size - length;
	    while (it2 !== size && b58[it2] === 0) {
	        it2++;
	    }
	    // Translate the result into a string.
	    let str = LEADER.repeat(zeroes);
	    for (; it2 < size; ++it2) {
	        str += alphabet_js_1.ALPHABET.charAt(b58[it2] || 0);
	    }
	    return str;
	}

	var cborDecode = {};

	// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js
	// heavily modified to remove all non-essential code
	Object.defineProperty(cborDecode, "__esModule", { value: true });
	cborDecode.decode = void 0;
	// TODO: re-enable typescript and properly type this
	// @ts-nocheck - TODO: re-enable typescript and properly type this
	let src;
	let srcEnd;
	let position = 0;
	let currentDecoder = {};
	let currentStructures;
	let srcString;
	const srcStringStart = 0;
	let srcStringEnd = 0;
	let bundledStrings;
	let referenceMap;
	let dataView;
	const defaultOptions = {
	    useRecords: false,
	    mapsAsObjects: true,
	};
	function readFixedString(length) {
	    let result;
	    if (length < 16) {
	        if (result = shortStringInJS(length))
	            return result;
	    }
	    if (length > 64 && decoder)
	        return decoder.decode(src.subarray(position, position += length));
	    const end = position + length;
	    const units = [];
	    result = '';
	    while (position < end) {
	        const byte1 = src[position++];
	        if ((byte1 & 0x80) === 0) {
	            // 1 byte
	            units.push(byte1);
	        }
	        else if ((byte1 & 0xe0) === 0xc0) {
	            // 2 bytes
	            const byte2 = src[position++] & 0x3f;
	            units.push(((byte1 & 0x1f) << 6) | byte2);
	        }
	        else if ((byte1 & 0xf0) === 0xe0) {
	            // 3 bytes
	            const byte2 = src[position++] & 0x3f;
	            const byte3 = src[position++] & 0x3f;
	            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
	        }
	        else if ((byte1 & 0xf8) === 0xf0) {
	            // 4 bytes
	            const byte2 = src[position++] & 0x3f;
	            const byte3 = src[position++] & 0x3f;
	            const byte4 = src[position++] & 0x3f;
	            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
	            if (unit > 0xffff) {
	                unit -= 0x10000;
	                units.push(((unit >>> 10) & 0x3ff) | 0xd800);
	                unit = 0xdc00 | (unit & 0x3ff);
	            }
	            units.push(unit);
	        }
	        else {
	            units.push(byte1);
	        }
	        if (units.length >= 0x1000) {
	            result += fromCharCode.apply(String, units);
	            units.length = 0;
	        }
	    }
	    if (units.length > 0) {
	        result += fromCharCode.apply(String, units);
	    }
	    return result;
	}
	class Decoder {
	    constructor() {
	        Object.assign(this, defaultOptions);
	    }
	    decodeKey(key) {
	        return key;
	    }
	    decode(source, end = -1) {
	        srcEnd = end > -1 ? end : source.length;
	        position = 0;
	        srcStringEnd = 0;
	        srcString = null;
	        bundledStrings = null;
	        src = source;
	        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
	        // technique for getting data from a database where it can be copied into an existing buffer instead of creating
	        // new ones
	        try {
	            dataView =
	                source.dataView ||
	                    (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
	        }
	        catch (error) {
	            // if it doesn't have a buffer, maybe it is the wrong type of object
	            src = null;
	            if (source instanceof Uint8Array) {
	                throw error;
	            }
	            throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === "object"
                ? source.constructor.name
                : typeof source}`);
	        }
	        if (this instanceof Decoder) {
	            currentDecoder = this;
	            this.sharedValues &&
	                    (this.pack
	                        ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues)
	                        : this.sharedValues);
	            if (!currentStructures || currentStructures.length > 0) {
	                currentStructures = [];
	            }
	        }
	        else {
	            currentDecoder = defaultOptions;
	            if (!currentStructures || currentStructures.length > 0) {
	                currentStructures = [];
	            }
	        }
	        return checkedRead();
	    }
	}
	function checkedRead() {
	    try {
	        const result = read();
	        if (bundledStrings) {
	            if (position >= bundledStrings.postBundlePosition) {
	                const error = new Error("Unexpected bundle position");
	                error.incomplete = true;
	                throw error;
	            }
	            // bundled strings to skip past
	            position = bundledStrings.postBundlePosition;
	            bundledStrings = null;
	        }
	        if (position === srcEnd) {
	            // finished reading this source, cleanup references
	            currentStructures = null;
	            src = null;
	            if (referenceMap) {
	                referenceMap = null;
	            }
	        }
	        else if (position > srcEnd) {
	            // over read
	            const error = new Error("Unexpected end of CBOR data");
	            error.incomplete = true;
	            throw error;
	        }
	        else {
	            throw new Error("Data read, but end of buffer not reached");
	        }
	        // else more to read, but we are reading sequentially, so don't clear source yet
	        return result;
	    }
	    catch (error) {
	        clearSource();
	        if (error instanceof RangeError ||
	            error.message.startsWith("Unexpected end of buffer")) {
	            error.incomplete = true;
	        }
	        throw error;
	    }
	}
	function read() {
	    let token = src[position++];
	    const majorType = token >> 5;
	    token = token & 0x1f;
	    if (token > 0x17) {
	        switch (token) {
	            case 0x18:
	                token = src[position++];
	                break;
	            default:
	                throw new Error(`Unknown token ${token}`);
	        }
	    }
	    switch (majorType) {
	        case 0: // positive int
	            return token;
	        case 1: // negative int
	            return ~token;
	        case 2: // buffer
	            return readBin(token);
	        case 3: // string
	            if (srcStringEnd >= position) {
	                return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
	            }
	            if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {
	                // for small blocks, avoiding the overhead of the extract call is helpful
	                const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
	                if (string !== null) {
	                    return string;
	                }
	            }
	            return readFixedString(token);
	        case 4: { // array
	            const array = new Array(token);
	            for (let i = 0; i < token; i++) {
	                array[i] = read();
	            }
	            return array;
	        }
	        case 5: { // map
	            const object = {};
	            for (let i = 0; i < token; i++) {
	                object[safeKey(read())] = read();
	            }
	            return object;
	        }
	        default: // negative int
	            if (Number.isNaN(token)) {
	                const error = new Error("Unexpected end of CBOR data");
	                error.incomplete = true;
	                throw error;
	            }
	            throw new Error(`Unknown CBOR token ${token}`);
	    }
	}
	function safeKey(key) {
	    // protect against prototype pollution
	    if (typeof key === "string") {
	        return key === "__proto__" ? "__proto_" : key;
	    }
	    if (typeof key !== "object") {
	        return key.toString();
	    }
	    // protect against expensive (DoS) string conversions
	    throw new Error(`Invalid property name type ${typeof key}`);
	}
	const fromCharCode = String.fromCharCode;
	function longStringInJS(length) {
	    const start = position;
	    const bytes = new Array(length);
	    for (let i = 0; i < length; i++) {
	        const byte = src[position++];
	        if ((byte & 0x80) > 0) {
	            position = start;
	            return;
	        }
	        bytes[i] = byte;
	    }
	    return fromCharCode.apply(String, bytes);
	}
	function shortStringInJS(length) {
	    if (length < 4) {
	        if (length < 2) {
	            if (length === 0) {
	                return "";
	            }
	            const a = src[position++];
	            if ((a & 0x80) > 1) {
	                position -= 1;
	                return;
	            }
	            return fromCharCode(a);
	        }
	        const a = src[position++];
	        const b = src[position++];
	        if ((a & 0x80) > 0 || (b & 0x80) > 0) {
	            position -= 2;
	            return;
	        }
	        if (length < 3) {
	            return fromCharCode(a, b);
	        }
	        const c = src[position++];
	        if ((c & 0x80) > 0) {
	            position -= 3;
	            return;
	        }
	        return fromCharCode(a, b, c);
	    }
	    const a = src[position++];
	    const b = src[position++];
	    const c = src[position++];
	    const d = src[position++];
	    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
	        position -= 4;
	        return;
	    }
	    if (length < 6) {
	        if (length === 4) {
	            return fromCharCode(a, b, c, d);
	        }
	        const e = src[position++];
	        if ((e & 0x80) > 0) {
	            position -= 5;
	            return;
	        }
	        return fromCharCode(a, b, c, d, e);
	    }
	    if (length < 8) {
	        const e = src[position++];
	        const f = src[position++];
	        if ((e & 0x80) > 0 || (f & 0x80) > 0) {
	            position -= 6;
	            return;
	        }
	        if (length < 7) {
	            return fromCharCode(a, b, c, d, e, f);
	        }
	        const g = src[position++];
	        if ((g & 0x80) > 0) {
	            position -= 7;
	            return;
	        }
	        return fromCharCode(a, b, c, d, e, f, g);
	    }
	    const e = src[position++];
	    const f = src[position++];
	    const g = src[position++];
	    const h = src[position++];
	    if ((e & 0x80) > 0 ||
	        (f & 0x80) > 0 ||
	        (g & 0x80) > 0 ||
	        (h & 0x80) > 0) {
	        position -= 8;
	        return;
	    }
	    if (length < 10) {
	        if (length === 8) {
	            return fromCharCode(a, b, c, d, e, f, g, h);
	        }
	        const i = src[position++];
	        if ((i & 0x80) > 0) {
	            position -= 9;
	            return;
	        }
	        return fromCharCode(a, b, c, d, e, f, g, h, i);
	    }
	    if (length < 12) {
	        const i = src[position++];
	        const j = src[position++];
	        if ((i & 0x80) > 0 || (j & 0x80) > 0) {
	            position -= 10;
	            return;
	        }
	        if (length < 11) {
	            return fromCharCode(a, b, c, d, e, f, g, h, i, j);
	        }
	        const k = src[position++];
	        if ((k & 0x80) > 0) {
	            position -= 11;
	            return;
	        }
	        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
	    }
	    const i = src[position++];
	    const j = src[position++];
	    const k = src[position++];
	    const l = src[position++];
	    if ((i & 0x80) > 0 ||
	        (j & 0x80) > 0 ||
	        (k & 0x80) > 0 ||
	        (l & 0x80) > 0) {
	        position -= 12;
	        return;
	    }
	    if (length < 14) {
	        if (length === 12) {
	            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
	        }
	        const m = src[position++];
	        if ((m & 0x80) > 0) {
	            position -= 13;
	            return;
	        }
	        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
	    }
	    const m = src[position++];
	    const n = src[position++];
	    if ((m & 0x80) > 0 || (n & 0x80) > 0) {
	        position -= 14;
	        return;
	    }
	    if (length < 15) {
	        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
	    }
	    const o = src[position++];
	    if ((o & 0x80) > 0) {
	        position -= 15;
	        return;
	    }
	    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
	}
	function readBin(length) {
	    return currentDecoder.copyBuffers
	        ? // specifically use the copying slice (not the node one)
	            Uint8Array.prototype.slice.call(src, position, (position += length))
	        : src.subarray(position, (position += length));
	}
	function clearSource() {
	    src = null;
	    referenceMap = null;
	    currentStructures = null;
	}
	const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding
	for (let i = 0; i < 256; i++) {
	    mult10[i] = /* @__PURE__ */ (() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();
	}
	const defaultDecoder = new Decoder();
	cborDecode.decode = defaultDecoder.decode;

	var prefix = {};

	Object.defineProperty(prefix, "__esModule", { value: true });
	prefix.ensureBytecodePrefix = ensureBytecodePrefix;
	const hex_js_1$3 = hex;
	/**
	 * Ensures that the given bytecode has the correct prefix.
	 * If the bytecode already starts with "0x", it is returned as is.
	 * Otherwise, the prefix "0x" is added to the bytecode.
	 * @param bytecode - The bytecode to ensure the prefix for.
	 * @returns The bytecode with the correct prefix.
	 * @example
	 * ```ts
	 * import { ensureBytecodePrefix } from "thirdweb/utils/bytecode/prefix";
	 * const bytecode = "363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3";
	 * const prefixedBytecode = ensureBytecodePrefix(bytecode);
	 * console.log(prefixedBytecode);
	 * ```
	 * @utils
	 */
	function ensureBytecodePrefix(bytecode) {
	    if ((0, hex_js_1$3.isHex)(bytecode, { strict: false })) {
	        return bytecode;
	    }
	    return `0x${bytecode}`;
	}

	Object.defineProperty(extractIPFS, "__esModule", { value: true });
	extractIPFS.extractIPFSUri = extractIPFSUri;
	const encode_js_1$3 = encode$2;
	const to_bytes_js_1$1 = toBytes$2;
	const cbor_decode_js_1 = cborDecode;
	const prefix_js_1 = prefix;
	/**
	 * Extracts the IPFS URI from the given bytecode.
	 * @param bytecode - The bytecode to extract the IPFS URI from.
	 * @returns The IPFS URI if found, otherwise undefined.
	 * @example
	 * ```ts
	 * import { extractIPFSUri } from "thirdweb/utils/bytecode/extractIPFS";
	 * const bytecode = "0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3";
	 * const ipfsHash = extractIPFSUri(bytecode);
	 * console.log(ipfsHash);
	 * ```
	 * @utils
	 */
	function extractIPFSUri(bytecode) {
	    const numericBytecode = (0, to_bytes_js_1$1.hexToBytes)((0, prefix_js_1.ensureBytecodePrefix)(bytecode));
	    const cborLength = 
	    // @ts-expect-error - TS doesn't like this, but it's fine
	    numericBytecode[numericBytecode.length - 2] * 0x100 +
	        // @ts-expect-error - TS doesn't like this, but it's fine
	        numericBytecode[numericBytecode.length - 1];
	    const cborStart = numericBytecode.length - 2 - cborLength;
	    // if the cborStart is invalid, return undefined
	    if (cborStart < 0 || cborStart > numericBytecode.length) {
	        return undefined;
	    }
	    const bytecodeBuffer = numericBytecode.slice(cborStart, -2);
	    const cborData = (0, cbor_decode_js_1.decode)(bytecodeBuffer);
	    if ("ipfs" in cborData) {
	        return `ipfs://${(0, encode_js_1$3.base58Encode)(cborData.ipfs)}`;
	    }
	    return undefined;
	}

	var getBytecode$1 = {};

	Object.defineProperty(getBytecode$1, "__esModule", { value: true });
	getBytecode$1.getBytecode = getBytecode;
	const eth_getCode_js_1 = eth_getCode$1;
	const rpc_js_1$6 = rpc$1;
	const BYTECODE_CACHE = new WeakMap();
	/**
	 * Retrieves the bytecode of a contract.
	 * @param contract - The ThirdwebContract instance.
	 * @returns A Promise that resolves to the bytecode of the contract.
	 * @example
	 * ```ts
	 * import { getBytecode } from "thirdweb/contract";
	 * const bytecode = await getBytecode(contract);
	 * ```
	 * @contract
	 */
	function getBytecode(contract) {
	    if (BYTECODE_CACHE.has(contract)) {
	        return BYTECODE_CACHE.get(contract);
	    }
	    const prom = (async () => {
	        const rpcRequest = (0, rpc_js_1$6.getRpcClient)(contract);
	        const result = await (0, eth_getCode_js_1.eth_getCode)(rpcRequest, {
	            address: contract.address,
	            blockTag: "latest",
	        });
	        if (result === "0x") {
	            BYTECODE_CACHE.delete(contract);
	        }
	        return result;
	    })();
	    BYTECODE_CACHE.set(contract, prom);
	    return prom;
	}

	Object.defineProperty(resolveAbi, "__esModule", { value: true });
	resolveAbi.resolveContractAbi = resolveContractAbi;
	resolveAbi.resolveAbiFromContractApi = resolveAbiFromContractApi;
	resolveAbi.resolveAbiFromBytecode = resolveAbiFromBytecode;
	resolveAbi.resolveCompositeAbi = resolveCompositeAbi;
	const abitype_1$1 = exports$1;
	const getInstalledModules_js_1 = getInstalledModules;
	const download_js_1 = download$1;
	const extractIPFS_js_1 = extractIPFS;
	const fetch_js_1$6 = fetch$1;
	const get_bytecode_js_1 = getBytecode$1;
	const ABI_RESOLUTION_CACHE = new WeakMap();
	/**
	 * Resolves the ABI (Application Binary Interface) for a given contract.
	 * If the ABI is already cached, it returns the cached value.
	 * Otherwise, it tries to resolve the ABI from the contract's API.
	 * If that fails, it resolves the ABI from the contract's bytecode.
	 * @param contract The contract for which to resolve the ABI.
	 * @param contractApiBaseUrl The base URL of the contract API. Defaults to "https://contract.thirdweb.com/abi".
	 * @returns A promise that resolves to the ABI of the contract.
	 * @example
	 * ```ts
	 * import { createThirdwebClient, getContract } from "thirdweb";
	 * import { resolveContractAbi } from "thirdweb/contract";
	 * import { ethereum } from "thirdweb/chains";
	 * const client = createThirdwebClient({ clientId: "..." });
	 * const myContract = getContract({
	 *  client,
	 *  address: "...",
	 *  chain: ethereum,
	 * });
	 * const abi = await resolveContractAbi(myContract);
	 * ```
	 * @contract
	 */
	function resolveContractAbi(contract, contractApiBaseUrl = "https://contract.thirdweb.com/abi") {
	    if (ABI_RESOLUTION_CACHE.has(contract)) {
	        return ABI_RESOLUTION_CACHE.get(contract);
	    }
	    const prom = (async () => {
	        // if the contract already HAS a user defined we always use that!
	        if (contract.abi) {
	            return contract.abi;
	        }
	        // try to get it from the api
	        try {
	            return await resolveAbiFromContractApi(contract, contractApiBaseUrl);
	        }
	        catch {
	            // if that fails, try to resolve it from the bytecode
	            return await resolveCompositeAbi(contract);
	        }
	    })();
	    ABI_RESOLUTION_CACHE.set(contract, prom);
	    return prom;
	}
	/**
	 * Resolves the ABI (Application Binary Interface) for a contract from the contract API.
	 * @param contract The ThirdwebContract instance representing the contract.
	 * @param contractApiBaseUrl The base URL of the contract API. Defaults to "https://contract.thirdweb.com/abi".
	 * @returns A promise that resolves to the ABI of the contract.
	 * @example
	 * ```ts
	 * import { createThirdwebClient, getContract } from "thirdweb";
	 * import { resolveAbiFromContractApi } from "thirdweb/contract"
	 * import { ethereum } from "thirdweb/chains";
	 * const client = createThirdwebClient({ clientId: "..." });
	 * const myContract = getContract({
	 *  client,
	 *  address: "...",
	 *  chain: ethereum,
	 * });
	 * const abi = await resolveAbiFromContractApi(myContract);
	 * ```
	 * @contract
	 */
	async function resolveAbiFromContractApi(
	// biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type
	contract, contractApiBaseUrl = "https://contract.thirdweb.com/abi") {
	    const response = await (0, fetch_js_1$6.getClientFetch)(contract.client)(`${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`);
	    const json = await response.json();
	    if (!json || json.error) {
	        throw new Error(`Failed to resolve ABI from contract API. ${json.error || ""}`);
	    }
	    return json;
	}
	/**
	 * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.
	 * @param contract The ThirdwebContract instance.
	 * @returns The resolved ABI as a generic type.
	 * @throws Error if no IPFS URI is found in the bytecode.
	 * @example
	 * ```ts
	 * import { createThirdwebClient, getContract } from "thirdweb";
	 * import { resolveAbiFromBytecode } from "thirdweb/contract";
	 * import { ethereum } from "thirdweb/chains";
	 * const client = createThirdwebClient({ clientId: "..." });
	 * const myContract = getContract({
	 *  client,
	 *  address: "...",
	 *  chain: ethereum,
	 * });
	 * const abi = await resolveAbiFromBytecode(myContract);
	 * ```
	 * @contract
	 */
	async function resolveAbiFromBytecode(
	// biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type
	contract) {
	    const bytecode = await (0, get_bytecode_js_1.getBytecode)(contract);
	    if (bytecode === "0x") {
	        const { id, name } = contract.chain;
	        throw new Error(`Failed to load contract bytecode. Make sure the contract [${contract.address}] exists on the chain [${name || "Unknown Chain"} (chain id: ${id})]`);
	    }
	    const ipfsUri = (0, extractIPFS_js_1.extractIPFSUri)(bytecode);
	    if (!ipfsUri) {
	        // just early exit if we can't find an IPFS URI
	        return [];
	    }
	    try {
	        const res = await (0, download_js_1.download)({ uri: ipfsUri, client: contract.client });
	        const json = await res.json();
	        // ABI is at `json.output.abi`
	        return json.output.abi;
	    }
	    catch {
	        // if we can't resolve the ABI from the IPFS URI, return an empty array
	        return [];
	    }
	}
	const PLUGINS_ABI = {
	    inputs: [],
	    name: "getAllPlugins",
	    outputs: [
	        {
	            components: [
	                {
	                    internalType: "bytes4",
	                    name: "functionSelector",
	                    type: "bytes4",
	                },
	                {
	                    internalType: "string",
	                    name: "functionSignature",
	                    type: "string",
	                },
	                {
	                    internalType: "address",
	                    name: "pluginAddress",
	                    type: "address",
	                },
	            ],
	            internalType: "struct IPluginMap.Plugin[]",
	            name: "registered",
	            type: "tuple[]",
	        },
	    ],
	    stateMutability: "view",
	    type: "function",
	};
	const BASE_ROUTER_ABI = {
	    inputs: [],
	    name: "getAllExtensions",
	    outputs: [
	        {
	            components: [
	                {
	                    components: [
	                        {
	                            internalType: "string",
	                            name: "name",
	                            type: "string",
	                        },
	                        {
	                            internalType: "string",
	                            name: "metadataURI",
	                            type: "string",
	                        },
	                        {
	                            internalType: "address",
	                            name: "implementation",
	                            type: "address",
	                        },
	                    ],
	                    internalType: "struct IExtension.ExtensionMetadata",
	                    name: "metadata",
	                    type: "tuple",
	                },
	                {
	                    components: [
	                        {
	                            internalType: "bytes4",
	                            name: "functionSelector",
	                            type: "bytes4",
	                        },
	                        {
	                            internalType: "string",
	                            name: "functionSignature",
	                            type: "string",
	                        },
	                    ],
	                    internalType: "struct IExtension.ExtensionFunction[]",
	                    name: "functions",
	                    type: "tuple[]",
	                },
	            ],
	            internalType: "struct IExtension.Extension[]",
	            name: "allExtensions",
	            type: "tuple[]",
	        },
	    ],
	    stateMutability: "view",
	    type: "function",
	};
	const DIAMOND_ABI = {
	    inputs: [],
	    name: "facets",
	    outputs: [
	        {
	            components: [
	                {
	                    internalType: "address",
	                    name: "facetAddress",
	                    type: "address",
	                },
	                {
	                    internalType: "bytes4[]",
	                    name: "functionSelectors",
	                    type: "bytes4[]",
	                },
	            ],
	            type: "tuple[]",
	        },
	    ],
	    stateMutability: "view",
	    type: "function",
	};
	/**
	 * Resolves the ABI for a contract based on its bytecode.
	 * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.
	 * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.
	 * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.
	 * @param contract The contract for which to resolve the ABI.
	 * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.
	 * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.
	 * @returns The resolved ABI for the contract.
	 * @example
	 * ```ts
	 * import { createThirdwebClient, getContract } from "thirdweb";
	 * import { resolveCompositeAbiFromBytecode } from "thirdweb/contract";
	 * import { ethereum } from "thirdweb/chains";
	 * const client = createThirdwebClient({ clientId: "..." });
	 * const myContract = getContract({
	 *  client,
	 *  address: "...",
	 *  chain: ethereum,
	 * });
	 * const abi = await resolveCompositeAbiFromBytecode(myContract);
	 * ```
	 * @contract
	 */
	async function resolveCompositeAbi(contract, rootAbi, resolveSubAbi) {
	    const [rootAbi_, pluginPatternAddresses, baseRouterAddresses, modularExtensionAddresses, diamondFacetAddresses,] = await Promise.all([
	        rootAbi ? rootAbi : resolveAbiFromBytecode(contract),
	        // check these all at the same time
	        resolvePluginPatternAddresses(contract),
	        resolveBaseRouterAddresses(contract),
	        resolveModularModuleAddresses(contract),
	        resolveDiamondFacetAddresses(contract),
	    ]);
	    const mergedPlugins = [
	        ...new Set([
	            ...pluginPatternAddresses,
	            ...baseRouterAddresses,
	            ...modularExtensionAddresses,
	            ...diamondFacetAddresses,
	        ]),
	    ];
	    // no plugins
	    if (!mergedPlugins.length) {
	        return rootAbi_;
	    }
	    // get all the abis for the plugins
	    const pluginAbis = await getAbisForPlugins({
	        contract,
	        plugins: mergedPlugins,
	        resolveSubAbi,
	    });
	    // join them together
	    return joinAbis({ rootAbi: rootAbi_, pluginAbis });
	}
	async function resolvePluginPatternAddresses(contract) {
	    try {
	        const { readContract } = await Promise.resolve().then(() => readContract$1);
	        const pluginMap = await readContract({
	            contract,
	            method: PLUGINS_ABI,
	        });
	        // if there are no plugins, return the root ABI
	        if (!pluginMap.length) {
	            return [];
	        }
	        // get all the plugin addresses
	        return [...new Set(pluginMap.map((item) => item.pluginAddress))];
	    }
	    catch {
	        // no-op, expected because not everything supports this
	    }
	    return [];
	}
	async function resolveBaseRouterAddresses(contract) {
	    try {
	        const { readContract } = await Promise.resolve().then(() => readContract$1);
	        const pluginMap = await readContract({
	            contract,
	            method: BASE_ROUTER_ABI,
	        });
	        // if there are no plugins, return the root ABI
	        if (!pluginMap.length) {
	            return [];
	        }
	        // get all the plugin addresses
	        return [...new Set(pluginMap.map((item) => item.metadata.implementation))];
	    }
	    catch {
	        // no-op, expected because not everything supports this
	    }
	    return [];
	}
	async function resolveModularModuleAddresses(contract) {
	    try {
	        const modules = await (0, getInstalledModules_js_1.getInstalledModules)({ contract });
	        // if there are no plugins, return the root ABI
	        if (!modules.length) {
	            return [];
	        }
	        // get all the plugin addresses
	        return [...new Set(modules.map((item) => item.implementation))];
	    }
	    catch {
	        // no-op, expected because not everything supports this
	    }
	    return [];
	}
	async function resolveDiamondFacetAddresses(contract) {
	    try {
	        const { readContract } = await Promise.resolve().then(() => readContract$1);
	        const facets = await readContract({ contract, method: DIAMOND_ABI });
	        // if there are no facets, return the root ABI
	        if (!facets.length) {
	            return [];
	        }
	        // get all the plugin addresses
	        return facets.map((item) => item.facetAddress);
	    }
	    catch {
	        // no-op, expected because not everything supports this
	    }
	    return [];
	}
	async function getAbisForPlugins(options) {
	    return Promise.all(options.plugins.map((pluginAddress) => {
	        const newContract = {
	            ...options.contract,
	            address: pluginAddress,
	        };
	        // if we have a method passed in that tells us how to resove the sub-api, use that
	        if (options.resolveSubAbi) {
	            return options.resolveSubAbi(newContract);
	        }
	        // otherwise default logic
	        return resolveAbiFromBytecode(newContract);
	    }));
	}
	function joinAbis(options) {
	    let mergedPlugins = options.pluginAbis
	        .flat()
	        .filter((item) => item.type !== "constructor");
	    if (options.rootAbi) {
	        mergedPlugins = [...(options.rootAbi || []), ...mergedPlugins].filter(Boolean);
	    }
	    // unique by formatting every abi and then throwing them in a set
	    // TODO: this may not be super efficient...
	    const humanReadableAbi = [...new Set((0, abitype_1$1.formatAbi)(mergedPlugins))];
	    // finally parse it back out
	    return (0, abitype_1$1.parseAbi)(humanReadableAbi);
	}

	Object.defineProperty(resolveMethod$1, "__esModule", { value: true });
	resolveMethod$1.resolveMethod = resolveMethod;
	const resolve_abi_js_1$1 = resolveAbi;
	/**
	 * Resolves and returns the ABI function with the specified method name.
	 * Throws an error if the function is not found in the ABI.
	 * @template abiFn - The type of the ABI function.
	 * @param method - The name of the method to resolve.
	 * @returns The resolved ABI function.
	 * @throws Error if the function is not found in the ABI.
	 * @example
	 * ```ts
	 * import { resolveMethod, prepareContractCall } from "thirdweb";
	 * const tx = prepareContractCall({
	 *  contract,
	 *  // automatically resolves the necessary abi to encode the transaction
	 *  method: resolveMethod("transfer"),
	 *  // however there is no type completion for params in this case (as the resolution is async and happens at runtime)
	 *  params: [to, value],
	 * });
	 * ```
	 * @contract
	 */
	function resolveMethod(method) {
	    return async (contract) => {
	        const resolvedAbi = await (0, resolve_abi_js_1$1.resolveContractAbi)(contract);
	        // we try to find the abiFunction in the abi
	        const abiFunction = resolvedAbi.find((item) => {
	            // if the item is not a function we can ignore it
	            if (item.type !== "function") {
	                return false;
	            }
	            // if the item is a function we can compare the name
	            return item.name === method;
	        });
	        if (!abiFunction) {
	            throw new Error(`could not find function with name "${method}" in abi`);
	        }
	        return abiFunction;
	    };
	}

	var encode$1 = {};

	var concatHex$1 = {};

	Object.defineProperty(concatHex$1, "__esModule", { value: true });
	concatHex$1.concatHex = concatHex;
	/**
	 * Concatenates an array of hexadecimal values into a single hexadecimal value.
	 *
	 * @param values - An array of hexadecimal values to concatenate.
	 * @returns The concatenated hexadecimal value.
	 * @utils
	 */
	function concatHex(values) {
	    return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
	}

	Object.defineProperty(encode$1, "__esModule", { value: true });
	encode$1.encode = encode;
	encode$1.getDataFromTx = getDataFromTx;
	encode$1.getExtraCallDataFromTx = getExtraCallDataFromTx;
	const encodeWeakMap = new WeakMap();
	/**
	 * Encodes a transaction object into a hexadecimal string representation of the encoded data.
	 * @param transaction - The transaction object to encode.
	 * @returns A promise that resolves to the encoded data as a hexadecimal string.
	 * @transaction
	 * @example
	 * ```ts
	 * import { encode } from "thirdweb";
	 * const encodedData = await encode(transaction);
	 * ```
	 */
	async function encode(transaction) {
	    if (encodeWeakMap.has(transaction)) {
	        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
	        return encodeWeakMap.get(transaction);
	    }
	    const promise = (async () => {
	        const [data, extraData, { concatHex }] = await Promise.all([
	            getDataFromTx(transaction),
	            getExtraCallDataFromTx(transaction),
	            Promise.resolve().then(() => concatHex$1),
	        ]);
	        if (extraData) {
	            return concatHex([data, extraData]);
	        }
	        return data;
	    })();
	    encodeWeakMap.set(transaction, promise);
	    return promise;
	}
	/**
	 * Get the transaction.data (from a PreparedTransaction)
	 * If the transaction does not have `data`, we default to "0x"
	 * @internal
	 */
	async function getDataFromTx(transaction) {
	    if (transaction.data === undefined) {
	        return "0x";
	    }
	    if (typeof transaction.data === "function") {
	        const data = await transaction.data();
	        if (!data) {
	            return "0x";
	        }
	        return data;
	    }
	    return transaction.data;
	}
	/**
	 * Get the extraCallData from a PreparedTransaction
	 * @internal
	 * If extraCallData is "0x", we will return `undefined`
	 * to simplify the code, since concatenating "0x" doesn't do anything
	 */
	async function getExtraCallDataFromTx(transaction) {
	    if (!transaction.extraCallData) {
	        return undefined;
	    }
	    if (typeof transaction.extraCallData === "function") {
	        const extraData = await transaction.extraCallData();
	        if (!extraData)
	            return undefined;
	        if (!extraData.startsWith("0x")) {
	            throw Error("Invalid extra calldata - must be a hex string");
	        }
	        if (extraData === "0x") {
	            return undefined;
	        }
	        return extraData;
	    }
	    if (!transaction.extraCallData.startsWith("0x")) {
	        throw Error("Invalid extra calldata - must be a hex string");
	    }
	    return transaction.extraCallData;
	}

	var estimateGas$1 = {};

	var opGasFeeReducer = {};

	Object.defineProperty(opGasFeeReducer, "__esModule", { value: true });
	opGasFeeReducer.roundUpGas = roundUpGas;
	/**
	 * Via: https://twitter.com/0xjustadev/status/1758973668011434062
	 *
	 * Increases the gas fee value to the nearest power of 2.
	 * If the value is already a power of 2 or 0, it returns the value as is.
	 * Otherwise, it finds the highest power of 2 that is bigger than the given value.
	 * @param value - The gas fee value to be "rounded up".
	 * @returns The *increased* gas value which will result in a lower L1 gas fee, overall reducing the gas fee.
	 * @internal
	 */
	function roundUpGas(value) {
	    if (value === 0n || (value & (value - 1n)) === 0n) {
	        return value;
	    }
	    // Find the highest set bit by shifting until the value is 0.
	    let highestBit = 1n;
	    while (value > 0n) {
	        // biome-ignore lint/style/noParameterAssign: the whole point is that we modify the value in palce
	        value >>= 1n;
	        highestBit <<= 1n;
	    }
	    return highestBit;
	}

	var extractError = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.__DEV__ = void 0;
		exports.extractError = extractError;
		const viem_1 = _cjs;
		const resolve_abi_js_1 = resolveAbi;
		/**
		 * @internal
		 */
		async function extractError(args) {
		    const { error, contract } = args;
		    if (typeof error === "object") {
		        // try to parse RPC error
		        const errorObj = error;
		        if (errorObj.data) {
		            if (errorObj.data !== "0x") {
		                let abi = contract?.abi;
		                if (contract && !abi) {
		                    abi = await (0, resolve_abi_js_1.resolveContractAbi)(contract).catch(() => undefined);
		                }
		                const parsedError = (0, viem_1.decodeErrorResult)({
		                    data: errorObj.data,
		                    abi,
		                });
		                return new TransactionError(`${parsedError.errorName}${parsedError.args ? ` - ${parsedError.args}` : ""}`, contract);
		            }
		            return new TransactionError("Execution Reverted", contract);
		        }
		    }
		    return error;
		}
		exports.__DEV__ = "production" !== "production";
		class TransactionError extends Error {
		    constructor(reason, contract) {
		        let message = reason;
		        if (exports.__DEV__ && contract) {
		            // show more infor in dev
		            message = [
		                reason,
		                "",
		                `contract: ${contract.address}`,
		                `chainId: ${contract.chain?.id}`,
		            ].join("\n");
		        }
		        super(message);
		        Object.defineProperty(this, "contractAddress", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        Object.defineProperty(this, "chainId", {
		            enumerable: true,
		            configurable: true,
		            writable: true,
		            value: void 0
		        });
		        this.name = "TransactionError";
		        this.contractAddress = contract?.address;
		        this.chainId = contract?.chain?.id;
		        this.message = message;
		    }
		}
		
	} (extractError));

	Object.defineProperty(estimateGas$1, "__esModule", { value: true });
	estimateGas$1.estimateGas = estimateGas;
	const viem_1$7 = _cjs;
	const op_gas_fee_reducer_js_1$1 = opGasFeeReducer;
	const resolve_promised_value_js_1$5 = resolvePromisedValue$1;
	const extract_error_js_1$1 = extractError;
	const cache = new WeakMap();
	/**
	 * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.
	 * @param options - The options for estimating gas.
	 * @returns A promise that resolves to the estimated gas as a bigint.
	 * @transaction
	 * @example
	 * ```ts
	 * import { estimateGas } from "thirdweb";
	 * const gas = await estimateGas({
	 *  transaction,
	 * });
	 * ```
	 */
	async function estimateGas(options) {
	    // from is:
	    // 1. the user specified from address
	    // 2. the passed in account address
	    // 3. the passed in wallet's account address
	    const from = options.from ?? options.account?.address ?? undefined;
	    const txWithFrom = { ...options.transaction, from };
	    if (cache.has(txWithFrom)) {
	        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
	        return cache.get(txWithFrom);
	    }
	    const { account } = options;
	    const promise = (async () => {
	        const predefinedGas = await (0, resolve_promised_value_js_1$5.resolvePromisedValue)(options.transaction.gas);
	        // if we have a predefined gas value in the TX -> always use that
	        if (predefinedGas !== undefined) {
	            return predefinedGas;
	        }
	        // if the wallet itself overrides the estimateGas function, use that
	        if (account?.estimateGas) {
	            try {
	                let gas = await account.estimateGas(options.transaction);
	                if (options.transaction.chain.experimental?.increaseZeroByteCount) {
	                    gas = (0, op_gas_fee_reducer_js_1$1.roundUpGas)(gas);
	                }
	                return gas;
	            }
	            catch (error) {
	                throw await (0, extract_error_js_1$1.extractError)({
	                    error,
	                    contract: options.transaction.__contract,
	                });
	            }
	        }
	        // load up encode function if we need it
	        const { encode } = await Promise.resolve().then(() => encode$1);
	        const [encodedData, toAddress, value] = await Promise.all([
	            encode(options.transaction),
	            (0, resolve_promised_value_js_1$5.resolvePromisedValue)(options.transaction.to),
	            (0, resolve_promised_value_js_1$5.resolvePromisedValue)(options.transaction.value),
	        ]);
	        // load up the rpc client and the estimateGas function if we need it
	        const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([
	            Promise.resolve().then(() => rpc$1),
	            Promise.resolve().then(() => eth_estimateGas$1),
	        ]);
	        const rpcRequest = getRpcClient(options.transaction);
	        try {
	            let gas = await eth_estimateGas(rpcRequest, (0, viem_1$7.formatTransactionRequest)({
	                to: toAddress,
	                data: encodedData,
	                from,
	                value,
	            }));
	            if (options.transaction.chain.experimental?.increaseZeroByteCount) {
	                gas = (0, op_gas_fee_reducer_js_1$1.roundUpGas)(gas);
	            }
	            return gas;
	        }
	        catch (error) {
	            throw await (0, extract_error_js_1$1.extractError)({
	                error,
	                contract: options.transaction.__contract,
	            });
	        }
	    })();
	    cache.set(txWithFrom, promise);
	    return promise;
	}

	var estimateGasCost$1 = {};

	var constants$1 = {};

	var baseSepolia = {};

	Object.defineProperty(baseSepolia, "__esModule", { value: true });
	baseSepolia.baseSepolia = void 0;
	const utils_js_1$9 = utils$7;
	/**
	 * @chain
	 */
	baseSepolia.baseSepolia = (0, utils_js_1$9.defineChain)({
	    id: 84532,
	    name: "Base Sepolia",
	    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
	    blockExplorers: [
	        {
	            name: "Basescan",
	            url: "https://sepolia.basescan.org",
	            apiUrl: "https://api-sepolia.basescan.org/api",
	        },
	    ],
	    testnet: true,
	});

	var base = {};

	Object.defineProperty(base, "__esModule", { value: true });
	base.base = void 0;
	const utils_js_1$8 = utils$7;
	/**
	 * @chain
	 */
	base.base = (0, utils_js_1$8.defineChain)({
	    id: 8453,
	    name: "Base",
	    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
	    blockExplorers: [
	        {
	            name: "Basescan",
	            url: "https://basescan.org",
	            apiUrl: "https://api.basescan.org/api",
	        },
	    ],
	});

	var optimismSepolia = {};

	Object.defineProperty(optimismSepolia, "__esModule", { value: true });
	optimismSepolia.optimismSepolia = void 0;
	const utils_js_1$7 = utils$7;
	/**
	 * @chain
	 */
	optimismSepolia.optimismSepolia = (0, utils_js_1$7.defineChain)({
	    id: 11155420,
	    name: "OP Sepolia",
	    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
	    blockExplorers: [
	        {
	            name: "Blockscout",
	            url: "https://optimism-sepolia.blockscout.com",
	            apiUrl: "https://optimism-sepolia.blockscout.com/api",
	        },
	    ],
	    testnet: true,
	});

	var optimism = {};

	Object.defineProperty(optimism, "__esModule", { value: true });
	optimism.optimism = void 0;
	const utils_js_1$6 = utils$7;
	/**
	 * @chain
	 */
	optimism.optimism = (0, utils_js_1$6.defineChain)({
	    id: 10,
	    name: "OP Mainnet",
	    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
	    blockExplorers: [
	        {
	            name: "Optimism Explorer",
	            url: "https://optimistic.etherscan.io",
	            apiUrl: "https://api-optimistic.etherscan.io",
	        },
	    ],
	});

	var zoraSepolia = {};

	Object.defineProperty(zoraSepolia, "__esModule", { value: true });
	zoraSepolia.zoraSepolia = void 0;
	const utils_js_1$5 = utils$7;
	/**
	 * @chain
	 */
	zoraSepolia.zoraSepolia = (0, utils_js_1$5.defineChain)({
	    id: 999999999,
	    name: "Zora Sepolia",
	    nativeCurrency: {
	        decimals: 18,
	        name: "Zora Sepolia",
	        symbol: "ETH",
	    },
	    blockExplorers: [
	        {
	            name: "Zora Sepolia Explorer",
	            url: "https://sepolia.explorer.zora.energy/",
	            apiUrl: "https://sepolia.explorer.zora.energy/api",
	        },
	    ],
	    testnet: true,
	});

	var zora = {};

	Object.defineProperty(zora, "__esModule", { value: true });
	zora.zora = void 0;
	const utils_js_1$4 = utils$7;
	/**
	 * @chain
	 */
	zora.zora = (0, utils_js_1$4.defineChain)({
	    id: 7777777,
	    name: "Zora",
	    nativeCurrency: {
	        decimals: 18,
	        name: "Ether",
	        symbol: "ETH",
	    },
	    blockExplorers: [
	        {
	            name: "Explorer",
	            url: "https://explorer.zora.energy",
	            apiUrl: "https://explorer.zora.energy/api",
	        },
	    ],
	});

	Object.defineProperty(constants$1, "__esModule", { value: true });
	constants$1.isOpStackChain = isOpStackChain;
	const base_sepolia_js_1 = baseSepolia;
	const base_js_1 = base;
	const optimism_sepolia_js_1 = optimismSepolia;
	const optimism_js_1 = optimism;
	const zora_sepolia_js_1 = zoraSepolia;
	const zora_js_1 = zora;
	const opChains = [
	    base_js_1.base.id,
	    base_sepolia_js_1.baseSepolia.id,
	    optimism_js_1.optimism.id,
	    optimism_sepolia_js_1.optimismSepolia.id,
	    zora_js_1.zora.id,
	    zora_sepolia_js_1.zoraSepolia.id,
	    34443, // mode
	    919, // mode testnet
	    42220, // celo
	    44787, // celo testnet
	    204, // opBNB
	    5611, // opBNB testnet
	];
	/**
	 * TODO this should be in the chain definition itself
	 * @internal
	 */
	function isOpStackChain(chain) {
	    return opChains.includes(chain.id);
	}

	var getGasPrice$1 = {};

	Object.defineProperty(getGasPrice$1, "__esModule", { value: true });
	getGasPrice$1.getGasPrice = getGasPrice;
	const eth_gasPrice_js_1 = eth_gasPrice$1;
	const rpc_js_1$5 = rpc$1;
	/**
	 * Retrieves the gas price for a transaction on a specific chain.
	 * @param client - The Thirdweb client.
	 * @param chain - The ID of the chain.
	 * @returns A promise that resolves to the gas price as a bigint.
	 * @example
	 * ```ts
	 * import { getGasPrice } from "thirdweb";
	 *
	 * const gasPrice = await getGasPrice({ client, chain });
	 * ```
	 * @utils
	 */
	async function getGasPrice(options) {
	    const { client, chain, percentMultiplier } = options;
	    const rpcClient = (0, rpc_js_1$5.getRpcClient)({ client, chain });
	    const gasPrice_ = await (0, eth_gasPrice_js_1.eth_gasPrice)(rpcClient);
	    const extraTip = percentMultiplier
	        ? (gasPrice_ / BigInt(100)) * BigInt(percentMultiplier)
	        : 0n;
	    const txGasPrice = gasPrice_ + extraTip;
	    return txGasPrice;
	}

	var units = {};

	Object.defineProperty(units, "__esModule", { value: true });
	units.toTokens = toTokens;
	units.toEther = toEther;
	units.toUnits = toUnits;
	units.toWei = toWei;
	units.fromGwei = fromGwei;
	/**
	 * Converts a given number of units to a string representation with a specified number of decimal places.
	 * @param units - The number of units to convert.
	 * @param decimals - The number of decimal places to include in the string representation.
	 * @returns The string representation of the converted units.
	 * @example
	 * ```ts
	 * import { toTokens } from "thirdweb/utils";
	 * toTokens(1000000000000000000n, 18)
	 * // '1'
	 * ```
	 * @utils
	 */
	function toTokens(units, decimals) {
	    // Convert to string once and handle negativity.
	    const stringValue = units.toString();
	    const prefix = stringValue[0] === "-" ? "-" : "";
	    // Abusing that string "-" is truthy
	    const absStringValue = prefix ? stringValue.slice(1) : stringValue;
	    // Ensure we have enough digits for the fractional part.
	    const paddedValue = absStringValue.padStart(decimals + 1, "0");
	    const splitIndex = paddedValue.length - decimals;
	    // Extract integer and fraction parts directly.
	    const integerPart = paddedValue.slice(0, splitIndex) || "0";
	    let fractionPart = paddedValue.slice(splitIndex);
	    // Manually trim trailing zeros from the fraction part.
	    for (let i = fractionPart.length - 1; i >= 0; i--) {
	        if (fractionPart[i] !== "0") {
	            fractionPart = fractionPart.slice(0, i + 1);
	            break;
	        }
	        // check if the next digit is a zero also
	        // If all zeros, make fraction part empty
	        if (i === 0) {
	            fractionPart = "";
	        }
	    }
	    // Construct and return the formatted string.
	    return `${prefix}${integerPart}${fractionPart ? `.${fractionPart}` : ""}`;
	}
	/**
	 * Converts a value from wei to ether.
	 * @param wei The value in wei to be converted.
	 * @returns The converted value in ether.
	 * @example
	 * ```ts
	 * import { toEther } from "thirdweb/utils";
	 * toEther(1000000000000000000n)
	 * // '1'
	 * ```
	 * @utils
	 */
	function toEther(wei) {
	    return toTokens(wei, 18);
	}
	/**
	 * Converts a string representation of a number with decimal places to a BigInt representation.
	 * @param tokens - The string representation of the number, including the integer and fraction parts.
	 * @param decimals - The number of decimal places to include in the BigInt representation.
	 * @returns The BigInt representation of the number.
	 * @example
	 * ```ts
	 * import { toUnits } from "thirdweb/utils";
	 * toUnits('1', 18)
	 * // 1000000000000000000n
	 * ```
	 * @utils
	 */
	function toUnits(tokens, decimals) {
	    let [integerPart, fractionPart = ""] = tokens.split(".");
	    const prefix = integerPart.startsWith("-") ? "-" : "";
	    if (prefix) {
	        integerPart = integerPart.slice(1);
	    }
	    fractionPart = fractionPart.padEnd(decimals, "0"); // Ensure fraction part is at least 'decimals' long.
	    if (decimals === 0) {
	        // Check if there's any fraction part that would necessitate rounding up the integer part.
	        if (fractionPart[0] && Number.parseInt(fractionPart[0]) >= 5) {
	            integerPart = (BigInt(integerPart) + 1n).toString();
	        }
	        fractionPart = ""; // No fraction part is needed when decimals === 0.
	    }
	    else {
	        // When decimals > 0, handle potential rounding based on the digit right after the specified decimal places.
	        if (fractionPart.length > decimals) {
	            const roundingDigit = fractionPart[decimals];
	            if (roundingDigit && Number.parseInt(roundingDigit, 10) >= 5) {
	                // If rounding is needed, add 1 to the last included digit of the fraction part.
	                const roundedFraction = BigInt(fractionPart.substring(0, decimals)) + 1n;
	                fractionPart = roundedFraction.toString().padStart(decimals, "0");
	                if (fractionPart.length > decimals) {
	                    // If rounding the fraction results in a length increase (e.g., .999 -> 1.000), increment the integer part.
	                    integerPart = (BigInt(integerPart) + 1n).toString();
	                    // Adjust the fraction part if it's longer than the specified decimals due to rounding up.
	                    fractionPart = fractionPart.substring(fractionPart.length - decimals);
	                }
	            }
	            else {
	                // If no rounding is necessary, just truncate the fraction part to the specified number of decimals.
	                fractionPart = fractionPart.substring(0, decimals);
	            }
	        }
	        // If the fraction part is shorter than the specified decimals, it's already handled by padEnd() above.
	    }
	    // Combine the integer and fraction parts into the final BigInt representation.
	    return BigInt(`${prefix}${integerPart}${fractionPart}`);
	}
	/**
	 * Converts the specified number of tokens to Wei.
	 * @param tokens The number of tokens to convert.
	 * @returns The converted value in Wei.
	 * @example
	 * ```ts
	 * import { toWei } from "thirdweb/utils";
	 * toWei('1')
	 * // 1000000000000000000n
	 * ```
	 * @utils
	 */
	function toWei(tokens) {
	    return toUnits(tokens, 18);
	}
	/**
	 * Converts the specified number from gwei to wei.
	 * @param gwei The number of gwei to convert.
	 * @returns The converted value in wei.
	 * @example
	 * ```ts
	 * import { fromGwei } from "thirdweb/utils";
	 * fromGwei('1')
	 * // 1000000000n
	 * ```
	 * @utils
	 */
	function fromGwei(gwei) {
	    return toUnits(gwei, 9);
	}

	var estimateL1Fee = {};

	var toSerializableTransaction$1 = {};

	var feeData = {};

	Object.defineProperty(feeData, "__esModule", { value: true });
	feeData.getGasOverridesForTransaction = getGasOverridesForTransaction;
	feeData.getDefaultGasOverrides = getDefaultGasOverrides;
	const eth_getBlockByNumber_js_1 = eth_getBlockByNumber$1;
	const eth_maxPriorityFeePerGas_js_1 = eth_maxPriorityFeePerGas$1;
	const rpc_js_1$4 = rpc$1;
	const resolve_promised_value_js_1$4 = resolvePromisedValue$1;
	const units_js_1$2 = units;
	const get_gas_price_js_1$1 = getGasPrice$1;
	const op_gas_fee_reducer_js_1 = opGasFeeReducer;
	// for these chains - always force pre eip1559 transactions
	const FORCE_GAS_PRICE_CHAIN_IDS = [
	    78600, // Vanar testnet
	    2040, // Vanar mainnet
	    248, // Oasys Mainnet
	    9372, // Oasys Testnet
	    841, // Taraxa Mainnet
	    842, // Taraxa Testnet
	    2016, // MainnetZ Mainnet
	    9768, // MainnetZ Testnet
	];
	/**
	 *
	 * @internal
	 */
	async function getGasOverridesForTransaction(transaction) {
	    // first check for explicit values
	    const [maxFeePerGas, maxPriorityFeePerGas, gasPrice] = await Promise.all([
	        (0, resolve_promised_value_js_1$4.resolvePromisedValue)(transaction.maxFeePerGas),
	        (0, resolve_promised_value_js_1$4.resolvePromisedValue)(transaction.maxPriorityFeePerGas),
	        (0, resolve_promised_value_js_1$4.resolvePromisedValue)(transaction.gasPrice),
	    ]);
	    // Exit early if the user explicitly provided enough options
	    if (maxFeePerGas !== undefined && maxPriorityFeePerGas !== undefined) {
	        return {
	            maxFeePerGas,
	            maxPriorityFeePerGas,
	        };
	    }
	    if (gasPrice) {
	        return { gasPrice };
	    }
	    // If we don't have enough explicit values, get defaults
	    const defaultGasOverrides = await getDefaultGasOverrides(transaction.client, transaction.chain);
	    if (transaction.chain.experimental?.increaseZeroByteCount) {
	        // otherwise adjust each value
	        if (defaultGasOverrides.gasPrice) {
	            return { gasPrice: (0, op_gas_fee_reducer_js_1.roundUpGas)(defaultGasOverrides.gasPrice) };
	        }
	        return {
	            maxFeePerGas: maxFeePerGas ?? (0, op_gas_fee_reducer_js_1.roundUpGas)(defaultGasOverrides.maxFeePerGas ?? 0n),
	            maxPriorityFeePerGas: maxPriorityFeePerGas ??
	                (0, op_gas_fee_reducer_js_1.roundUpGas)(defaultGasOverrides.maxPriorityFeePerGas ?? 0n),
	        };
	    }
	    // return as is
	    if (defaultGasOverrides.gasPrice) {
	        return defaultGasOverrides;
	    }
	    // Still check for explicit values in case one is provided and not the other
	    return {
	        maxFeePerGas: maxFeePerGas ?? defaultGasOverrides.maxFeePerGas,
	        maxPriorityFeePerGas: maxPriorityFeePerGas ?? defaultGasOverrides.maxPriorityFeePerGas,
	    };
	}
	/**
	 * Retrieves the default gas overrides for a given client and chain ID.
	 * If the fee data contains both maxFeePerGas and maxPriorityFeePerGas, it returns an object with those values.
	 * Otherwise, it returns an object with the gasPrice obtained from the client and chain ID.
	 * @param client - The ThirdwebClient instance.
	 * @param chain - The chain ID.
	 * @returns An object containing the default gas overrides.
	 * @internal
	 */
	async function getDefaultGasOverrides(client, chain) {
	    // if chain is in the force gas price list, always use gas price
	    if (!FORCE_GAS_PRICE_CHAIN_IDS.includes(chain.id)) {
	        const feeData = await getDynamicFeeData(client, chain);
	        if (feeData.maxFeePerGas !== null &&
	            feeData.maxPriorityFeePerGas !== null) {
	            return {
	                maxFeePerGas: feeData.maxFeePerGas,
	                maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,
	            };
	        }
	    }
	    return {
	        gasPrice: await (0, get_gas_price_js_1$1.getGasPrice)({ client, chain, percentMultiplier: 10 }),
	    };
	}
	/**
	 * Retrieves dynamic fee data for a given chain.
	 * @param client - The Thirdweb client.
	 * @param chain - The chain ID.
	 * @returns A promise that resolves to the fee data.
	 * @internal
	 */
	async function getDynamicFeeData(client, chain) {
	    let maxFeePerGas = null;
	    let maxPriorityFeePerGas_ = null;
	    const rpcRequest = (0, rpc_js_1$4.getRpcClient)({ client, chain });
	    const [block, maxPriorityFeePerGas] = await Promise.all([
	        (0, eth_getBlockByNumber_js_1.eth_getBlockByNumber)(rpcRequest, { blockTag: "latest" }),
	        (0, eth_maxPriorityFeePerGas_js_1.eth_maxPriorityFeePerGas)(rpcRequest).catch(() => null),
	    ]);
	    const baseBlockFee = block?.baseFeePerGas ?? 0n;
	    const chainId = chain.id;
	    // flag chain testnet & flag chain
	    if (chainId === 220 || chainId === 1220) {
	        // these does not support eip-1559, for some reason even though `eth_maxPriorityFeePerGas` is available?!?
	        // return null because otherwise TX break
	        return { maxFeePerGas: null, maxPriorityFeePerGas: null };
	        // mumbai & polygon
	    }
	    if (chainId === 80002 || chainId === 137) {
	        // for polygon, get fee data from gas station
	        maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);
	    }
	    else if (maxPriorityFeePerGas !== null) {
	        // prioritize fee from eth_maxPriorityFeePerGas
	        maxPriorityFeePerGas_ = maxPriorityFeePerGas;
	    }
	    if (maxPriorityFeePerGas_ == null) {
	        // chain does not support eip-1559, return null for both
	        return { maxFeePerGas: null, maxPriorityFeePerGas: null };
	    }
	    // add 10% tip to maxPriorityFeePerGas for faster processing
	    maxPriorityFeePerGas_ = getPreferredPriorityFee(maxPriorityFeePerGas_);
	    // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is
	    // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees
	    maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;
	    // special cased for Celo gas fees
	    if (chainId === 42220 || chainId === 44787 || chainId === 62320) {
	        maxPriorityFeePerGas_ = maxFeePerGas;
	    }
	    return {
	        maxFeePerGas,
	        maxPriorityFeePerGas: maxPriorityFeePerGas_,
	    };
	}
	/**
	 * Calculates the preferred priority fee based on the default priority fee per gas and a percent multiplier.
	 * @param defaultPriorityFeePerGas - The default priority fee per gas.
	 * @param percentMultiplier - The percent multiplier to calculate the extra tip. Default is 10.
	 * @returns The total priority fee including the extra tip.
	 * @internal
	 */
	function getPreferredPriorityFee(defaultPriorityFeePerGas, percentMultiplier = 10) {
	    const extraTip = (defaultPriorityFeePerGas / BigInt(100)) * BigInt(percentMultiplier);
	    const totalPriorityFee = defaultPriorityFeePerGas + extraTip;
	    return totalPriorityFee;
	}
	/**
	 * @internal
	 */
	function getGasStationUrl(chainId) {
	    switch (chainId) {
	        case 137:
	            return "https://gasstation.polygon.technology/v2";
	        case 80002:
	            return "https://gasstation-testnet.polygon.technology/v2";
	    }
	}
	const MIN_POLYGON_GAS_PRICE = 31n; // 31 gwei
	/**
	 *
	 * @returns The gas price
	 * @internal
	 */
	async function getPolygonGasPriorityFee(chainId) {
	    const gasStationUrl = getGasStationUrl(chainId);
	    try {
	        const data = await (await fetch(gasStationUrl)).json();
	        // take the standard speed here, SDK options will define the extra tip
	        const priorityFee = data.fast.maxPriorityFee;
	        if (priorityFee > 0) {
	            const fixedFee = Number.parseFloat(priorityFee).toFixed(9);
	            return (0, units_js_1$2.toUnits)(fixedFee, 9);
	        }
	    }
	    catch (e) {
	        console.error("failed to fetch gas", e);
	    }
	    return MIN_POLYGON_GAS_PRICE;
	}

	Object.defineProperty(toSerializableTransaction$1, "__esModule", { value: true });
	toSerializableTransaction$1.toSerializableTransaction = toSerializableTransaction;
	const fee_data_js_1 = feeData;
	const rpc_js_1$3 = rpc$1;
	const resolve_promised_value_js_1$3 = resolvePromisedValue$1;
	const encode_js_1$2 = encode$1;
	const estimate_gas_js_1$1 = estimateGas$1;
	/**
	 * Converts a prepared transaction to a transaction with populated options.
	 * @param options - The transaction and additional options for conversion
	 * @returns A serializable transaction for inspection or submission to an account.
	 *
	 * @note For easier transaction sending, {@see sendTransaction}
	 * @example
	 * ```ts
	 * import { prepareTransaction, toSerializableTransaction } from "thirdweb";
	 *
	 * const transaction = await prepareTransaction({
	 *   transaction: {
	 *     to: "0x...",
	 *     value: 100,
	 *   },
	 * });
	 * const finalTx = await toSerializableTransaction({
	 *   transaction,
	 * });
	 *
	 * account.sendTransaction(finalTx);
	 * ```
	 * @transaction
	 */
	async function toSerializableTransaction(options) {
	    const rpcRequest = (0, rpc_js_1$3.getRpcClient)(options.transaction);
	    const chainId = options.transaction.chain.id;
	    const from = options.from;
	    let [data, nonce, gas, feeData, to, accessList, value] = await Promise.all([
	        (0, encode_js_1$2.encode)(options.transaction),
	        (async () => {
	            // if the user has specified a nonce, use that
	            const resolvedNonce = await (0, resolve_promised_value_js_1$3.resolvePromisedValue)(options.transaction.nonce);
	            if (resolvedNonce !== undefined) {
	                return resolvedNonce;
	            }
	            return from // otherwise get the next nonce (import the method to do so)
	                ? await Promise.resolve().then(() => eth_getTransactionCount$1).then(({ eth_getTransactionCount }) => eth_getTransactionCount(rpcRequest, {
	                    address: from,
	                    blockTag: "pending",
	                }))
	                : undefined;
	        })(),
	        // takes the same options as the sendTransaction function thankfully!
	        (0, estimate_gas_js_1$1.estimateGas)(options),
	        (0, fee_data_js_1.getGasOverridesForTransaction)(options.transaction),
	        (0, resolve_promised_value_js_1$3.resolvePromisedValue)(options.transaction.to),
	        (0, resolve_promised_value_js_1$3.resolvePromisedValue)(options.transaction.accessList),
	        (0, resolve_promised_value_js_1$3.resolvePromisedValue)(options.transaction.value),
	    ]);
	    const extraGas = await (0, resolve_promised_value_js_1$3.resolvePromisedValue)(options.transaction.extraGas);
	    if (extraGas) {
	        gas += extraGas;
	    }
	    return {
	        to,
	        chainId,
	        data,
	        gas,
	        nonce,
	        accessList,
	        value,
	        ...feeData,
	    };
	}

	var hasRequiredEstimateL1Fee;

	function requireEstimateL1Fee () {
		if (hasRequiredEstimateL1Fee) return estimateL1Fee;
		hasRequiredEstimateL1Fee = 1;
		Object.defineProperty(estimateL1Fee, "__esModule", { value: true });
		estimateL1Fee.estimateL1Fee = estimateL1Fee$1;
		const viem_1 = _cjs;
		const contract_js_1 = contract;
		const to_serializable_transaction_js_1 = toSerializableTransaction$1;
		const read_contract_js_1 = readContract$1;
		const OPStackGasPriceOracleAddress = "0x420000000000000000000000000000000000000F";
		/**
		 * @internal
		 */
		async function estimateL1Fee$1(options) {
		    const { transaction, gasPriceOracleAddress } = options;
		    const oracleContract = (0, contract_js_1.getContract)({
		        client: transaction.client,
		        address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,
		        chain: transaction.chain,
		    });
		    // purposefully remove gasPrice from the transaction
		    const { gasPrice, ...serializableTx } = await (0, to_serializable_transaction_js_1.toSerializableTransaction)({
		        transaction,
		    });
		    const serialized = (0, viem_1.serializeTransaction)({
		        ...serializableTx,
		        type: "eip1559",
		    });
		    //serializeTransaction(transaction);
		    return (0, read_contract_js_1.readContract)({
		        contract: oracleContract,
		        method: "function getL1Fee(bytes memory _data) view returns (uint256)",
		        params: [serialized],
		    });
		}
		
		return estimateL1Fee;
	}

	Object.defineProperty(estimateGasCost$1, "__esModule", { value: true });
	estimateGasCost$1.estimateGasCost = estimateGasCost;
	const constants_js_1$2 = constants$1;
	const get_gas_price_js_1 = getGasPrice$1;
	const resolve_promised_value_js_1$2 = resolvePromisedValue$1;
	const units_js_1$1 = units;
	const estimate_gas_js_1 = estimateGas$1;
	/**
	 * Estimate the gas cost of a transaction in ether and wei.
	 * @example
	 * ```ts
	 * import { estimateGasCost } from "thirdweb";
	 *
	 * const gasCost = await estimateGasCost({ transaction });
	 * ```
	 * @transaction
	 */
	async function estimateGasCost(options) {
	    const { transaction } = options;
	    const from = options.from ?? options.account?.address ?? undefined;
	    const gasLimit = (await (0, resolve_promised_value_js_1$2.resolvePromisedValue)(transaction.gas)) ||
	        (await (0, estimate_gas_js_1.estimateGas)({ transaction, from }));
	    const gasPrice = await (0, get_gas_price_js_1.getGasPrice)({
	        client: transaction.client,
	        chain: transaction.chain,
	    });
	    let l1Fee;
	    if ((0, constants_js_1$2.isOpStackChain)(transaction.chain)) {
	        const { estimateL1Fee } = await Promise.resolve().then(() => requireEstimateL1Fee());
	        l1Fee = await estimateL1Fee({
	            transaction,
	        });
	    }
	    else {
	        l1Fee = 0n;
	    }
	    const wei = gasLimit * gasPrice + l1Fee;
	    return {
	        ether: (0, units_js_1$1.toEther)(wei),
	        wei,
	    };
	}

	var sendTransaction$1 = {};

	var transactionStore = {};

	var store = {};

	Object.defineProperty(store, "__esModule", { value: true });
	store.createStore = createStore;
	/**
	 * Create a reactive value store
	 * @param initialValue - The initial value to store
	 * @example
	 * ```ts
	 * const store = createStore(0);
	 * ```
	 * @returns A store object
	 * @internal
	 */
	function createStore(initialValue) {
	    const listeners = new Set();
	    let value = initialValue;
	    const notify = () => {
	        for (const listener of listeners) {
	            listener();
	        }
	    };
	    return {
	        getValue() {
	            return value;
	        },
	        setValue(newValue) {
	            if (newValue === value) {
	                return;
	            }
	            value = newValue;
	            notify();
	        },
	        subscribe(listener) {
	            listeners.add(listener);
	            return () => {
	                listeners.delete(listener);
	            };
	        },
	    };
	}

	Object.defineProperty(transactionStore, "__esModule", { value: true });
	transactionStore.getTransactionStore = getTransactionStore;
	transactionStore.addTransactionToStore = addTransactionToStore;
	const store_js_1 = store;
	const transactionsByAddress = new Map();
	/**
	 * Retrieve the transaction store for a given address.
	 * @param address - The address to retrieve the transaction store for.
	 * @returns A store of transactions for the given account to subscribe to.
	 * @transaction
	 * @example
	 * ```ts
	 * import { getTransactionStore } from "thirdweb/transaction";
	 *
	 * const store = getTransactionStore("0x...");
	 * store.subscribe((transactions) => {
	 *   console.log(transactions);
	 * });
	 * ```
	 */
	function getTransactionStore(address) {
	    const existingStore = transactionsByAddress.get(address);
	    if (existingStore) {
	        return existingStore;
	    }
	    const newStore = (0, store_js_1.createStore)([]);
	    transactionsByAddress.set(address, newStore);
	    return newStore;
	}
	/**
	 * @internal
	 */
	function addTransactionToStore(options) {
	    const { address, transactionHash, chainId } = options;
	    const tranasctionStore = getTransactionStore(address);
	    tranasctionStore.setValue([
	        ...tranasctionStore.getValue(),
	        { transactionHash, chainId },
	    ]);
	    transactionsByAddress.set(address, tranasctionStore);
	}

	var sendGaslessTransaction = {};

	var biconomy = {};

	var hasRequiredBiconomy;

	function requireBiconomy () {
		if (hasRequiredBiconomy) return biconomy;
		hasRequiredBiconomy = 1;
		Object.defineProperty(biconomy, "__esModule", { value: true });
		biconomy.prepareBiconomyTransaction = prepareBiconomyTransaction;
		biconomy.relayBiconomyTransaction = relayBiconomyTransaction;
		const viem_1 = _cjs;
		const addresses_js_1 = addresses;
		const contract_js_1 = contract;
		const is_hex_js_1 = isHex$3;
		const keccak256_js_1 = keccak256$1;
		const json_js_1 = json;
		const read_contract_js_1 = readContract$1;
		// we do not send multiple batches so this stays consistent
		const BATCH_ID = 0n;
		/**
		 * @internal - only exported for testing
		 */
		async function prepareBiconomyTransaction({ account, serializableTransaction, transaction, gasless, }) {
		    const forwarderContract = (0, contract_js_1.getContract)({
		        address: gasless.relayerForwarderAddress,
		        chain: transaction.chain,
		        client: transaction.client,
		    });
		    // get the nonce
		    const nonce = await (0, read_contract_js_1.readContract)({
		        contract: forwarderContract,
		        method: "function getNonce(address,uint256) view returns (uint256)",
		        params: [account.address, BATCH_ID],
		    });
		    const deadline = Math.floor(Date.now() / 1000) + (gasless.deadlineSeconds ?? 3600);
		    const request = {
		        from: account.address,
		        to: serializableTransaction.to,
		        token: addresses_js_1.ADDRESS_ZERO,
		        txGas: serializableTransaction.gas,
		        tokenGasPrice: 0n,
		        batchId: BATCH_ID,
		        batchNonce: nonce,
		        deadline: deadline,
		        data: serializableTransaction.data,
		    };
		    if (!request.to) {
		        throw new Error("Cannot send a transaction without a `to` address");
		    }
		    if (!request.txGas) {
		        throw new Error("Cannot send a transaction without a `gas` value");
		    }
		    if (!request.data) {
		        throw new Error("Cannot send a transaction without a `data` value");
		    }
		    // create the hash
		    const message = (0, viem_1.encodeAbiParameters)([
		        { type: "address" },
		        { type: "address" },
		        { type: "address" },
		        { type: "uint256" },
		        { type: "uint256" },
		        { type: "uint256" },
		        { type: "uint256" },
		        { type: "bytes32" },
		    ], [
		        request.from,
		        request.to,
		        request.token,
		        request.txGas,
		        request.tokenGasPrice,
		        request.batchId,
		        request.batchNonce,
		        (0, keccak256_js_1.keccak256)(request.data),
		    ]);
		    const signature = await account.signMessage({ message });
		    return [request, signature];
		}
		/**
		 * @internal
		 */
		async function relayBiconomyTransaction(options) {
		    const [request, signature] = await prepareBiconomyTransaction(options);
		    // send the transaction to the biconomy api
		    const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
		        method: "POST",
		        body: (0, json_js_1.stringify)({
		            apiId: options.gasless.apiId,
		            params: [request, signature],
		            from: request.from,
		            to: request.to,
		            gasLimit: request.txGas,
		        }),
		        headers: {
		            "x-api-key": options.gasless.apiKey,
		            "Content-Type": "application/json;charset=utf-8",
		        },
		    });
		    if (!response.ok) {
		        response.body?.cancel();
		        throw new Error(`Failed to send transaction: ${await response.text()}`);
		    }
		    const json = await response.json();
		    const transactionHash = json.txHash;
		    if ((0, is_hex_js_1.isHex)(transactionHash)) {
		        return {
		            transactionHash: transactionHash,
		            chain: options.transaction.chain,
		            client: options.transaction.client,
		        };
		    }
		    throw new Error(`Failed to send transaction: ${(0, json_js_1.stringify)(json)}`);
		}
		
		return biconomy;
	}

	var openzeppelin = {};

	var hasRequiredOpenzeppelin;

	function requireOpenzeppelin () {
		if (hasRequiredOpenzeppelin) return openzeppelin;
		hasRequiredOpenzeppelin = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.ChainAwareForwardRequest = exports.ForwardRequest = void 0;
			exports.prepareOpenZeppelinTransaction = prepareOpenZeppelinTransaction;
			exports.relayOpenZeppelinTransaction = relayOpenZeppelinTransaction;
			const contract_js_1 = contract;
			const is_hex_js_1 = isHex$3;
			const json_js_1 = json;
			const read_contract_js_1 = readContract$1;
			/**
			 * @internal - only exported for testing
			 */
			async function prepareOpenZeppelinTransaction({ account, serializableTransaction, transaction, gasless, }) {
			    const forrwaderContract = (0, contract_js_1.getContract)({
			        address: gasless.relayerForwarderAddress,
			        chain: transaction.chain,
			        client: transaction.client,
			    });
			    const nonce = await (0, read_contract_js_1.readContract)({
			        contract: forrwaderContract,
			        method: "function getNonce(address) view returns (uint256)",
			        params: [account.address],
			    });
			    const [signature, message] = await (async () => {
			        // TODO: handle special case for `approve` -> `permit` transactions
			        if (!serializableTransaction.to) {
			            throw new Error("OpenZeppelin transactions must have a 'to' address");
			        }
			        if (!serializableTransaction.gas) {
			            throw new Error("OpenZeppelin transactions must have a 'gas' value");
			        }
			        if (!serializableTransaction.data) {
			            throw new Error("OpenZeppelin transactions must have a 'data' value");
			        }
			        // chainless support!
			        if (gasless.experimentalChainlessSupport) {
			            const message = {
			                from: account.address,
			                to: serializableTransaction.to,
			                value: 0n,
			                gas: serializableTransaction.gas,
			                nonce: nonce,
			                data: serializableTransaction.data,
			                chainid: BigInt(transaction.chain.id),
			            };
			            return [
			                await account.signTypedData({
			                    domain: {
			                        name: "GSNv2 Forwarder",
			                        version: "0.0.1",
			                        verifyingContract: forrwaderContract.address,
			                    },
			                    message,
			                    primaryType: "ForwardRequest",
			                    types: { ForwardRequest: exports.ChainAwareForwardRequest },
			                }),
			                message,
			            ];
			        }
			        // else non-chainless support
			        const message = {
			            from: account.address,
			            to: serializableTransaction.to,
			            value: 0n,
			            gas: serializableTransaction.gas,
			            nonce: nonce,
			            data: serializableTransaction.data,
			        };
			        return [
			            await account.signTypedData({
			                domain: {
			                    name: gasless.domainName ?? "GSNv2 Forwarder",
			                    version: gasless.domainVersion ?? "0.0.1",
			                    chainId: transaction.chain.id,
			                    verifyingContract: forrwaderContract.address,
			                },
			                message,
			                primaryType: "ForwardRequest",
			                types: { ForwardRequest: exports.ForwardRequest },
			            }),
			            message,
			        ];
			    })();
			    // TODO: handle special case for `approve` -> `permit`
			    const messageType = "forward";
			    return { message, signature, messageType };
			}
			exports.ForwardRequest = [
			    { name: "from", type: "address" },
			    { name: "to", type: "address" },
			    { name: "value", type: "uint256" },
			    { name: "gas", type: "uint256" },
			    { name: "nonce", type: "uint256" },
			    { name: "data", type: "bytes" },
			];
			exports.ChainAwareForwardRequest = [
			    { name: "from", type: "address" },
			    { name: "to", type: "address" },
			    { name: "value", type: "uint256" },
			    { name: "gas", type: "uint256" },
			    { name: "nonce", type: "uint256" },
			    { name: "data", type: "bytes" },
			    { name: "chainid", type: "uint256" },
			];
			/**
			 * @internal
			 */
			async function relayOpenZeppelinTransaction(options) {
			    const { message, messageType, signature } = await prepareOpenZeppelinTransaction(options);
			    const response = await fetch(options.gasless.relayerUrl, {
			        method: "POST",
			        body: (0, json_js_1.stringify)({
			            request: message,
			            type: messageType,
			            signature,
			            forwarderAddress: options.gasless.relayerForwarderAddress,
			        }),
			    });
			    if (!response.ok) {
			        response.body?.cancel();
			        throw new Error(`Failed to send transaction: ${await response.text()}`);
			    }
			    const json = await response.json();
			    if (!json.result) {
			        throw new Error(`Relay transaction failed: ${json.message}`);
			    }
			    const transactionHash = JSON.parse(json.result).txHash;
			    if ((0, is_hex_js_1.isHex)(transactionHash)) {
			        return {
			            transactionHash,
			            chain: options.transaction.chain,
			            client: options.transaction.client,
			        };
			    }
			    throw new Error(`Failed to send transaction: ${(0, json_js_1.stringify)(json)}`);
			}
			
		} (openzeppelin));
		return openzeppelin;
	}

	var engine = {};

	var waitForTxReceipt = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.DEFAULT_MAX_BLOCKS_WAIT_TIME = void 0;
		exports.waitForReceipt = waitForReceipt;
		const eth_getTransactionReceipt_js_1 = eth_getTransactionReceipt$1;
		const rpc_js_1 = rpc$1;
		const watchBlockNumber_js_1 = watchBlockNumber$3;
		exports.DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;
		const map = new Map();
		/**
		 * Waits for the transaction receipt of a given transaction hash on a specific contract.
		 * @param options - The options for waiting for the receipt.
		 * By default, it's 100 blocks.
		 * @returns A promise that resolves with the transaction receipt.
		 * @transaction
		 * @example
		 * ```ts
		 * import { waitForReceipt } from "thirdweb";
		 * const receipt = await waitForReceipt({
		 *   client,
		 *   chain,
		 *   transactionHash: "0x123...",
		 * });
		 * ```
		 */
		function waitForReceipt(options) {
		    const { transactionHash, chain, client } = options;
		    const chainId = chain.id;
		    const key = `${chainId}:tx_${transactionHash}`;
		    const maxBlocksWaitTime = options.maxBlocksWaitTime ?? exports.DEFAULT_MAX_BLOCKS_WAIT_TIME;
		    if (map.has(key)) {
		        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
		        return map.get(key);
		    }
		    const promise = new Promise((resolve, reject) => {
		        if (!transactionHash) {
		            reject(new Error("Transaction has no transactionHash to wait for, did you execute it?"));
		        }
		        const request = (0, rpc_js_1.getRpcClient)({ client, chain });
		        // start at -1 because the first block doesn't count
		        let blocksWaited = -1;
		        const unwatch = (0, watchBlockNumber_js_1.watchBlockNumber)({
		            client: client,
		            chain: chain,
		            onNewBlockNumber: async () => {
		                blocksWaited++;
		                if (blocksWaited >= maxBlocksWaitTime) {
		                    unwatch();
		                    reject(new Error(`Transaction not found after ${maxBlocksWaitTime} blocks`));
		                    return;
		                }
		                try {
		                    const receipt = await (0, eth_getTransactionReceipt_js_1.eth_getTransactionReceipt)(request, {
		                        hash: transactionHash,
		                    });
		                    // stop the polling
		                    unwatch();
		                    // resolve the top level promise with the receipt
		                    resolve(receipt);
		                }
		                catch {
		                    // noop, we'll try again on the next blocks
		                }
		            },
		        });
		        // remove the promise from the map when it's done (one way or the other)
		    }).finally(() => {
		        map.delete(key);
		    });
		    map.set(key, promise);
		    return promise;
		}
		
	} (waitForTxReceipt));

	var hasRequiredEngine;

	function requireEngine () {
		if (hasRequiredEngine) return engine;
		hasRequiredEngine = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.ChainAwareForwardRequest = exports.ForwardRequest = void 0;
			exports.prepareEngineTransaction = prepareEngineTransaction;
			exports.relayEngineTransaction = relayEngineTransaction;
			const contract_js_1 = contract;
			const json_js_1 = json;
			const read_contract_js_1 = readContract$1;
			const wait_for_tx_receipt_js_1 = waitForTxReceipt;
			/**
			 * @internal - only exported for testing
			 */
			async function prepareEngineTransaction({ account, serializableTransaction, transaction, gasless, }) {
			    const forrwaderContract = (0, contract_js_1.getContract)({
			        address: gasless.relayerForwarderAddress,
			        chain: transaction.chain,
			        client: transaction.client,
			    });
			    const nonce = await (0, read_contract_js_1.readContract)({
			        contract: forrwaderContract,
			        method: "function getNonce(address) view returns (uint256)",
			        params: [account.address],
			    });
			    const [signature, message] = await (async () => {
			        // TODO: handle special case for `approve` -> `permit` transactions
			        if (!serializableTransaction.to) {
			            throw new Error("engine transactions must have a 'to' address");
			        }
			        if (!serializableTransaction.gas) {
			            throw new Error("engine transactions must have a 'gas' value");
			        }
			        if (!serializableTransaction.data) {
			            throw new Error("engine transactions must have a 'data' value");
			        }
			        // chainless support!
			        if (gasless.experimentalChainlessSupport) {
			            const message = {
			                from: account.address,
			                to: serializableTransaction.to,
			                value: 0n,
			                gas: serializableTransaction.gas,
			                nonce: nonce,
			                data: serializableTransaction.data,
			                chainid: BigInt(transaction.chain.id),
			            };
			            return [
			                await account.signTypedData({
			                    domain: {
			                        name: "GSNv2 Forwarder",
			                        version: "0.0.1",
			                        verifyingContract: forrwaderContract.address,
			                    },
			                    message,
			                    primaryType: "ForwardRequest",
			                    types: { ForwardRequest: exports.ChainAwareForwardRequest },
			                }),
			                message,
			            ];
			        }
			        // else non-chainless support
			        const message = {
			            from: account.address,
			            to: serializableTransaction.to,
			            value: 0n,
			            gas: serializableTransaction.gas,
			            nonce: nonce,
			            data: serializableTransaction.data,
			        };
			        return [
			            await account.signTypedData({
			                domain: {
			                    name: gasless.domainName ?? "GSNv2 Forwarder",
			                    version: gasless.domainVersion ?? "0.0.1",
			                    chainId: transaction.chain.id,
			                    verifyingContract: forrwaderContract.address,
			                },
			                message,
			                primaryType: "ForwardRequest",
			                types: { ForwardRequest: exports.ForwardRequest },
			            }),
			            message,
			        ];
			    })();
			    // TODO: handle special case for `approve` -> `permit`
			    const messageType = "forward";
			    return { message, signature, messageType };
			}
			exports.ForwardRequest = [
			    { name: "from", type: "address" },
			    { name: "to", type: "address" },
			    { name: "value", type: "uint256" },
			    { name: "gas", type: "uint256" },
			    { name: "nonce", type: "uint256" },
			    { name: "data", type: "bytes" },
			];
			exports.ChainAwareForwardRequest = [
			    { name: "from", type: "address" },
			    { name: "to", type: "address" },
			    { name: "value", type: "uint256" },
			    { name: "gas", type: "uint256" },
			    { name: "nonce", type: "uint256" },
			    { name: "data", type: "bytes" },
			    { name: "chainid", type: "uint256" },
			];
			/**
			 * @internal
			 */
			async function relayEngineTransaction(options) {
			    const { message, messageType, signature } = await prepareEngineTransaction(options);
			    const response = await fetch(options.gasless.relayerUrl, {
			        method: "POST",
			        headers: {
			            "Content-Type": "application/json",
			        },
			        body: (0, json_js_1.stringify)({
			            request: message,
			            type: messageType,
			            signature,
			            forwarderAddress: options.gasless.relayerForwarderAddress,
			        }),
			    });
			    if (!response.ok) {
			        throw new Error(`Failed to send transaction: ${await response.text()}`);
			    }
			    const json = await response.json();
			    if (!json.result) {
			        throw new Error(`Relay transaction failed: ${json.message}`);
			    }
			    const queueId = json.result.queueId;
			    // poll for transactionHash
			    const timeout = 60000;
			    const interval = 1000;
			    const endtime = Date.now() + timeout;
			    while (Date.now() < endtime) {
			        const receipt = await fetchReceipt({ options, queueId });
			        if (receipt) {
			            return {
			                transactionHash: receipt.transactionHash,
			                chain: options.transaction.chain,
			                client: options.transaction.client,
			            };
			        }
			        await new Promise((resolve) => setTimeout(resolve, interval));
			    }
			    throw new Error(`Failed to find relayed transaction after ${timeout}ms`);
			}
			async function fetchReceipt(args) {
			    const { options, queueId } = args;
			    const url = options.gasless.relayerUrl.split("/relayer/")[0];
			    const res = await fetch(`${url}/transaction/status/${queueId}`, {
			        method: "GET",
			    });
			    const resJson = await res.json();
			    if (!res.ok) {
			        return null;
			    }
			    const result = resJson.result;
			    if (!result) {
			        return null;
			    }
			    switch (result.status) {
			        case "errored":
			            throw new Error(`Transaction errored with reason: ${result.errorMessage}`);
			        case "cancelled":
			            throw new Error("Transaction execution cancelled.");
			        case "mined": {
			            const receipt = await (0, wait_for_tx_receipt_js_1.waitForReceipt)({
			                client: options.transaction.client,
			                chain: options.transaction.chain,
			                transactionHash: result.transactionHash,
			            });
			            return receipt;
			        }
			        default: {
			            return null;
			        }
			    }
			}
			
		} (engine));
		return engine;
	}

	var hasRequiredSendGaslessTransaction;

	function requireSendGaslessTransaction () {
		if (hasRequiredSendGaslessTransaction) return sendGaslessTransaction;
		hasRequiredSendGaslessTransaction = 1;
		Object.defineProperty(sendGaslessTransaction, "__esModule", { value: true });
		sendGaslessTransaction.sendGaslessTransaction = sendGaslessTransaction$1;
		const transaction_store_js_1 = transactionStore;
		async function sendGaslessTransaction$1({ account, transaction, serializableTransaction, gasless, }) {
		    // TODO: handle special case for mutlicall transactions!
		    // Steps:
		    // 1. check if the method is `multicall` by comparing the 4bytes data with the `multicall` selector
		    // 2. split the rest of the data into its "parts"
		    // 3. solidityPack the parts with the part data + the `account.address`
		    // see v4: `core/classes/transactions.ts>Transaction>prepareGasless:L551`
		    if (serializableTransaction.value && serializableTransaction.value > 0n) {
		        throw new Error("Gasless transactions cannot have a value");
		    }
		    // TODO: multiply gas by 2 for some reason(?) - we do in v4, *should* we?
		    let result;
		    // biconomy
		    if (gasless.provider === "biconomy") {
		        const { relayBiconomyTransaction } = await Promise.resolve().then(() => requireBiconomy());
		        result = await relayBiconomyTransaction({
		            account,
		            transaction,
		            serializableTransaction,
		            gasless,
		        });
		    }
		    // openzeppelin
		    if (gasless.provider === "openzeppelin") {
		        const { relayOpenZeppelinTransaction } = await Promise.resolve().then(() => requireOpenzeppelin());
		        result = await relayOpenZeppelinTransaction({
		            account,
		            transaction,
		            serializableTransaction,
		            gasless,
		        });
		    }
		    if (gasless.provider === "engine") {
		        const { relayEngineTransaction } = await Promise.resolve().then(() => requireEngine());
		        result = await relayEngineTransaction({
		            account,
		            transaction,
		            serializableTransaction,
		            gasless,
		        });
		    }
		    if (!result) {
		        throw new Error("Unsupported gasless provider");
		    }
		    (0, transaction_store_js_1.addTransactionToStore)({
		        address: account.address,
		        transactionHash: result.transactionHash,
		        chainId: transaction.chain.id,
		    });
		    return result;
		}
		
		return sendGaslessTransaction;
	}

	Object.defineProperty(sendTransaction$1, "__esModule", { value: true });
	sendTransaction$1.sendTransaction = sendTransaction;
	const transaction_store_js_1 = transactionStore;
	const to_serializable_transaction_js_1 = toSerializableTransaction$1;
	/**
	 * Sends a transaction using the provided account.
	 *
	 * You can send a transaction with a [prepared contract call](https://portal.thirdweb.com/references/typescript/v5/prepareContractCall), a [prepared transaction](https://portal.thirdweb.com/references/typescript/v5/prepareTransaction), or using a write [Extension](https://portal.thirdweb.com/typescript/v5/extensions/use).
	 * @param options - The options for sending the transaction.
	 * @returns A promise that resolves to the transaction result.
	 * @throws An error if the transaction reverts.
	 * @transaction
	 * @example
	 *
	 * ### Using a prepared contract call
	 *
	 * ```ts
	 * import { sendTransaction, getContract, prepareContractCall } from "thirdweb";
	 * import { sepolia } from "thirdweb/chains";
	 *
	 * const contract = getContract({
	 *   address: "0x...",
	 *   chain: sepolia,
	 *   client,
	 * });
	 *
	 * const transaction = prepareContractCall({
	 *   contract,
	 *   method: "function transfer(address to, uint256 value)",
	 *   params: [to, value],
	 * });
	 *
	 * const { transactionHash } = await sendTransaction({
	 *  account,
	 *  transaction,
	 * });
	 * ```
	 *
	 * ### Using a write extension
	 *
	 * ```ts
	 * import { sendTransaction, getContract } from "thirdweb";
	 * import { sepolia } from "thirdweb/chains";
	 * import { mintTo } from "thirdweb/extensions/erc721";
	 *
	 * const contract = getContract({
	 *   address: "0x...",
	 *   chain: sepolia,
	 *   client,
	 * });
	 *
	 * const transaction = mintTo({
	 *   contract,
	 *   to: "0x...",
	 *   nft: {
	 *     name: "NFT Name",
	 *     description: "NFT Description",
	 *     image: "https://example.com/image.png",
	 *   },
	 * });
	 *
	 * const { transactionHash } = await sendTransaction({
	 *  account,
	 *  transaction,
	 * });
	 * ```
	 *
	 * ### Using a prepared transaction
	 *
	 * ```ts
	 * import { sendTransaction, getContract, prepareTransaction } from "thirdweb";
	 * import { sepolia } from "thirdweb/chains";
	 *
	 * const contract = getContract({
	 *   address: "0x...",
	 *   chain: sepolia,
	 *   client,
	 * });
	 *
	 * const transaction = prepareTransaction({
	 *   contract,
	 *   to: "0x...",
	 *   value: toWei("0.1"),
	 * });
	 *
	 * const { transactionHash } = await sendTransaction({
	 *  account,
	 *  transaction,
	 * });
	 * ```
	 *
	 * ### Gasless usage with [thirdweb Engine](https://portal.thirdweb.com/engine)
	 * ```ts
	 * const { transactionHash } = await sendTransaction({
	 *  account,
	 *  transaction,
	 *  gasless: {
	 *    provider: "engine",
	 *    relayerUrl: "https://thirdweb.engine-***.thirdweb.com/relayer/***",
	 *    relayerForwarderAddress: "0x...",
	 *  }
	 * });
	 * ```
	 *
	 * ### Gasless usage with OpenZeppelin
	 * ```ts
	 * const { transactionHash } = await sendTransaction({
	 *  account,
	 *  transaction,
	 *  gasless: {
	 *    provider: "openzeppelin",
	 *    relayerUrl: "https://...",
	 *    relayerForwarderAddress: "0x...",
	 *  }
	 * });
	 * ```
	 */
	async function sendTransaction(options) {
	    const { account, transaction, gasless } = options;
	    if (account.onTransactionRequested) {
	        await account.onTransactionRequested(transaction);
	    }
	    const serializableTransaction = await (0, to_serializable_transaction_js_1.toSerializableTransaction)({
	        transaction: transaction,
	        from: account.address,
	    });
	    // branch for gasless transactions
	    if (gasless) {
	        // lazy load the gasless tx function because it's only needed for gasless transactions
	        const { sendGaslessTransaction } = await Promise.resolve().then(() => requireSendGaslessTransaction());
	        return sendGaslessTransaction({
	            account,
	            transaction,
	            serializableTransaction,
	            gasless,
	        });
	    }
	    const result = await account.sendTransaction(serializableTransaction);
	    // Store the transaction
	    (0, transaction_store_js_1.addTransactionToStore)({
	        address: account.address,
	        transactionHash: result.transactionHash,
	        chainId: transaction.chain.id,
	    });
	    return { ...result, chain: transaction.chain, client: transaction.client };
	}

	var sendAndConfirmTransaction$1 = {};

	Object.defineProperty(sendAndConfirmTransaction$1, "__esModule", { value: true });
	sendAndConfirmTransaction$1.sendAndConfirmTransaction = sendAndConfirmTransaction;
	const send_transaction_js_1 = sendTransaction$1;
	const wait_for_tx_receipt_js_1 = waitForTxReceipt;
	/**
	 * Sends a transaction using the provided wallet.
	 * @param options - The options for sending the transaction.
	 * @returns A promise that resolves to the confirmed transaction receipt.
	 * @throws An error if the wallet is not connected.
	 * @transaction
	 * @example
	 *
	 * ### Basic usage
	 * ```ts
	 * import { sendAndConfirmTransaction } from "thirdweb";
	 *
	 * const transactionReceipt = await sendAndConfirmTransaction({
	 *  account,
	 *  transaction
	 * });
	 * ```
	 *
	 * ### Gasless usage with [thirdweb Engine](https://portal.thirdweb.com/engine)
	 * ```ts
	 * const transactionReceipt = await sendAndConfirmTransaction({
	 *  account,
	 *  transaction,
	 *  gasless: {
	 *    provider: "engine",
	 *    relayerUrl: "https://thirdweb.engine-***.thirdweb.com/relayer/***",
	 *    relayerForwarderAddress: "0x...",
	 *  }
	 * });
	 * ```
	 *
	 * ### Gasless usage with OpenZeppelin
	 * ```ts
	 * const transactionReceipt = await sendAndConfirmTransaction({
	 *  account,
	 *  transaction,
	 *  gasless: {
	 *    provider: "openzeppelin",
	 *    relayerUrl: "https://...",
	 *    relayerForwarderAddress: "0x...",
	 *  }
	 * });
	 * ```
	 */
	async function sendAndConfirmTransaction(options) {
	    const submittedTx = await (0, send_transaction_js_1.sendTransaction)(options);
	    return (0, wait_for_tx_receipt_js_1.waitForReceipt)(submittedTx);
	}

	var sendBatchTransaction$1 = {};

	Object.defineProperty(sendBatchTransaction$1, "__esModule", { value: true });
	sendBatchTransaction$1.sendBatchTransaction = sendBatchTransaction;
	const resolve_promised_value_js_1$1 = resolvePromisedValue$1;
	const encode_js_1$1 = encode$1;
	/**
	 * Sends a batch transaction using the provided options.
	 * @param options - The options for sending the batch transaction.
	 * @returns A promise that resolves to the options for waiting for the receipt of the first transaction in the batch.
	 * @throws An error if the account is not connected, there are no transactions to send, or the account does not implement sendBatchTransaction.
	 * @transaction
	 * @example
	 * ```ts
	 * import { sendBatchTransaction } from "thirdweb";
	 *
	 * const waitForReceiptOptions = await sendBatchTransaction({
	 *  account,
	 *  transactions
	 * });
	 * ```
	 */
	async function sendBatchTransaction(options) {
	    const { account, transactions } = options;
	    if (!account) {
	        throw new Error("not connected");
	    }
	    if (transactions.length === 0) {
	        throw new Error("No transactions to send");
	    }
	    const firstTx = transactions[0];
	    if (!firstTx) {
	        throw new Error("No transactions to send");
	    }
	    if (account.sendBatchTransaction) {
	        const serializedTxs = await Promise.all(transactions.map(async (tx) => {
	            // no need to estimate gas for these, gas will be estimated on the entire batch
	            const [data, to, accessList, value] = await Promise.all([
	                (0, encode_js_1$1.encode)(tx),
	                (0, resolve_promised_value_js_1$1.resolvePromisedValue)(tx.to),
	                (0, resolve_promised_value_js_1$1.resolvePromisedValue)(tx.accessList),
	                (0, resolve_promised_value_js_1$1.resolvePromisedValue)(tx.value),
	            ]);
	            const serializedTx = {
	                data,
	                chainId: tx.chain.id,
	                to,
	                value,
	                accessList,
	            };
	            return serializedTx;
	        }));
	        const result = await account.sendBatchTransaction(serializedTxs);
	        return {
	            ...result,
	            chain: firstTx.chain,
	            client: firstTx.client,
	        };
	    }
	    throw new Error("Account doesn't implement sendBatchTransaction");
	}

	var simulate = {};

	Object.defineProperty(simulate, "__esModule", { value: true });
	simulate.simulateTransaction = simulateTransaction;
	const viem_1$6 = _cjs;
	const eth_call_js_1$1 = eth_call$1;
	const rpc_js_1$2 = rpc$1;
	const resolve_promised_value_js_1 = resolvePromisedValue$1;
	const extract_error_js_1 = extractError;
	const encode_js_1 = encode$1;
	/**
	 * Simulates the execution of a transaction.
	 * @param options - The options for simulating the transaction.
	 * @returns A promise that resolves to the result of the simulation.
	 * @transaction
	 * @example
	 * ```ts
	 * import { simulateTransaction } from "thirdweb";
	 * const result = await simulateTransaction({
	 *  transaction,
	 * });
	 * ```
	 */
	async function simulateTransaction(options) {
	    const [data, to, accessList, value] = await Promise.all([
	        (0, encode_js_1.encode)(options.transaction),
	        (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.to),
	        (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.accessList),
	        (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.value),
	    ]);
	    // from is:
	    // 1. the user specified from address
	    // 2. the passed in account address
	    // 3. the passed in wallet's account address
	    const from = options.from ?? options.account?.address ?? undefined;
	    const serializedTx = (0, viem_1$6.formatTransactionRequest)({
	        data,
	        from,
	        to,
	        value,
	        accessList,
	    });
	    const rpcRequest = (0, rpc_js_1$2.getRpcClient)(options.transaction);
	    try {
	        const result = await (0, eth_call_js_1$1.eth_call)(rpcRequest, serializedTx);
	        if (!options.transaction.__preparedMethod) {
	            return result;
	        }
	        const prepared = await options.transaction.__preparedMethod();
	        const decoded = (0, viem_1$6.decodeAbiParameters)(prepared[2], result);
	        if (Array.isArray(decoded) && decoded.length === 1) {
	            return decoded[0];
	        }
	        return decoded;
	    }
	    catch (error) {
	        throw await (0, extract_error_js_1.extractError)({
	            error,
	            contract: options.transaction.__contract,
	        });
	    }
	}

	var signTransaction$1 = {};

	var sign$1 = {};

	Object.defineProperty(sign$1, "__esModule", { value: true });
	sign$1.sign = sign;
	const secp256k1_1 = secp256k1;
	const hex_js_1$2 = hex;
	/**
	 * Generates the signature for the provided transaction hash.
	 * @param options - The options for signing.
	 * @param options.hash - The hash to be signed.
	 * @param options.privateKey - The private key to sign the hash with.
	 * @returns The transaction signature.
	 * @example
	 * ```ts
	 * import { sign } from "thirdweb/utils";
	 *
	 * const signature = sign({
	 *   hash: "0x",
	 *   privateKey: "0x",
	 * });
	 * ```
	 * @utils
	 */
	function sign({ hash, privateKey }) {
	    const { r, s, recovery } = secp256k1_1.secp256k1.sign(hash.slice(2), privateKey.slice(2));
	    return {
	        r: (0, hex_js_1$2.toHex)(r, { size: 32 }),
	        s: (0, hex_js_1$2.toHex)(s, { size: 32 }),
	        v: recovery ? 28n : 27n,
	        yParity: recovery,
	    };
	}

	var serializeTransaction$1 = {};

	Object.defineProperty(serializeTransaction$1, "__esModule", { value: true });
	serializeTransaction$1.serializeTransaction = serializeTransaction;
	const viem_1$5 = _cjs;
	/**
	 * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.
	 *
	 * @param options - The serialization options.
	 * @param options.transaction - The transaction object to be serialized.
	 * @param [options.signature] - The signature to include with the transaction, if necessary.
	 * @returns The serialized transaction.
	 * @throws An error if the provided transaction object is invalid.
	 * @transaction
	 * @example
	 * ```ts
	 * import { serializeTransaction } from "thirdweb";
	 *
	 * const serializedTransaction = serializeTransaction({ transaction: {
	 *    to: "0x",
	 *    value: 0n,
	 *  }
	 * });
	 * ```
	 */
	function serializeTransaction(options) {
	    const { transaction } = options;
	    // This is to maintain compatibility with our old interface (including the signature in the transaction object)
	    const signature = (() => {
	        if (options.signature)
	            return options.signature;
	        if (transaction.v === undefined && transaction.yParity === undefined) {
	            return undefined;
	        }
	        if (transaction.r === undefined || transaction.s === undefined) {
	            throw new Error("Invalid signature provided with transaction");
	        }
	        return {
	            v: transaction.v,
	            r: transaction.r,
	            s: transaction.s,
	            yParity: transaction.yParity,
	        };
	    })();
	    return (0, viem_1$5.serializeTransaction)(transaction, signature); // Trust the options type-checking did its job and that the converted signature mirrors that type
	}

	Object.defineProperty(signTransaction$1, "__esModule", { value: true });
	signTransaction$1.signTransaction = signTransaction;
	const keccak256_js_1 = keccak256$1;
	const sign_js_1 = sign$1;
	const serialize_transaction_js_1 = serializeTransaction$1;
	/**
	 * Signs a transaction to be sent to a node.
	 * @param options The options for signing.
	 * @param options.transaction - The transaction object to sign
	 * @param options.privateKey - The account private key
	 * @returns The signed transaction as a hex string
	 * @example
	 * ```ts
	 * import { signTransaction } from "thirdweb";
	 * signTransaction({
	 *   transaction: {
	 *     ...
	 *   },
	 *   privateKey: "0x...",
	 * });
	 * ```
	 * @transaction
	 */
	function signTransaction({ transaction, privateKey, }) {
	    if (transaction.type === "eip4844") {
	        transaction = { ...transaction, sidecars: false };
	    }
	    const serializedTransaction = (0, serialize_transaction_js_1.serializeTransaction)({ transaction });
	    const signature = (0, sign_js_1.sign)({
	        hash: (0, keccak256_js_1.keccak256)(serializedTransaction),
	        privateKey: privateKey,
	    });
	    return (0, serialize_transaction_js_1.serializeTransaction)({
	        transaction: { ...transaction, ...signature },
	    });
	}

	var prepareEvent$1 = {};

	var utils = {};

	Object.defineProperty(utils, "__esModule", { value: true });
	utils.isAbiEvent = isAbiEvent;
	/**
	 * @internal
	 */
	function isAbiEvent(item) {
	    return !!(item &&
	        typeof item === "object" &&
	        "type" in item &&
	        item.type === "event");
	}

	Object.defineProperty(prepareEvent$1, "__esModule", { value: true });
	prepareEvent$1.prepareEvent = prepareEvent;
	const abitype_1 = exports$1;
	const viem_1$4 = _cjs;
	const utils_js_1$3 = utils;
	/**
	 * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.
	 * @param options - The options for preparing the event.
	 * @returns The prepared event object.
	 * @example
	 * ```ts
	 * import { prepareEvent } from "thirdweb";
	 * const myEvent = prepareEvent({
	 *  signature: "event MyEvent(uint256 myArg)",
	 * });
	 * ```
	 * @contract
	 */
	function prepareEvent(options) {
	    const { signature } = options;
	    let resolvedSignature;
	    if ((0, utils_js_1$3.isAbiEvent)(signature)) {
	        resolvedSignature = signature;
	    }
	    else {
	        resolvedSignature = (0, abitype_1.parseAbiItem)(signature);
	    }
	    return {
	        abiEvent: resolvedSignature,
	        hash: (0, viem_1$4.toEventHash)(resolvedSignature),
	        // @ts-expect-error - TODO: investiagte why this complains, it works fine however
	        topics: (0, viem_1$4.encodeEventTopics)({
	            abi: [resolvedSignature],
	            args: options.filters,
	        }),
	    };
	}

	var getEvents = {};

	var parseLogs = {};

	Object.defineProperty(parseLogs, "__esModule", { value: true });
	parseLogs.parseEventLogs = parseEventLogs;
	const viem_1$3 = _cjs;
	/**
	 * Parses logs and returns the corresponding events.
	 * @param options - The options for parsing logs.
	 * @returns The parsed events.
	 * @example
	 * ```ts
	 * import { parseEventLogs } from "thirdweb";
	 * const events = parseEventLogs({
	 *  logs,
	 *  events: [preparedEvent, preparedEvent2],
	 * });
	 * ```
	 * @contract
	 */
	function parseEventLogs(options) {
	    const { logs, events, strict } = options;
	    return (0, viem_1$3.parseEventLogs)({
	        logs,
	        abi: events.map((e) => e.abiEvent),
	        strict,
	    });
	}

	/**
	 * 1. blockTime + contract (with abi) + no events -> logs with types and parsing *if* contract has abi defined
	 * 2. blockTime + contract (no abi) + no events -> logs with NO types but *with* parsing
	 * 3. blockTime + no contract + events -> logs with types and parsing (across all "addresses") (no contract filter)
	 * 4. blockTime + contract + events -> logs with types and parsing (filtered by contract address +  event topics)
	 */
	Object.defineProperty(getEvents, "__esModule", { value: true });
	getEvents.getContractEvents = getContractEvents;
	const resolve_abi_js_1 = resolveAbi;
	const eth_blockNumber_js_1 = eth_blockNumber$1;
	const eth_getLogs_js_1 = eth_getLogs$1;
	const rpc_js_1$1 = rpc$1;
	const prepare_event_js_1 = prepareEvent$1;
	const utils_js_1$2 = utils;
	const parse_logs_js_1 = parseLogs;
	/**
	 * Retrieves events from a contract based on the provided options.
	 * @param options - The options for retrieving events.
	 * @returns A promise that resolves to an array of parsed event logs.
	 * Note: toBlock and fromBlock are both inclusive.
	 * @example
	 * ```ts
	 * import { getContractEvents } from "thirdweb";
	 * const events = await getContractEvents({
	 *  contract: myContract,
	 *  fromBlock: 123456n,
	 *  toBlock: 123456n,
	 *  events: [preparedEvent, preparedEvent2],
	 * });
	 * ```
	 * @example
	 * Optionally specify a blockRange as the number of blocks to retrieve. toBlock will default to the current block number.
	 * ```ts
	 * import { getContractEvents } from "thirdweb";
	 * const events = await getContractEvents({
	 *  contract: myContract,
	 *  blockRange: 123456n,
	 *  events: [preparedEvent, preparedEvent2],
	 * });
	 * ```
	 * @example
	 * Use fromBlock with blockRange for pagination.
	 * ```ts
	 * import { getContractEvents } from "thirdweb";
	 * const events = await getContractEvents({
	 *  contract: myContract,
	 *  fromBlock: lastBlockFetched,
	 *  blockRange: 123456n,
	 *  events: [preparedEvent, preparedEvent2],
	 * });
	 * ```
	 * @example
	 * Retrieve events for a specific block hash.
	 * ```ts
	 * import { getContractEvents } from "thirdweb";
	 * const events = await getContractEvents({
	 *  contract: myContract,
	 *  blockHash: "0x...",
	 *  events: [preparedEvent, preparedEvent2],
	 * });
	 * ```
	 * @contract
	 */
	async function getContractEvents(options) {
	    const { contract, events, blockRange, ...restParams } = options;
	    const rpcRequest = (0, rpc_js_1$1.getRpcClient)(contract);
	    if (restParams.blockHash &&
	        (blockRange || restParams.fromBlock || restParams.toBlock)) {
	        throw new Error("Cannot specify blockHash and range simultaneously,");
	    }
	    const latestBlockNumber = await (0, eth_blockNumber_js_1.eth_blockNumber)(rpcRequest);
	    // Compute toBlock and fromBlock if blockRange was passed
	    if (blockRange) {
	        const { fromBlock, toBlock } = restParams;
	        // Make sure the inputs were properly defined
	        if (fromBlock &&
	            toBlock &&
	            BigInt(toBlock) - BigInt(fromBlock) !== BigInt(blockRange)) {
	            throw new Error("Incompatible blockRange with specified fromBlock and toBlock. Please only define fromBlock or toBlock when specifying blockRange.");
	        }
	        if (fromBlock) {
	            restParams.toBlock = BigInt(fromBlock) + BigInt(blockRange) - 1n; // Subtract one because toBlock is inclusive
	        }
	        else if (toBlock) {
	            restParams.fromBlock = BigInt(toBlock) - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive
	        }
	        else {
	            // If no from or to block specified, use the latest block as the to block
	            restParams.toBlock = latestBlockNumber;
	            restParams.fromBlock = latestBlockNumber - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive
	        }
	    }
	    let resolvedEvents = events ?? [];
	    // if we have an abi on the contract, we can encode the topics with it
	    if (!events?.length && !!contract) {
	        // if we have a contract *WITH* an abi we can use that
	        if (contract.abi?.length) {
	            // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event
	            resolvedEvents = contract.abi
	                .filter(utils_js_1$2.isAbiEvent)
	                .map((abiEvent) => (0, prepare_event_js_1.prepareEvent)({ signature: abiEvent }));
	        }
	        else {
	            const runtimeAbi = await (0, resolve_abi_js_1.resolveContractAbi)(contract);
	            // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event
	            resolvedEvents = runtimeAbi
	                .filter(utils_js_1$2.isAbiEvent)
	                .map((abiEvent) => (0, prepare_event_js_1.prepareEvent)({ signature: abiEvent }));
	        }
	    }
	    const logsParams = events && events.length > 0
	        ? // if we have events passed in then we use those
	            events.map((e) => ({
	                ...restParams,
	                address: contract?.address,
	                topics: e.topics,
	            }))
	        : // otherwise we want "all" events (aka not pass any topics at all)
	            [{ ...restParams, address: contract?.address }];
	    const logs = await Promise.all(logsParams.map((ethLogParams) => (0, eth_getLogs_js_1.eth_getLogs)(rpcRequest, ethLogParams)));
	    const flattenLogs = logs
	        .flat()
	        .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));
	    return (0, parse_logs_js_1.parseEventLogs)({
	        logs: flattenLogs,
	        events: resolvedEvents,
	    });
	}

	var watchEvents = {};

	var retry$1 = {};

	/**
	 * Attempts to execute a function that returns a promise and retries if the function throws an error.
	 *
	 * @param {Function} fn - A function that returns a promise to be executed.
	 * @param {Object} options - Configuration options for the retry behavior.
	 * @param {number} [options.retries=1] - The number of times to retry the function before failing.
	 * @param {number} [options.delay=0] - The delay in milliseconds between retries.
	 * @returns {Promise<void>} The result of the function execution if successful.
	 */
	Object.defineProperty(retry$1, "__esModule", { value: true });
	retry$1.retry = retry;
	async function retry(fn, options) {
	    const retries = options.retries ?? 1;
	    const delay = options.delay ?? 0;
	    let lastError = null;
	    for (let i = 0; i < retries; i++) {
	        try {
	            return await fn();
	        }
	        catch (error) {
	            lastError = error;
	            if (delay > 0) {
	                await new Promise((resolve) => setTimeout(resolve, delay));
	            }
	        }
	    }
	    throw lastError;
	}

	Object.defineProperty(watchEvents, "__esModule", { value: true });
	watchEvents.watchContractEvents = watchContractEvents;
	const get_events_js_1 = getEvents;
	const watchBlockNumber_js_1 = watchBlockNumber$3;
	const retry_js_1 = retry$1;
	/**
	 * Listens for  contract events from the blockchain.
	 * @param options - The options for retrieving contract events.
	 * @returns The unwatch function.
	 * @example
	 * ### Listen to all events for a contract
	 * ```ts
	 * import { watchContractEvents } from "thirdweb";
	 * const unwatch = watchContractEvents({
	 *  contract: myContract,
	 *  onEvents: (events) => {
	 *   // do something with the events
	 *  },
	 * });
	 * ```
	 *
	 * ### Listen to specific events for a contract
	 * ```ts
	 * import { prepareEvent, watchContractEvents } from "thirdweb";
	 * const myEvent = prepareEvent({
	 *  event: "event MyEvent(uint256 myArg)",
	 * });
	 * const events = await watchContractEvents({
	 *  contract: myContract,
	 *  events: [myEvent],
	 *  onEvents: (events) => {
	 *   // do something with the events
	 *  },
	 * });
	 * ```
	 * @contract
	 */
	function watchContractEvents(options) {
	    // returning this returns the underlying "unwatch" function
	    return (0, watchBlockNumber_js_1.watchBlockNumber)({
	        ...options.contract,
	        /**
	         * This function is called every time a new block is mined.
	         * @param blockNumber - The block number of the new block.
	         * @returns A promise that resolves when the function is finished.
	         * @internal
	         */
	        onNewBlockNumber: async (blockNumber) => {
	            const logs = await (0, retry_js_1.retry)(async () => (0, get_events_js_1.getContractEvents)({
	                ...options,
	                // fromBlock is inclusive
	                fromBlock: blockNumber,
	                // toBlock is inclusive
	                toBlock: blockNumber,
	            }), {
	                retries: 3,
	                delay: 500,
	            });
	            // if there were any logs associated with our event(s)
	            if (logs.length) {
	                options.onEvents(logs);
	            }
	        },
	        latestBlockNumber: options.latestBlockNumber,
	    });
	}

	var getQuote = {};

	var approve$2 = {};

	var approve$1 = {};

	var once$1 = {};

	Object.defineProperty(once$1, "__esModule", { value: true });
	once$1.once = once;
	function once(fn) {
	    let result;
	    return () => {
	        if (!result) {
	            result = fn();
	        }
	        return result;
	    };
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FN_SELECTOR = void 0;
		exports.isApproveSupported = isApproveSupported;
		exports.encodeApproveParams = encodeApproveParams;
		exports.encodeApprove = encodeApprove;
		exports.approve = approve;
		const prepare_contract_call_js_1 = prepareContractCall$1;
		const encodeAbiParameters_js_1 = encodeAbiParameters$1;
		const once_js_1 = once$1;
		const detectExtension_js_1 = detectExtension;
		exports.FN_SELECTOR = "0x095ea7b3";
		const FN_INPUTS = [
		    {
		        type: "address",
		        name: "spender",
		    },
		    {
		        type: "uint256",
		        name: "value",
		    },
		];
		const FN_OUTPUTS = [
		    {
		        type: "bool",
		    },
		];
		/**
		 * Checks if the `approve` method is supported by the given contract.
		 * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using "whatsabi" or if you have the ABI of the contract available you can use it to generate the selectors.
		 * @returns A boolean indicating if the `approve` method is supported.
		 * @extension ERC20
		 * @example
		 * ```ts
		 * import { isApproveSupported } from "thirdweb/extensions/erc20";
		 *
		 * const supported = isApproveSupported(["0x..."]);
		 * ```
		 */
		function isApproveSupported(availableSelectors) {
		    return (0, detectExtension_js_1.detectMethod)({
		        availableSelectors,
		        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
		    });
		}
		/**
		 * Encodes the parameters for the "approve" function.
		 * @param options - The options for the approve function.
		 * @returns The encoded ABI parameters.
		 * @extension ERC20
		 * @example
		 * ```ts
		 * import { encodeApproveParams } "thirdweb/extensions/erc20";
		 * const result = encodeApproveParams({
		 *  spender: ...,
		 *  value: ...,
		 * });
		 * ```
		 */
		function encodeApproveParams(options) {
		    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(FN_INPUTS, [options.spender, options.value]);
		}
		/**
		 * Encodes the "approve" function into a Hex string with its parameters.
		 * @param options - The options for the approve function.
		 * @returns The encoded hexadecimal string.
		 * @extension ERC20
		 * @example
		 * ```ts
		 * import { encodeApprove } "thirdweb/extensions/erc20";
		 * const result = encodeApprove({
		 *  spender: ...,
		 *  value: ...,
		 * });
		 * ```
		 */
		function encodeApprove(options) {
		    // we do a "manual" concat here to avoid the overhead of the "concatHex" function
		    // we can do this because we know the specific formats of the values
		    return (exports.FN_SELECTOR +
		        encodeApproveParams(options).slice(2));
		}
		/**
		 * Prepares a transaction to call the "approve" function on the contract.
		 * @param options - The options for the "approve" function.
		 * @returns A prepared transaction object.
		 * @extension ERC20
		 * @example
		 * ```ts
		 * import { approve } from "thirdweb/extensions/erc20";
		 *
		 * const transaction = approve({
		 *  contract,
		 *  spender: ...,
		 *  value: ...,
		 *  overrides: {
		 *    ...
		 *  }
		 * });
		 *
		 * // Send the transaction
		 * ...
		 *
		 * ```
		 */
		function approve(options) {
		    const asyncOptions = (0, once_js_1.once)(async () => {
		        return "asyncParams" in options ? await options.asyncParams() : options;
		    });
		    return (0, prepare_contract_call_js_1.prepareContractCall)({
		        contract: options.contract,
		        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
		        params: async () => {
		            const resolvedOptions = await asyncOptions();
		            return [resolvedOptions.spender, resolvedOptions.value];
		        },
		        value: async () => (await asyncOptions()).overrides?.value,
		        accessList: async () => (await asyncOptions()).overrides?.accessList,
		        gas: async () => (await asyncOptions()).overrides?.gas,
		        gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,
		        maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,
		        maxPriorityFeePerGas: async () => (await asyncOptions()).overrides?.maxPriorityFeePerGas,
		        nonce: async () => (await asyncOptions()).overrides?.nonce,
		        extraGas: async () => (await asyncOptions()).overrides?.extraGas,
		        erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,
		    });
		}
		
	} (approve$1));

	var decimals$1 = {};

	var decimals = {};

	var hasRequiredDecimals$1;

	function requireDecimals$1 () {
		if (hasRequiredDecimals$1) return decimals;
		hasRequiredDecimals$1 = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.FN_SELECTOR = void 0;
			exports.isDecimalsSupported = isDecimalsSupported;
			exports.decodeDecimalsResult = decodeDecimalsResult;
			exports.decimals = decimals;
			const read_contract_js_1 = readContract$1;
			const viem_1 = _cjs;
			const detectExtension_js_1 = detectExtension;
			exports.FN_SELECTOR = "0x313ce567";
			const FN_INPUTS = [];
			const FN_OUTPUTS = [
			    {
			        type: "uint8",
			    },
			];
			/**
			 * Checks if the `decimals` method is supported by the given contract.
			 * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using "whatsabi" or if you have the ABI of the contract available you can use it to generate the selectors.
			 * @returns A boolean indicating if the `decimals` method is supported.
			 * @extension ERC20
			 * @example
			 * ```ts
			 * import { isDecimalsSupported } from "thirdweb/extensions/erc20";
			 *
			 * const supported = isDecimalsSupported(["0x..."]);
			 * ```
			 */
			function isDecimalsSupported(availableSelectors) {
			    return (0, detectExtension_js_1.detectMethod)({
			        availableSelectors,
			        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
			    });
			}
			/**
			 * Decodes the result of the decimals function call.
			 * @param result - The hexadecimal result to decode.
			 * @returns The decoded result as per the FN_OUTPUTS definition.
			 * @extension ERC20
			 * @example
			 * ```ts
			 * import { decodeDecimalsResult } from "thirdweb/extensions/erc20";
			 * const result = decodeDecimalsResult("...");
			 * ```
			 */
			function decodeDecimalsResult(result) {
			    return (0, viem_1.decodeAbiParameters)(FN_OUTPUTS, result)[0];
			}
			/**
			 * Calls the "decimals" function on the contract.
			 * @param options - The options for the decimals function.
			 * @returns The parsed result of the function call.
			 * @extension ERC20
			 * @example
			 * ```ts
			 * import { decimals } from "thirdweb/extensions/erc20";
			 *
			 * const result = await decimals({
			 *  contract,
			 * });
			 *
			 * ```
			 */
			async function decimals(options) {
			    return (0, read_contract_js_1.readContract)({
			        contract: options.contract,
			        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
			        params: [],
			    });
			}
			
		} (decimals));
		return decimals;
	}

	var hasRequiredDecimals;

	function requireDecimals () {
		if (hasRequiredDecimals) return decimals$1;
		hasRequiredDecimals = 1;
		Object.defineProperty(decimals$1, "__esModule", { value: true });
		decimals$1.decimals = decimals;
		const withCache_js_1 = withCache$2;
		const decimals_js_1 = requireDecimals$1();
		/**
		 * Retrieves the number of decimal places for a given ERC20 contract.
		 * @param options - The options for the transaction.
		 * @returns A promise that resolves to the number of decimal places.
		 * @extension ERC20
		 * @example
		 * ```ts
		 * import { decimals } from "thirdweb/extensions/erc20";
		 *
		 * const tokenDecimals = await decimals({ contract });
		 * ```
		 */
		async function decimals(options) {
		    return (0, withCache_js_1.withCache)(() => (0, decimals_js_1.decimals)(options), {
		        cacheKey: `${options.contract.chain.id}:${options.contract.address}:decimals`,
		        // can never change, so cache forever
		        cacheTime: Number.POSITIVE_INFINITY,
		    });
		}
		
		return decimals$1;
	}

	Object.defineProperty(approve$2, "__esModule", { value: true });
	approve$2.approve = approve;
	const units_js_1 = units;
	const approve_js_1$2 = approve$1;
	/**
	 * Approves the spending of tokens by a specific address.
	 * @param options - The transaction options.
	 * @returns A prepared transaction object.
	 * @extension ERC20
	 * @example
	 * ```ts
	 * import { approve } from "thirdweb/extensions/erc20";
	 * import { sendTransaction } from "thirdweb";
	 *
	 * const transaction = await approve({
	 *  contract,
	 *  spender: "0x...",
	 *  amount: 100,
	 * });
	 *
	 * await sendTransaction({ transaction, account });
	 * ```
	 */
	function approve(options) {
	    return (0, approve_js_1$2.approve)({
	        contract: options.contract,
	        asyncParams: async () => {
	            let amount;
	            if ("amount" in options) {
	                // if we need to parse the amount from ether to gwei then we pull in the decimals extension
	                const { decimals } = await Promise.resolve().then(() => requireDecimals());
	                // if this fails we fall back to `18` decimals
	                const d = await decimals(options).catch(() => 18);
	                // turn ether into gwei
	                amount = (0, units_js_1.toUnits)(options.amount.toString(), d);
	            }
	            else {
	                amount = options.amountWei;
	            }
	            return {
	                spender: options.spender,
	                value: amount,
	                overrides: {
	                    erc20Value: {
	                        amountWei: amount,
	                        tokenAddress: options.contract.address,
	                    },
	                },
	            };
	        },
	    });
	}

	var definitions = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getPayBuyHistoryEndpoint = exports.getPaySupportedSources = exports.getPaySupportedDestinations = exports.getPayBuyWithCryptoHistoryEndpoint = exports.getPayBuyWithFiatHistoryEndpoint = exports.getPayBuyWithFiatStatusEndpoint = exports.getPayBuyWithFiatQuoteEndpoint = exports.getPayBuyWithCryptoTransferEndpoint = exports.getPayBuyWithCryptoQuoteEndpoint = exports.getPayBuyWithCryptoStatusUrl = exports.getPayBaseUrl = void 0;
		const domains_js_1 = domains;
		const getPayBaseUrl = () => {
		    const payDomain = (0, domains_js_1.getThirdwebDomains)().pay;
		    return payDomain.startsWith("localhost")
		        ? `http://${payDomain}`
		        : `https://${payDomain}`;
		};
		exports.getPayBaseUrl = getPayBaseUrl;
		/**
		 * Endpoint to get the status of a "Buy with Crypto" quote.
		 * @internal
		 */
		const getPayBuyWithCryptoStatusUrl = () => `${(0, exports.getPayBaseUrl)()}/buy-with-crypto/status/v1`;
		exports.getPayBuyWithCryptoStatusUrl = getPayBuyWithCryptoStatusUrl;
		/**
		 * Endpoint to get "Buy with Crypto" quote.
		 * @internal
		 */
		const getPayBuyWithCryptoQuoteEndpoint = () => `${(0, exports.getPayBaseUrl)()}/buy-with-crypto/quote/v1`;
		exports.getPayBuyWithCryptoQuoteEndpoint = getPayBuyWithCryptoQuoteEndpoint;
		/**
		 * Endpoint to get "Buy with Crypto" transfer.
		 * @internal
		 */
		const getPayBuyWithCryptoTransferEndpoint = () => `${(0, exports.getPayBaseUrl)()}/buy-with-crypto/transfer/v1`;
		exports.getPayBuyWithCryptoTransferEndpoint = getPayBuyWithCryptoTransferEndpoint;
		/**
		 * Endpoint to get a "Buy with Fiat" quote.
		 * @internal
		 */
		const getPayBuyWithFiatQuoteEndpoint = () => `${(0, exports.getPayBaseUrl)()}/buy-with-fiat/quote/v1`;
		exports.getPayBuyWithFiatQuoteEndpoint = getPayBuyWithFiatQuoteEndpoint;
		/**
		 * Endpoint to get the status of a "Buy with Fiat" transaction status.
		 * @internal
		 */
		const getPayBuyWithFiatStatusEndpoint = () => `${(0, exports.getPayBaseUrl)()}/buy-with-fiat/status/v1`;
		exports.getPayBuyWithFiatStatusEndpoint = getPayBuyWithFiatStatusEndpoint;
		/**
		 * Endpoint to get history of "Buy with Fiat" transactions for given wallet address.
		 * @internal
		 */
		const getPayBuyWithFiatHistoryEndpoint = () => `${(0, exports.getPayBaseUrl)()}/buy-with-fiat/history/v1`;
		exports.getPayBuyWithFiatHistoryEndpoint = getPayBuyWithFiatHistoryEndpoint;
		/**
		 * Endpoint to get a "Buy with Crypto" transaction history for a given wallet address.
		 * @internal
		 */
		const getPayBuyWithCryptoHistoryEndpoint = () => `${(0, exports.getPayBaseUrl)()}/buy-with-crypto/history/v1`;
		exports.getPayBuyWithCryptoHistoryEndpoint = getPayBuyWithCryptoHistoryEndpoint;
		/**
		 * Endpoint to get a list of supported destination chains and tokens for thirdweb pay.
		 * @internal
		 */
		const getPaySupportedDestinations = () => `${(0, exports.getPayBaseUrl)()}/destination-tokens/v1`;
		exports.getPaySupportedDestinations = getPaySupportedDestinations;
		/**
		 * Endpoint to get a list of supported source chains + tokens for thirdweb pay.
		 * @internal
		 */
		const getPaySupportedSources = () => `${(0, exports.getPayBaseUrl)()}/buy-with-crypto/source-tokens/v1`;
		exports.getPaySupportedSources = getPaySupportedSources;
		/**
		 * Endpoint to get buy history for a given wallet address.
		 * This includes both "Buy with Crypto" and "Buy with Fiat" transactions.
		 * @internal
		 */
		const getPayBuyHistoryEndpoint = () => `${(0, exports.getPayBaseUrl)()}/wallet/history/v1`;
		exports.getPayBuyHistoryEndpoint = getPayBuyHistoryEndpoint;
		
	} (definitions));

	Object.defineProperty(getQuote, "__esModule", { value: true });
	getQuote.getBuyWithCryptoQuote = getBuyWithCryptoQuote;
	const utils_js_1$1 = utils$7;
	const contract_js_1$2 = contract;
	const approve_js_1$1 = approve$2;
	const fetch_js_1$5 = fetch$1;
	const definitions_js_1$3 = definitions;
	/**
	 * Get a quote of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote) to buy any given token with crypto.
	 * This quote contains the information about the swap such as token amounts, processing fees, estimated time etc.
	 *
	 * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.
	 * @param params - object of type [`GetBuyWithCryptoQuoteParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoQuoteParams)
	 * @returns Object of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote) which contains the information about the quote such as processing fees, estimated time, converted token amounts, etc.
	 * @example
	 *
	 * ```ts
	 * import { getBuyWithCryptoQuote } from "thirdweb/pay";
	 *
	 * const quote = await getBuyWithCryptoQuote({
	 *  client,
	 *  fromAddress: "0x...", // wallet address
	 *  fromChainId: 137, // chain id of the source token
	 *  fromTokenAddress: "0x...", // token address of the source token
	 *  fromAmount: "10", // amount of source token to swap
	 *  // optionally, you can use `toAmount` instead if you only want a certain amount of destination token
	 *  toChainId: 10, // chain id of the destination token
	 *  toTokenAddress: "0x...", // token address of the destination token
	 *  toAddress: "0x...", // optional: send the tokens to a different address
	 *  maxSlippageBPS: 50, // optional: max 0.5% slippage
	 * });
	 * ```
	 * @buyCrypto
	 */
	async function getBuyWithCryptoQuote(params) {
	    try {
	        const clientFetch = (0, fetch_js_1$5.getClientFetch)(params.client);
	        const response = await clientFetch((0, definitions_js_1$3.getPayBuyWithCryptoQuoteEndpoint)(), {
	            method: "POST",
	            headers: {
	                Accept: "application/json",
	                "Content-Type": "application/json",
	            },
	            body: JSON.stringify({
	                fromAddress: params.fromAddress,
	                toAddress: params.toAddress,
	                fromChainId: params.fromChainId.toString(),
	                fromTokenAddress: params.fromTokenAddress,
	                toChainId: params.toChainId.toString(),
	                toTokenAddress: params.toTokenAddress,
	                fromAmount: params.fromAmount,
	                toAmount: params.toAmount,
	                maxSlippageBPS: params.maxSlippageBPS,
	                intentId: params.intentId,
	                purchaseData: params.purchaseData,
	            }),
	        });
	        // Assuming the response directly matches the SwapResponse interface
	        if (!response.ok) {
	            const errorObj = await response.json();
	            if (errorObj && "error" in errorObj) {
	                throw errorObj;
	            }
	            throw new Error(`HTTP error! status: ${response.status}`);
	        }
	        const data = (await response.json())
	            .result;
	        const swapRoute = {
	            transactionRequest: {
	                chain: (0, utils_js_1$1.getCachedChain)(data.transactionRequest.chainId),
	                client: params.client,
	                data: data.transactionRequest.data,
	                to: data.transactionRequest.to,
	                value: BigInt(data.transactionRequest.value),
	                gas: BigInt(data.transactionRequest.gasLimit),
	                gasPrice: BigInt(data.transactionRequest.gasPrice),
	            },
	            approval: data.approval
	                ? (0, approve_js_1$1.approve)({
	                    contract: (0, contract_js_1$2.getContract)({
	                        client: params.client,
	                        address: data.approval.tokenAddress,
	                        chain: (0, utils_js_1$1.getCachedChain)(data.approval.chainId),
	                    }),
	                    spender: data.approval?.spenderAddress,
	                    amountWei: BigInt(data.approval.amountWei),
	                })
	                : undefined,
	            swapDetails: {
	                fromAddress: data.fromAddress,
	                toAddress: data.toAddress,
	                fromToken: data.fromToken,
	                toToken: data.toToken,
	                fromAmount: data.fromAmount,
	                fromAmountWei: data.fromAmountWei,
	                toAmountMinWei: data.toAmountMinWei,
	                toAmountMin: data.toAmountMin,
	                toAmountWei: data.toAmountWei,
	                toAmount: data.toAmount,
	                estimated: data.estimated,
	                maxSlippageBPS: data.maxSlippageBPS,
	            },
	            paymentTokens: data.paymentTokens,
	            processingFees: data.processingFees,
	            client: params.client,
	        };
	        return swapRoute;
	    }
	    catch (error) {
	        console.error("Error getting buy with crypto quote", error);
	        throw error;
	    }
	}

	var getStatus = {};

	Object.defineProperty(getStatus, "__esModule", { value: true });
	getStatus.getBuyWithCryptoStatus = getBuyWithCryptoStatus;
	const fetch_js_1$4 = fetch$1;
	const definitions_js_1$2 = definitions;
	/**
	 * Gets the status of a buy with crypto transaction
	 * @param buyWithCryptoTransaction - Object of type [`BuyWithCryptoTransaction`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransaction)
	 * @example
	 *
	 * ```ts
	 * import { sendTransaction } from "thirdweb";
	 * import { getBuyWithCryptoStatus, getBuyWithCryptoQuote } from "thirdweb/pay";
	 *
	 * // get a quote between two tokens
	 * const quote = await getBuyWithCryptoQuote(quoteParams);
	 *
	 * // if approval is required, send the approval transaction
	 * if (quote.approval) {
	 *  const txResult = await sendTransaction({
	 *    transaction: quote.approval,
	 *    account: account, // account from connected wallet
	 *  });
	 *
	 *  await waitForReceipt(txResult);
	 * }
	 *
	 * // send the quoted transaction
	 * const swapTxResult = await sendTransaction({
	 *    transaction: quote.transactionRequest,
	 *    account: account, // account from connected wallet
	 *  });
	 *
	 * await waitForReceipt(swapTxResult);
	 *
	 * // keep polling the status of the quoted transaction until it returns a success or failure status
	 * const status = await getBuyWithCryptoStatus({
	 *    client,
	 *    transactionHash: swapTxResult.transactionHash,
	 * }});
	 * ```
	 * @returns Object of type [`BuyWithCryptoStatus`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoStatus)
	 * @buyCrypto
	 */
	async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
	    try {
	        if (!buyWithCryptoTransaction.transactionHash) {
	            throw new Error("Transaction hash is required");
	        }
	        const queryString = new URLSearchParams({
	            transactionHash: buyWithCryptoTransaction.transactionHash,
	        }).toString();
	        const url = `${(0, definitions_js_1$2.getPayBuyWithCryptoStatusUrl)()}?${queryString}`;
	        const response = await (0, fetch_js_1$4.getClientFetch)(buyWithCryptoTransaction.client)(url);
	        // Assuming the response directly matches the BuyWithCryptoStatus interface
	        if (!response.ok) {
	            response.body?.cancel();
	            throw new Error(`HTTP error! status: ${response.status}`);
	        }
	        const data = (await response.json()).result;
	        return data;
	    }
	    catch (error) {
	        console.error("Fetch error:", error);
	        throw new Error(`Fetch failed: ${error}`);
	    }
	}

	var getHistory = {};

	Object.defineProperty(getHistory, "__esModule", { value: true });
	getHistory.getBuyWithCryptoHistory = getBuyWithCryptoHistory;
	const fetch_js_1$3 = fetch$1;
	const definitions_js_1$1 = definitions;
	/**
	 * Gets the History of purchases for a given wallet address
	 * @param params Object of type [`BuyWithCryptoHistoryParams`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoHistoryParams)
	 * @example
	 *
	 * ```ts
	 * import { createThirdwebClient } from "thirdweb";
	 * import { BuyWithCryptoHistoryData } from "thirdweb/pay";
	 *
	 * const client = createThirdwebClient({ clientId: "..." });
	 * const walletAddress = "0x...";
	 * const params = {
	 *  client,
	 *  walletAddress,
	 * };
	 *
	 * // grabs the history of purchase transactions for the wallet address
	 * const status = await getBuyWithCryptoHistory(params)
	 * ```
	 * @returns Object of type [`BuyWithCryptoHistoryData`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoHistoryData)
	 * @buyCrypto
	 */
	async function getBuyWithCryptoHistory(params) {
	    try {
	        const queryParams = new URLSearchParams();
	        queryParams.append("walletAddress", params.walletAddress);
	        queryParams.append("start", params.start.toString());
	        queryParams.append("count", params.count.toString());
	        const queryString = queryParams.toString();
	        const url = `${(0, definitions_js_1$1.getPayBuyWithCryptoHistoryEndpoint)()}?${queryString}`;
	        const response = await (0, fetch_js_1$3.getClientFetch)(params.client)(url);
	        // Assuming the response directly matches the SwapResponse interface
	        if (!response.ok) {
	            response.body?.cancel();
	            throw new Error(`HTTP error! status: ${response.status}`);
	        }
	        const data = (await response.json()).result;
	        return data;
	    }
	    catch (error) {
	        throw new Error(`Fetch failed: ${error}`);
	    }
	}

	var getTransfer = {};

	Object.defineProperty(getTransfer, "__esModule", { value: true });
	getTransfer.getBuyWithCryptoTransfer = getBuyWithCryptoTransfer;
	const utils_js_1 = utils$7;
	const contract_js_1$1 = contract;
	const approve_js_1 = approve$2;
	const fetch_js_1$2 = fetch$1;
	const definitions_js_1 = definitions;
	/**
	 * Get a quote of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) to facilitate a token transfer transaction.
	 * Using this instead of a native transfer allows you to receive status and webhooks about successful or failed payments.
	 *
	 * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.
	 * @param params - object of type [`GetBuyWithCryptoTransferParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoTransferParams)
	 * @returns Object of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) which contains the information about the transfer
	 * @example
	 *
	 * ```ts
	 * import { getBuyWithCryptoTransfer } from "thirdweb/pay";
	 *
	 * const transfer = await getBuyWithCryptoTransfer({
	 *  client,
	 *  fromAddress: "0x...", // wallet address
	 *  toAddress: "0x...", // recipient address - likely to be your wallet
	 *  chainId: 10, // chain id of the token
	 *  tokenAddress: "0x...", // address of the token
	 *  amount: "10", // amount of token to transfer
	 *  purchaseData: {  // any metadata for you to attribute this purchase
	 *    "customerId": "yourId"
	 *  }
	 * });
	 * ```
	 * @buyCrypto
	 */
	async function getBuyWithCryptoTransfer(params) {
	    try {
	        const clientFetch = (0, fetch_js_1$2.getClientFetch)(params.client);
	        const response = await clientFetch((0, definitions_js_1.getPayBuyWithCryptoTransferEndpoint)(), {
	            method: "POST",
	            headers: {
	                Accept: "application/json",
	                "Content-Type": "application/json",
	            },
	            body: JSON.stringify({
	                fromAddress: params.fromAddress,
	                toAddress: params.toAddress,
	                chainId: params.chainId,
	                tokenAddress: params.tokenAddress,
	                amount: params.amount,
	                purchaseData: params.purchaseData,
	            }),
	        });
	        if (!response.ok) {
	            const errorObj = await response.json();
	            if (errorObj && "error" in errorObj) {
	                throw errorObj;
	            }
	            throw new Error(`HTTP error! status: ${response.status}`);
	        }
	        const data = (await response.json()).result;
	        const transfer = {
	            transactionRequest: {
	                chain: (0, utils_js_1.getCachedChain)(data.transactionRequest.chainId),
	                client: params.client,
	                data: data.transactionRequest.data,
	                to: data.transactionRequest.to,
	                value: BigInt(data.transactionRequest.value),
	                gas: BigInt(data.transactionRequest.gasLimit),
	            },
	            approval: data.approval
	                ? (0, approve_js_1.approve)({
	                    contract: (0, contract_js_1$1.getContract)({
	                        client: params.client,
	                        address: data.approval.tokenAddress,
	                        chain: (0, utils_js_1.getCachedChain)(data.approval.chainId),
	                    }),
	                    spender: data.approval.spenderAddress,
	                    amountWei: BigInt(data.approval.amountWei),
	                })
	                : undefined,
	            fromAddress: data.fromAddress,
	            toAddress: data.toAddress,
	            paymentToken: data.paymentToken,
	            processingFee: data.processingFee,
	            estimatedGasCostUSDCents: data.estimatedGasCostUSDCents,
	            client: params.client,
	        };
	        return transfer;
	    }
	    catch (error) {
	        console.error("Error getting buy with crypto transfer", error);
	        throw error;
	    }
	}

	var fromBytes$1 = {};

	var trim$1 = {};

	Object.defineProperty(trim$1, "__esModule", { value: true });
	trim$1.trim = trim;
	/**
	 * Trims leading or trailing zeros from a hexadecimal string or byte array.
	 *
	 * @param hexOrBytes - The hexadecimal string or byte array to trim.
	 * @param options - The options for trimming. Default is to trim leading zeros.
	 * @returns The trimmed hexadecimal string or byte array.
	 * @internal
	 */
	function trim(hexOrBytes, { dir = "left" } = {}) {
	    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
	    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
	    let sliceLength = 0;
	    for (let i = 0; i < data.length - 1; i++) {
	        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") {
	            sliceLength++;
	        }
	        else {
	            break;
	        }
	    }
	    data =
	        dir === "left"
	            ? data.slice(sliceLength)
	            : data.slice(0, data.length - sliceLength);
	    if (typeof hexOrBytes === "string") {
	        if (data.length === 1 && dir === "right") {
	            data = `${data}0`;
	        }
	        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
	    }
	    return data;
	}

	Object.defineProperty(fromBytes$1, "__esModule", { value: true });
	fromBytes$1.fromBytes = fromBytes;
	fromBytes$1.bytesToBigInt = bytesToBigInt;
	fromBytes$1.bytesToBool = bytesToBool;
	fromBytes$1.bytesToNumber = bytesToNumber;
	fromBytes$1.bytesToString = bytesToString;
	const assert_size_js_1 = assertSize$1;
	const trim_js_1 = trim$1;
	const hex_js_1$1 = hex;
	/**
	 * Converts a Uint8Array to the specified type.
	 * @param bytes - The Uint8Array to convert.
	 * @param toOrOpts - The target type or conversion options.
	 * @returns The converted value of the specified type.
	 * @example
	 * ```ts
	 * import { fromBytes } from "thirdweb/utils";
	 * const bytes = new Uint8Array([1, 164]);
	 * const number = fromBytes(bytes, "number");
	 * console.log(number); // 420
	 * ```
	 * @utils
	 */
	function fromBytes(bytes, toOrOpts) {
	    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
	    switch (opts.to) {
	        case "number":
	            return bytesToNumber(bytes, opts);
	        case "bigint":
	            return bytesToBigInt(bytes, opts);
	        case "boolean":
	            return bytesToBool(bytes, opts);
	        case "string":
	            return bytesToString(bytes, opts);
	        default:
	            return (0, hex_js_1$1.uint8ArrayToHex)(bytes, opts);
	    }
	}
	/**
	 * Converts a Uint8Array of bytes to a bigint.
	 * @param bytes - The Uint8Array of bytes to convert.
	 * @param opts - Optional parameters for the conversion.
	 * @returns The converted bigint.
	 * @example
	 * ```ts
	 * import { bytesToBigInt } from "thirdweb/utils";
	 * const bytes = new Uint8Array([1, 164]);
	 * const bigInt = bytesToBigInt(bytes);
	 * console.log(bigInt); // 420n
	 * ```
	 * @utils
	 */
	function bytesToBigInt(bytes, opts = {}) {
	    if (typeof opts.size !== "undefined") {
	        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
	    }
	    const hex = (0, hex_js_1$1.uint8ArrayToHex)(bytes, opts);
	    return (0, hex_js_1$1.hexToBigInt)(hex, opts);
	}
	/**
	 * Converts a byte array to a boolean value.
	 * @param bytes_ - The byte array to convert.
	 * @param opts - Optional parameters for the conversion.
	 * @returns The boolean value converted from the byte array.
	 * @throws Error if the byte array is invalid or the boolean representation is invalid.
	 * @example
	 * ```ts
	 * import { bytesToBool } from "thirdweb/utils";
	 * const bytes = new Uint8Array([1]);
	 * const bool = bytesToBool(bytes);
	 * console.log(bool); // true
	 * ```
	 * @utils
	 */
	function bytesToBool(bytes_, opts = {}) {
	    let bytes = bytes_;
	    if (typeof opts.size !== "undefined") {
	        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
	        bytes = (0, trim_js_1.trim)(bytes);
	    }
	    if (bytes.length > 1 || (bytes[0] && bytes[0] > 1)) {
	        throw new Error(`Invalid boolean representation: ${bytes}`);
	    }
	    return Boolean(bytes[0]);
	}
	/**
	 * Converts a Uint8Array of bytes to a number.
	 * @param bytes - The Uint8Array of bytes to convert.
	 * @param opts - Optional configuration options.
	 * @returns The converted number.
	 * @example
	 * ```ts
	 * import { bytesToNumber } from "thirdweb/utils";
	 * const bytes = new Uint8Array([1, 164]);
	 * const number = bytesToNumber(bytes);
	 * console.log(number); // 420
	 * ```
	 * @utils
	 */
	function bytesToNumber(bytes, opts = {}) {
	    if (typeof opts.size !== "undefined") {
	        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
	    }
	    const hex = (0, hex_js_1$1.uint8ArrayToHex)(bytes, opts);
	    return (0, hex_js_1$1.hexToNumber)(hex, opts);
	}
	/**
	 * Converts an array of bytes to a string using UTF-8 encoding.
	 * @param bytes_ - The array of bytes to convert.
	 * @param opts - Optional parameters for the conversion.
	 * @returns The resulting string.
	 * @example
	 * ```ts
	 * import { bytesToString } from "thirdweb/utils";
	 * const bytes = new Uint8Array([72, 101, 108, 108, 111]);
	 * const string = bytesToString(bytes);
	 * console.log(string); // "Hello"
	 * ```
	 * @utils
	 */
	function bytesToString(bytes_, opts = {}) {
	    let bytes = bytes_;
	    if (typeof opts.size !== "undefined") {
	        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
	        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
	    }
	    return new TextDecoder().decode(bytes);
	}

	var verifyTypedData$1 = {};

	var verifyHash$1 = {};

	var isValidSignature = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FN_SELECTOR = void 0;
		exports.isIsValidSignatureSupported = isIsValidSignatureSupported;
		exports.encodeIsValidSignatureParams = encodeIsValidSignatureParams;
		exports.encodeIsValidSignature = encodeIsValidSignature;
		exports.decodeIsValidSignatureResult = decodeIsValidSignatureResult;
		exports.isValidSignature = isValidSignature;
		const read_contract_js_1 = readContract$1;
		const encodeAbiParameters_js_1 = encodeAbiParameters$1;
		const viem_1 = _cjs;
		const detectExtension_js_1 = detectExtension;
		exports.FN_SELECTOR = "0x1626ba7e";
		const FN_INPUTS = [
		    {
		        type: "bytes32",
		        name: "hash",
		    },
		    {
		        type: "bytes",
		        name: "signature",
		    },
		];
		const FN_OUTPUTS = [
		    {
		        type: "bytes4",
		    },
		];
		/**
		 * Checks if the `isValidSignature` method is supported by the given contract.
		 * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using "whatsabi" or if you have the ABI of the contract available you can use it to generate the selectors.
		 * @returns A boolean indicating if the `isValidSignature` method is supported.
		 * @extension ERC1271
		 * @example
		 * ```ts
		 * import { isIsValidSignatureSupported } from "thirdweb/extensions/erc1271";
		 *
		 * const supported = isIsValidSignatureSupported(["0x..."]);
		 * ```
		 */
		function isIsValidSignatureSupported(availableSelectors) {
		    return (0, detectExtension_js_1.detectMethod)({
		        availableSelectors,
		        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
		    });
		}
		/**
		 * Encodes the parameters for the "isValidSignature" function.
		 * @param options - The options for the isValidSignature function.
		 * @returns The encoded ABI parameters.
		 * @extension ERC1271
		 * @example
		 * ```ts
		 * import { encodeIsValidSignatureParams } "thirdweb/extensions/erc1271";
		 * const result = encodeIsValidSignatureParams({
		 *  hash: ...,
		 *  signature: ...,
		 * });
		 * ```
		 */
		function encodeIsValidSignatureParams(options) {
		    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(FN_INPUTS, [options.hash, options.signature]);
		}
		/**
		 * Encodes the "isValidSignature" function into a Hex string with its parameters.
		 * @param options - The options for the isValidSignature function.
		 * @returns The encoded hexadecimal string.
		 * @extension ERC1271
		 * @example
		 * ```ts
		 * import { encodeIsValidSignature } "thirdweb/extensions/erc1271";
		 * const result = encodeIsValidSignature({
		 *  hash: ...,
		 *  signature: ...,
		 * });
		 * ```
		 */
		function encodeIsValidSignature(options) {
		    // we do a "manual" concat here to avoid the overhead of the "concatHex" function
		    // we can do this because we know the specific formats of the values
		    return (exports.FN_SELECTOR +
		        encodeIsValidSignatureParams(options).slice(2));
		}
		/**
		 * Decodes the result of the isValidSignature function call.
		 * @param result - The hexadecimal result to decode.
		 * @returns The decoded result as per the FN_OUTPUTS definition.
		 * @extension ERC1271
		 * @example
		 * ```ts
		 * import { decodeIsValidSignatureResult } from "thirdweb/extensions/erc1271";
		 * const result = decodeIsValidSignatureResult("...");
		 * ```
		 */
		function decodeIsValidSignatureResult(result) {
		    return (0, viem_1.decodeAbiParameters)(FN_OUTPUTS, result)[0];
		}
		/**
		 * Calls the "isValidSignature" function on the contract.
		 * @param options - The options for the isValidSignature function.
		 * @returns The parsed result of the function call.
		 * @extension ERC1271
		 * @example
		 * ```ts
		 * import { isValidSignature } from "thirdweb/extensions/erc1271";
		 *
		 * const result = await isValidSignature({
		 *  contract,
		 *  hash: ...,
		 *  signature: ...,
		 * });
		 *
		 * ```
		 */
		async function isValidSignature(options) {
		    return (0, read_contract_js_1.readContract)({
		        contract: options.contract,
		        method: [exports.FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
		        params: [options.hash, options.signature],
		    });
		}
		
	} (isValidSignature));

	var isErc6492Signature$1 = {};

	var constants = {};

	Object.defineProperty(constants, "__esModule", { value: true });
	constants.ERC_6492_MAGIC_VALUE = void 0;
	constants.ERC_6492_MAGIC_VALUE = "0x6492649264926492649264926492649264926492649264926492649264926492";

	Object.defineProperty(isErc6492Signature$1, "__esModule", { value: true });
	isErc6492Signature$1.isErc6492Signature = isErc6492Signature;
	const viem_1$2 = _cjs;
	const constants_js_1$1 = constants;
	/**
	 * @description Determines if a signature is compatible with [ERC6492](https://eips.ethereum.org/EIPS/eip-6492)
	 *
	 * @param {Hex} signature The signature to check for ERC6492 compatibility
	 *
	 * @returns {boolean} True if the signature is compatible with ERC6492, false otherwise
	 *
	 * @example
	 * ```ts
	 * import { isErc6492Signature } from 'thirdweb/auth';
	 *
	 * const isErc6492 = isErc6492Signature('0x1234567890123456789012345678901234567890');
	 * ```
	 *
	 * @auth
	 */
	function isErc6492Signature(signature) {
	    return (0, viem_1$2.sliceHex)(signature, -32) === constants_js_1$1.ERC_6492_MAGIC_VALUE;
	}

	var serializeErc6492Signature$1 = {};

	Object.defineProperty(serializeErc6492Signature$1, "__esModule", { value: true });
	serializeErc6492Signature$1.serializeErc6492Signature = serializeErc6492Signature;
	const encodeAbiParameters_js_1 = encodeAbiParameters$1;
	const concat_hex_js_1 = concatHex$1;
	const constants_js_1 = constants;
	/**
	 * @description Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.
	 *
	 * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format
	 * @param {string} signature.address The ERC-4337 Account Factory address
	 * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification
	 * @param {Hex} signature.signature The original signature
	 *
	 * @returns {Hex} The serialized signature
	 *
	 * @example
	 * ```ts
	 * import { serializeErc6492Signature } from 'thirdweb/auth';
	 *
	 * const serializedSignature = serializeErc6492Signature({
	 *  address: '0x...',
	 *  data: '0x...',
	 *  signature: '0x...',
	 * });
	 * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492
	 * ```
	 * @auth
	 */
	function serializeErc6492Signature({ address, data, signature, }) {
	    return (0, concat_hex_js_1.concatHex)([
	        (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
	        constants_js_1.ERC_6492_MAGIC_VALUE,
	    ]);
	}

	Object.defineProperty(verifyHash$1, "__esModule", { value: true });
	verifyHash$1.verifyHash = verifyHash;
	const utils_1 = utils$4;
	const viem_1$1 = _cjs;
	const contract_js_1 = contract;
	const isValidSignature_js_1 = isValidSignature;
	const eth_call_js_1 = eth_call$1;
	const rpc_js_1 = rpc$1;
	const from_bytes_js_1 = fromBytes$1;
	const hex_js_1 = hex;
	const to_bytes_js_1 = toBytes$2;
	const is_erc6492_signature_js_1 = isErc6492Signature$1;
	const serialize_erc6492_signature_js_1 = serializeErc6492Signature$1;
	/**
	 * @description Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.
	 * This function should rarely be used directly, instead use @see {import("./verify-signature.js")} and @see {import("./verify-typed-data.js")}}
	 *
	 * @param {Hex} options.hash The hash that was signed
	 * @param {string | Uint8Array | Signature} options.signature The signature that was signed
	 * @param {string} options.address The address that signed the hash
	 * @param {ThirdwebClient} options.client The Thirdweb client
	 * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.
	 * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory
	 * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory
	 *
	 * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.
	 *
	 * @example
	 * ```ts
	 * import { verifyHash } from "thirdweb/utils";
	 * const isValid = await verifyHash({
	 *   hash: "0x1234",
	 *   signature: "0x1234",
	 *   address: "0x1234",
	 *   client,
	 *   chain,
	 * });
	 * ```
	 *
	 * @auth
	 */
	async function verifyHash({ hash, signature, address, client, chain, accountFactory, }) {
	    const signatureHex = (() => {
	        if ((0, hex_js_1.isHex)(signature))
	            return signature;
	        if (typeof signature === "object" && "r" in signature && "s" in signature)
	            return (0, viem_1$1.serializeSignature)(signature);
	        if (signature instanceof Uint8Array)
	            return (0, from_bytes_js_1.fromBytes)(signature, "hex");
	        // We should never hit this but TS doesn't know that
	        throw new Error(`Invalid signature type for signature ${signature}: ${typeof signature}`);
	    })();
	    const wrappedSignature = await (async () => {
	        // If no factory is provided, we have to assume its already deployed or is an EOA
	        // TODO: Figure out how to automatically tell if our default factory was used
	        if (!accountFactory)
	            return signatureHex;
	        // If this sigature was already wrapped for ERC-6492, carry on
	        if ((0, is_erc6492_signature_js_1.isErc6492Signature)(signatureHex))
	            return signatureHex;
	        // Otherwise, serialize the signature for ERC-6492 validation
	        return (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
	            address: accountFactory.address,
	            data: accountFactory.verificationCalldata,
	            signature: signatureHex,
	        });
	    })();
	    const verificationData = (0, viem_1$1.encodeDeployData)({
	        abi: viem_1$1.universalSignatureValidatorAbi,
	        args: [address, hash, wrappedSignature],
	        bytecode: viem_1$1.universalSignatureValidatorByteCode,
	    });
	    const rpcRequest = (0, rpc_js_1.getRpcClient)({
	        chain,
	        client,
	    });
	    try {
	        const result = await (0, eth_call_js_1.eth_call)(rpcRequest, {
	            data: verificationData,
	        });
	        const hexResult = (0, hex_js_1.isHex)(result) ? (0, to_bytes_js_1.toBytes)(result) : result;
	        return (0, utils_1.equalBytes)(hexResult, (0, to_bytes_js_1.toBytes)("0x1"));
	    }
	    catch {
	        // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation
	        const validEip1271 = await verifyEip1271Signature({
	            hash,
	            signature: signatureHex,
	            contract: (0, contract_js_1.getContract)({
	                chain,
	                address,
	                client,
	            }),
	        }).catch(() => false);
	        if (validEip1271) {
	            return true;
	        }
	        // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error
	        // Verification failed somehow
	        return false;
	    }
	}
	const EIP_1271_MAGIC_VALUE = "0x1626ba7e";
	async function verifyEip1271Signature({ hash, signature, contract, }) {
	    const result = await (0, isValidSignature_js_1.isValidSignature)({
	        hash,
	        signature,
	        contract,
	    });
	    return result === EIP_1271_MAGIC_VALUE;
	}

	Object.defineProperty(verifyTypedData$1, "__esModule", { value: true });
	verifyTypedData$1.verifyTypedData = verifyTypedData;
	const viem_1 = _cjs;
	const verify_hash_js_1 = verifyHash$1;
	/**
	 * @description Verify am [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data signature. This function is interoperable with all wallet types (smart accounts or EOAs).
	 *
	 * @param {string} options.address The address that signed the typed data
	 * @param {string | Uint8Array | Signature} options.signature The signature that was signed
	 * @param {ThirdwebClient} options.client The Thirdweb client
	 * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.
	 * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory
	 * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory
	 * @param {typeof VerifyTypedDataParams.message} options.message The EIP-712 message that was signed.
	 * @param {typeof VerifyTypedDataParams.domain} options.domain The EIP-712 domain that was signed.
	 * @param {typeof VerifyTypedDataParams.primaryType} options.primaryType The EIP-712 primary type that was signed.
	 * @param {typeof VerifyTypedDataParams.types} options.types The EIP-712 types that were signed.
	 *
	 * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.
	 *
	 * @example
	 * ```ts
	 * import { verifyTypedData } from "thirdweb/utils";
	 * const isValid = await verifyTypedData({
	 *   address: "0x...",
	 *   signature: "0x...",
	 *   client,
	 *   chain,
	 *   domain: {
	      name: "Ether Mail",
	      version: "1",
	      chainId: 1,
	      verifyingContract: "0x0000000000000000000000000000000000000000",
	    },
	 *   primaryType: "Mail",
	 *   types: {
	      Person: [
	        { name: "name", type: "string" },
	        { name: "wallet", type: "address" },
	      ],
	      Mail: [
	        { name: "from", type: "Person" },
	        { name: "to", type: "Person" },
	        { name: "contents", type: "string" },
	      ],
	    },
	    message: {
	      from: {
	        name: "Cow",
	        wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
	      },
	      to: {
	        name: "Bob",
	        wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
	      },
	      contents: "Hello, Bob!",
	    },
	 * });
	 * ```
	 *
	 * @auth
	 */
	async function verifyTypedData({ address, signature, client, chain, accountFactory, message, domain, primaryType, types, }) {
	    const messageHash = (0, viem_1.hashTypedData)({
	        message,
	        domain,
	        primaryType,
	        types,
	    });
	    return (0, verify_hash_js_1.verifyHash)({
	        hash: messageHash,
	        signature,
	        address,
	        chain,
	        client,
	        accountFactory,
	    });
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getBuyWithCryptoQuote = exports.fromGwei = exports.toWei = exports.toUnits = exports.toTokens = exports.toEther = exports.watchContractEvents = exports.parseEventLogs = exports.getContractEvents = exports.prepareEvent = exports.toSerializableTransaction = exports.serializeTransaction = exports.signTransaction = exports.waitForReceipt = exports.simulateTransaction = exports.sendBatchTransaction = exports.sendAndConfirmTransaction = exports.sendTransaction = exports.getGasPrice = exports.estimateGasCost = exports.estimateGas = exports.encode = exports.resolveMethod = exports.readContract = exports.prepareContractCall = exports.isBaseTransactionOptions = exports.prepareTransaction = exports.getContract = exports.eth_sendRawTransaction = exports.eth_maxPriorityFeePerGas = exports.eth_getTransactionReceipt = exports.eth_getTransactionCount = exports.eth_getTransactionByHash = exports.eth_getStorageAt = exports.eth_getLogs = exports.eth_getCode = exports.eth_getBlockByNumber = exports.eth_getBlockByHash = exports.eth_getBalance = exports.eth_gasPrice = exports.eth_estimateGas = exports.eth_call = exports.eth_blockNumber = exports.watchBlockNumber = exports.getRpcClient = exports.defineChain = exports.createThirdwebClient = exports.NATIVE_TOKEN_ADDRESS = exports.ZERO_ADDRESS = exports.ADDRESS_ZERO = void 0;
		exports.verifyTypedData = exports.isAddress = exports.getAddress = exports.sha256 = exports.keccak256 = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigInt = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.concatHex = exports.uint8ArrayToHex = exports.toHex = exports.stringToHex = exports.padHex = exports.numberToHex = exports.isHex = exports.hexToUint8Array = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.boolToHex = exports.getBuyWithCryptoTransfer = exports.getBuyWithCryptoHistory = exports.getBuyWithCryptoStatus = void 0;
		/**
		 * CONSTANTS
		 */
		var addresses_js_1 = addresses;
		Object.defineProperty(exports, "ADDRESS_ZERO", { enumerable: true, get: function () { return addresses_js_1.ADDRESS_ZERO; } });
		Object.defineProperty(exports, "ZERO_ADDRESS", { enumerable: true, get: function () { return addresses_js_1.ZERO_ADDRESS; } });
		Object.defineProperty(exports, "NATIVE_TOKEN_ADDRESS", { enumerable: true, get: function () { return addresses_js_1.NATIVE_TOKEN_ADDRESS; } });
		/**
		 * CLIENT
		 */
		var client_js_1 = client;
		Object.defineProperty(exports, "createThirdwebClient", { enumerable: true, get: function () { return client_js_1.createThirdwebClient; } });
		// define chain
		var utils_js_1 = utils$7;
		Object.defineProperty(exports, "defineChain", { enumerable: true, get: function () { return utils_js_1.defineChain; } });
		/**
		 * RPC
		 */
		// rpc client
		var rpc_js_1 = rpc$1;
		Object.defineProperty(exports, "getRpcClient", { enumerable: true, get: function () { return rpc_js_1.getRpcClient; } });
		// blockNumber watcher
		var watchBlockNumber_js_1 = watchBlockNumber$3;
		Object.defineProperty(exports, "watchBlockNumber", { enumerable: true, get: function () { return watchBlockNumber_js_1.watchBlockNumber; } });
		// all the actions
		var eth_blockNumber_js_1 = eth_blockNumber$1;
		Object.defineProperty(exports, "eth_blockNumber", { enumerable: true, get: function () { return eth_blockNumber_js_1.eth_blockNumber; } });
		var eth_call_js_1 = eth_call$1;
		Object.defineProperty(exports, "eth_call", { enumerable: true, get: function () { return eth_call_js_1.eth_call; } });
		var eth_estimateGas_js_1 = eth_estimateGas$1;
		Object.defineProperty(exports, "eth_estimateGas", { enumerable: true, get: function () { return eth_estimateGas_js_1.eth_estimateGas; } });
		var eth_gasPrice_js_1 = eth_gasPrice$1;
		Object.defineProperty(exports, "eth_gasPrice", { enumerable: true, get: function () { return eth_gasPrice_js_1.eth_gasPrice; } });
		var eth_getBalance_js_1 = eth_getBalance$1;
		Object.defineProperty(exports, "eth_getBalance", { enumerable: true, get: function () { return eth_getBalance_js_1.eth_getBalance; } });
		var eth_getBlockByHash_js_1 = eth_getBlockByHash$1;
		Object.defineProperty(exports, "eth_getBlockByHash", { enumerable: true, get: function () { return eth_getBlockByHash_js_1.eth_getBlockByHash; } });
		var eth_getBlockByNumber_js_1 = eth_getBlockByNumber$1;
		Object.defineProperty(exports, "eth_getBlockByNumber", { enumerable: true, get: function () { return eth_getBlockByNumber_js_1.eth_getBlockByNumber; } });
		var eth_getCode_js_1 = eth_getCode$1;
		Object.defineProperty(exports, "eth_getCode", { enumerable: true, get: function () { return eth_getCode_js_1.eth_getCode; } });
		var eth_getLogs_js_1 = eth_getLogs$1;
		Object.defineProperty(exports, "eth_getLogs", { enumerable: true, get: function () { return eth_getLogs_js_1.eth_getLogs; } });
		var eth_getStorageAt_js_1 = eth_getStorageAt$1;
		Object.defineProperty(exports, "eth_getStorageAt", { enumerable: true, get: function () { return eth_getStorageAt_js_1.eth_getStorageAt; } });
		var eth_getTransactionByHash_js_1 = eth_getTransactionByHash$1;
		Object.defineProperty(exports, "eth_getTransactionByHash", { enumerable: true, get: function () { return eth_getTransactionByHash_js_1.eth_getTransactionByHash; } });
		var eth_getTransactionCount_js_1 = eth_getTransactionCount$1;
		Object.defineProperty(exports, "eth_getTransactionCount", { enumerable: true, get: function () { return eth_getTransactionCount_js_1.eth_getTransactionCount; } });
		var eth_getTransactionReceipt_js_1 = eth_getTransactionReceipt$1;
		Object.defineProperty(exports, "eth_getTransactionReceipt", { enumerable: true, get: function () { return eth_getTransactionReceipt_js_1.eth_getTransactionReceipt; } });
		var eth_maxPriorityFeePerGas_js_1 = eth_maxPriorityFeePerGas$1;
		Object.defineProperty(exports, "eth_maxPriorityFeePerGas", { enumerable: true, get: function () { return eth_maxPriorityFeePerGas_js_1.eth_maxPriorityFeePerGas; } });
		var eth_sendRawTransaction_js_1 = eth_sendRawTransaction$1;
		Object.defineProperty(exports, "eth_sendRawTransaction", { enumerable: true, get: function () { return eth_sendRawTransaction_js_1.eth_sendRawTransaction; } });
		/**
		 * CONTRACT
		 */
		var contract_js_1 = contract;
		Object.defineProperty(exports, "getContract", { enumerable: true, get: function () { return contract_js_1.getContract; } });
		/**
		 * TRANSACTIONS
		 */
		var prepare_transaction_js_1 = prepareTransaction$1;
		Object.defineProperty(exports, "prepareTransaction", { enumerable: true, get: function () { return prepare_transaction_js_1.prepareTransaction; } });
		var types_js_1 = types;
		Object.defineProperty(exports, "isBaseTransactionOptions", { enumerable: true, get: function () { return types_js_1.isBaseTransactionOptions; } });
		var prepare_contract_call_js_1 = prepareContractCall$1;
		Object.defineProperty(exports, "prepareContractCall", { enumerable: true, get: function () { return prepare_contract_call_js_1.prepareContractCall; } });
		var read_contract_js_1 = readContract$1;
		Object.defineProperty(exports, "readContract", { enumerable: true, get: function () { return read_contract_js_1.readContract; } });
		// method resolver
		var resolve_method_js_1 = resolveMethod$1;
		Object.defineProperty(exports, "resolveMethod", { enumerable: true, get: function () { return resolve_method_js_1.resolveMethod; } });
		// transaction actions
		var encode_js_1 = encode$1;
		Object.defineProperty(exports, "encode", { enumerable: true, get: function () { return encode_js_1.encode; } });
		var estimate_gas_js_1 = estimateGas$1;
		Object.defineProperty(exports, "estimateGas", { enumerable: true, get: function () { return estimate_gas_js_1.estimateGas; } });
		var estimate_gas_cost_js_1 = estimateGasCost$1;
		Object.defineProperty(exports, "estimateGasCost", { enumerable: true, get: function () { return estimate_gas_cost_js_1.estimateGasCost; } });
		var get_gas_price_js_1 = getGasPrice$1;
		Object.defineProperty(exports, "getGasPrice", { enumerable: true, get: function () { return get_gas_price_js_1.getGasPrice; } });
		var send_transaction_js_1 = sendTransaction$1;
		Object.defineProperty(exports, "sendTransaction", { enumerable: true, get: function () { return send_transaction_js_1.sendTransaction; } });
		var send_and_confirm_transaction_js_1 = sendAndConfirmTransaction$1;
		Object.defineProperty(exports, "sendAndConfirmTransaction", { enumerable: true, get: function () { return send_and_confirm_transaction_js_1.sendAndConfirmTransaction; } });
		var send_batch_transaction_js_1 = sendBatchTransaction$1;
		Object.defineProperty(exports, "sendBatchTransaction", { enumerable: true, get: function () { return send_batch_transaction_js_1.sendBatchTransaction; } });
		var simulate_js_1 = simulate;
		Object.defineProperty(exports, "simulateTransaction", { enumerable: true, get: function () { return simulate_js_1.simulateTransaction; } });
		var wait_for_tx_receipt_js_1 = waitForTxReceipt;
		Object.defineProperty(exports, "waitForReceipt", { enumerable: true, get: function () { return wait_for_tx_receipt_js_1.waitForReceipt; } });
		var sign_transaction_js_1 = signTransaction$1;
		Object.defineProperty(exports, "signTransaction", { enumerable: true, get: function () { return sign_transaction_js_1.signTransaction; } });
		var serialize_transaction_js_1 = serializeTransaction$1;
		Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function () { return serialize_transaction_js_1.serializeTransaction; } });
		var to_serializable_transaction_js_1 = toSerializableTransaction$1;
		Object.defineProperty(exports, "toSerializableTransaction", { enumerable: true, get: function () { return to_serializable_transaction_js_1.toSerializableTransaction; } });
		/**
		 * EVENTS
		 */
		var prepare_event_js_1 = prepareEvent$1;
		Object.defineProperty(exports, "prepareEvent", { enumerable: true, get: function () { return prepare_event_js_1.prepareEvent; } });
		// actions
		var get_events_js_1 = getEvents;
		Object.defineProperty(exports, "getContractEvents", { enumerable: true, get: function () { return get_events_js_1.getContractEvents; } });
		var parse_logs_js_1 = parseLogs;
		Object.defineProperty(exports, "parseEventLogs", { enumerable: true, get: function () { return parse_logs_js_1.parseEventLogs; } });
		var watch_events_js_1 = watchEvents;
		Object.defineProperty(exports, "watchContractEvents", { enumerable: true, get: function () { return watch_events_js_1.watchContractEvents; } });
		/**
		 * UNITS
		 */
		var units_js_1 = units;
		Object.defineProperty(exports, "toEther", { enumerable: true, get: function () { return units_js_1.toEther; } });
		Object.defineProperty(exports, "toTokens", { enumerable: true, get: function () { return units_js_1.toTokens; } });
		Object.defineProperty(exports, "toUnits", { enumerable: true, get: function () { return units_js_1.toUnits; } });
		Object.defineProperty(exports, "toWei", { enumerable: true, get: function () { return units_js_1.toWei; } });
		Object.defineProperty(exports, "fromGwei", { enumerable: true, get: function () { return units_js_1.fromGwei; } });
		var getQuote_js_1 = getQuote;
		Object.defineProperty(exports, "getBuyWithCryptoQuote", { enumerable: true, get: function () { return getQuote_js_1.getBuyWithCryptoQuote; } });
		var getStatus_js_1 = getStatus;
		Object.defineProperty(exports, "getBuyWithCryptoStatus", { enumerable: true, get: function () { return getStatus_js_1.getBuyWithCryptoStatus; } });
		var getHistory_js_1 = getHistory;
		Object.defineProperty(exports, "getBuyWithCryptoHistory", { enumerable: true, get: function () { return getHistory_js_1.getBuyWithCryptoHistory; } });
		var getTransfer_js_1 = getTransfer;
		Object.defineProperty(exports, "getBuyWithCryptoTransfer", { enumerable: true, get: function () { return getTransfer_js_1.getBuyWithCryptoTransfer; } });
		// ------------------------------------------------
		// encoding
		// ------------------------------------------------
		// hex
		var hex_js_1 = hex;
		Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function () { return hex_js_1.boolToHex; } });
		// from
		Object.defineProperty(exports, "fromHex", { enumerable: true, get: function () { return hex_js_1.fromHex; } });
		Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function () { return hex_js_1.hexToBigInt; } });
		Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function () { return hex_js_1.hexToBool; } });
		Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function () { return hex_js_1.hexToNumber; } });
		Object.defineProperty(exports, "hexToString", { enumerable: true, get: function () { return hex_js_1.hexToString; } });
		Object.defineProperty(exports, "hexToUint8Array", { enumerable: true, get: function () { return hex_js_1.hexToUint8Array; } });
		// util
		Object.defineProperty(exports, "isHex", { enumerable: true, get: function () { return hex_js_1.isHex; } });
		Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function () { return hex_js_1.numberToHex; } });
		Object.defineProperty(exports, "padHex", { enumerable: true, get: function () { return hex_js_1.padHex; } });
		Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function () { return hex_js_1.stringToHex; } });
		// to
		Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return hex_js_1.toHex; } });
		Object.defineProperty(exports, "uint8ArrayToHex", { enumerable: true, get: function () { return hex_js_1.uint8ArrayToHex; } });
		var concat_hex_js_1 = concatHex$1;
		Object.defineProperty(exports, "concatHex", { enumerable: true, get: function () { return concat_hex_js_1.concatHex; } });
		// bytes
		// to
		var to_bytes_js_1 = toBytes$2;
		Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function () { return to_bytes_js_1.boolToBytes; } });
		Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function () { return to_bytes_js_1.hexToBytes; } });
		Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function () { return to_bytes_js_1.numberToBytes; } });
		Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function () { return to_bytes_js_1.stringToBytes; } });
		Object.defineProperty(exports, "toBytes", { enumerable: true, get: function () { return to_bytes_js_1.toBytes; } });
		// from
		var from_bytes_js_1 = fromBytes$1;
		Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function () { return from_bytes_js_1.bytesToBigInt; } });
		Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function () { return from_bytes_js_1.bytesToBool; } });
		Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function () { return from_bytes_js_1.bytesToNumber; } });
		Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function () { return from_bytes_js_1.bytesToString; } });
		Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function () { return from_bytes_js_1.fromBytes; } });
		// ------------------------------------------------
		// hashing
		// ------------------------------------------------
		// keccak256
		var keccak256_js_1 = keccak256$1;
		Object.defineProperty(exports, "keccak256", { enumerable: true, get: function () { return keccak256_js_1.keccak256; } });
		// sha256
		var sha256_js_1 = sha256$4;
		Object.defineProperty(exports, "sha256", { enumerable: true, get: function () { return sha256_js_1.sha256; } });
		// ------------------------------------------------
		// address
		// ------------------------------------------------
		var address_js_1 = address;
		Object.defineProperty(exports, "getAddress", { enumerable: true, get: function () { return address_js_1.getAddress; } });
		Object.defineProperty(exports, "isAddress", { enumerable: true, get: function () { return address_js_1.isAddress; } });
		var verify_typed_data_js_1 = verifyTypedData$1;
		Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function () { return verify_typed_data_js_1.verifyTypedData; } });
		
	} (thirdweb));

	var storage = {};

	var uploadMobile$1 = {};

	var mobile = {};

	Object.defineProperty(mobile, "__esModule", { value: true });
	mobile.uploadBatchMobile = uploadBatchMobile;
	const domains_js_1$1 = domains;
	const fetch_js_1$1 = fetch$1;
	const helpers_js_1 = helpers;
	const METADATA_NAME = "Storage React Native SDK";
	async function uploadBatchMobile(client, data, options) {
	    if (!data || data.length === 0 || !data[0]) {
	        throw new Error("[UPLOAD_BATCH_ERROR] No files or objects to upload.");
	    }
	    if (typeof data[0] === "object" &&
	        "uri" in data[0] &&
	        "type" in data[0] &&
	        "name" in data[0]) {
	        // then it's an array of files
	        return new Promise((resolve, reject) => {
	            const formData = new FormData();
	            const { form, fileNames } = buildFormData(formData, data, options);
	            const xhr = new XMLHttpRequest();
	            let timer = setTimeout(() => {
	                xhr.abort();
	                reject(new Error("Request to upload timed out! No upload progress received in 30s"));
	            }, 30000);
	            xhr.upload.addEventListener("loadstart", () => {
	                console.log(`[${Date.now()}] [IPFS] Started`);
	            });
	            xhr.upload.addEventListener("progress", (event) => {
	                console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);
	                clearTimeout(timer);
	                if (event.loaded < event.total) {
	                    timer = setTimeout(() => {
	                        xhr.abort();
	                        reject(new Error("Request to upload timed out! No upload progress received in 30s"));
	                    }, 30000);
	                }
	                else {
	                    console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);
	                }
	            });
	            xhr.addEventListener("load", () => {
	                console.log(`[${Date.now()}] [IPFS] Load`);
	                clearTimeout(timer);
	                if (xhr.status >= 200 && xhr.status < 300) {
	                    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
	                    let body;
	                    try {
	                        body = JSON.parse(xhr.responseText);
	                    }
	                    catch {
	                        return reject(new Error("Failed to parse JSON from upload response"));
	                    }
	                    const cid = body.IpfsHash;
	                    if (!cid) {
	                        throw new Error("Failed to get IPFS hash from upload response");
	                    }
	                    if (options?.uploadWithoutDirectory) {
	                        return resolve([`ipfs://${cid}`]);
	                    }
	                    return resolve(fileNames.map((name) => `ipfs://${cid}/${name}`));
	                }
	                return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));
	            });
	            xhr.addEventListener("error", () => {
	                console.log("[IPFS] Load");
	                clearTimeout(timer);
	                if ((xhr.readyState !== 0 && xhr.readyState !== 4) ||
	                    xhr.status === 0) {
	                    return reject(new Error(`Upload failed due to a network error. ${xhr.responseText}`));
	                }
	                return reject(new Error("Unknown upload error occured"));
	            });
	            xhr.open("POST", `https://${(0, domains_js_1$1.getThirdwebDomains)().storage}/ipfs/upload`);
	            if (client.clientId) {
	                xhr.setRequestHeader("x-client-id", client.clientId);
	            }
	            for (const [key, value] of (0, fetch_js_1$1.getPlatformHeaders)()) {
	                xhr.setRequestHeader(key, value);
	            }
	            xhr.send(form);
	        });
	    }
	    // assume an array of things
	    const metadata = {
	        name: METADATA_NAME,
	        keyvalues: { ...options?.metadata },
	    };
	    const fetchBody = JSON.stringify({
	        metadata: metadata,
	        content: data,
	    });
	    try {
	        const res = await (0, fetch_js_1$1.getClientFetch)(client)(`https://${(0, domains_js_1$1.getThirdwebDomains)().storage}/ipfs/batch-pin-json`, {
	            method: "POST",
	            headers: {
	                "Content-Type": "application/json",
	            },
	            body: fetchBody,
	        });
	        if (res.ok) {
	            const ipfsResults = await res.json();
	            const results = ipfsResults.results.map((ipfs) => {
	                const cid = ipfs.IpfsHash;
	                return `ipfs://${cid}`;
	            });
	            return results;
	        }
	    }
	    catch (error) {
	        console.error("[IPFS] Error uploading JSON to IPFS", error);
	        throw error;
	    }
	    throw new Error("Failed to upload JSON to IPFS");
	}
	/**
	 * @internal
	 */
	function buildFormData(form, files, options) {
	    const fileNameToFileMap = new Map();
	    const fileNames = [];
	    for (let i = 0; i < files.length; i++) {
	        // biome-ignore lint/style/noNonNullAssertion: <explanation>
	        const file = files[i];
	        let fileName = "";
	        if (options?.rewriteFileNames) {
	            let extensions = "";
	            if (file.name) {
	                const extensionStartIndex = file.name.lastIndexOf(".");
	                if (extensionStartIndex > -1) {
	                    extensions = file.name.substring(extensionStartIndex);
	                }
	            }
	            fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;
	        }
	        else {
	            fileName = `${file.name}`;
	        }
	        if (fileNameToFileMap.has(fileName)) {
	            // if the file in the map is the same as the file we are already looking at then just skip and continue
	            if ((0, helpers_js_1.isFileBufferOrStringEqual)(fileNameToFileMap.get(fileName), file)) {
	                // we add it to the filenames array so that we can return the correct number of urls,
	                fileNames.push(fileName);
	                // but then we skip because we don't need to upload it multiple times
	                continue;
	            }
	            // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to different files but with the same names)
	            throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);
	        }
	        // add it to the map so that we can check for duplicates
	        fileNameToFileMap.set(fileName, file);
	        // add it to the filenames array so that we can return the correct number of urls
	        fileNames.push(fileName);
	        // @ts-ignore - ReactNative does not support Blob and takes any here.
	        form.append("file", file);
	    }
	    const metadata = {
	        name: METADATA_NAME,
	        keyvalues: { ...options?.metadata },
	    };
	    form.append("pinataMetadata", JSON.stringify(metadata));
	    form.append("pinataOptions", JSON.stringify({
	        wrapWithDirectory: options?.uploadWithoutDirectory !== true,
	    }));
	    return {
	        form,
	        // encode the file names on the way out (which is what the upload backend expects)
	        fileNames: fileNames.map((fName) => encodeURIComponent(fName)),
	    };
	}

	Object.defineProperty(uploadMobile$1, "__esModule", { value: true });
	uploadMobile$1.uploadMobile = uploadMobile;
	const mobile_js_1 = mobile;
	/**
	 * Batch upload arbitrary file or JSON data using the configured decentralized storage system.
	 * Automatically uploads any file data within JSON objects and replaces them with hashes.
	 * @param options - Options to pass through to the storage uploader class
	 * @returns  The URIs of the uploaded data
	 * @example
	 * ```jsx
	 * // Upload an image
	 * launchImageLibrary({mediaType: 'photo'}, async response => {
	 *   if (response.assets?.[0]) {
	 *      const {fileName, type, uri} = response.assets[0];
	 *      if (!uri) {
	 *        throw new Error('No uri');
	 *      }
	 *      const resp = await uploadMobile({
	 *        uri,
	 *        type,
	 *        name: fileName,
	 *      });
	 *    }
	 *  });
	 *
	 * // Upload an array of JSON objects
	 * const objects = [
	 *  { name: "JSON 1", text: "Hello World" },
	 *  { name: "JSON 2", trait: "Awesome" },
	 * ];
	 * const jsonUris = await uploadMobile(objects);
	 * ```
	 * @storage
	 */
	async function uploadMobile(options) {
	    if (!options) {
	        return [];
	    }
	    const data = options.files.filter((item) => item !== undefined);
	    if (!data?.length) {
	        return [];
	    }
	    return await (0, mobile_js_1.uploadBatchMobile)(options.client, data, options);
	}

	var unpin$1 = {};

	Object.defineProperty(unpin$1, "__esModule", { value: true });
	unpin$1.unpin = unpin;
	const domains_js_1 = domains;
	const fetch_js_1 = fetch$1;
	/**
	 * Unpins a file from IPFS.
	 * @note For security purposes, this method requires a secret key to be set in the ThirdwebClient instance.
	 * @param options - The options for unpinning the file.
	 * @param options.client - The Thirdweb client instance.
	 * @param options.cid - The content identifier (CID) of the file to unpin.
	 * @throws Will throw an error if the client does not have a secret key or if the unpinning fails.
	 * @example
	 * ```ts
	 * import { unpin } from "thirdweb";
	 *
	 * const result = await unpin({
	 *   client: thirdwebClient,
	 *   cid: "QmTzQ1N1z1Q1N1z1Q1N1z1Q1N1z1Q1N1z1Q1N1z1Q1N1z1",
	 * });
	 * ```
	 * @storage
	 */
	async function unpin(options) {
	    if (!options.client.secretKey) {
	        throw new Error("Unauthorized - Your client must have a secret key to unpin files.");
	    }
	    const res = await (0, fetch_js_1.getClientFetch)(options.client)(`https://${(0, domains_js_1.getThirdwebDomains)().storage}/ipfs/pinned/${options.cid}`, {
	        method: "DELETE",
	    });
	    if (!res.ok) {
	        res.body?.cancel();
	        if (res.status === 401) {
	            throw new Error("Unauthorized - You don't have permission to use this service.");
	        }
	        throw new Error(`Failed to unpin file - ${res.status} - ${res.statusText}`);
	    }
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.resolveArweaveScheme = exports.resolveScheme = exports.unpin = exports.download = exports.uploadMobile = exports.upload = void 0;
		var upload_js_1 = upload$1;
		Object.defineProperty(exports, "upload", { enumerable: true, get: function () { return upload_js_1.upload; } });
		var uploadMobile_js_1 = uploadMobile$1;
		Object.defineProperty(exports, "uploadMobile", { enumerable: true, get: function () { return uploadMobile_js_1.uploadMobile; } });
		var download_js_1 = download$1;
		Object.defineProperty(exports, "download", { enumerable: true, get: function () { return download_js_1.download; } });
		var unpin_js_1 = unpin$1;
		Object.defineProperty(exports, "unpin", { enumerable: true, get: function () { return unpin_js_1.unpin; } });
		var ipfs_js_1 = ipfs;
		Object.defineProperty(exports, "resolveScheme", { enumerable: true, get: function () { return ipfs_js_1.resolveScheme; } });
		var arweave_js_1 = arweave;
		Object.defineProperty(exports, "resolveArweaveScheme", { enumerable: true, get: function () { return arweave_js_1.resolveArweaveScheme; } });
		
	} (storage));

	Object.defineProperty(thirdWebClient, "__esModule", { value: true });
	thirdWebClient.uploadFile = uploadFile;
	thirdWebClient.downloadFile = downloadFile;
	thirdWebClient.deleteFile = deleteFile;
	thirdWebClient.default = init$2;
	const thirdweb_1 = thirdweb;
	const storage_1 = storage;
	let thirdwebClient;
	async function uploadFile(content) {
	    return await (0, storage_1.upload)({
	        client: thirdwebClient,
	        files: [new File([content], "d.txt")],
	    });
	}
	async function downloadFile(uri) {
	    const file = await (0, storage_1.download)({
	        client: thirdwebClient,
	        uri,
	    });
	    return await file.text();
	}
	function deleteFile(uri) {
	    return (0, storage_1.unpin)({
	        client: thirdwebClient,
	        cid: uri.match(/ipfs:\/\/([^\/]+)/)[1],
	    });
	}
	async function init$2(secretKey) {
	    thirdwebClient = (0, thirdweb_1.createThirdwebClient)({
	        secretKey,
	    });
	}

	var keys = {};

	const STORAGE_KEY = "brewing-disaster";

	function getSave() {
	  const save = localStorage.getItem(STORAGE_KEY);

	  try {
	    return JSON.parse(save) || {};
	  } catch (e) {
	    return {};
	  }
	}

	function storeSave(save) {
	  localStorage.setItem(STORAGE_KEY, JSON.stringify(save));
	}

	function storeKey(key, value) {
	  const save = getSave();

	  storeSave({
	    ...save,
	    [key]: value,
	  });
	}

	function getKey(key) {
	  const save = getSave();

	  return save[key];
	}

	var save = /*#__PURE__*/Object.freeze({
		__proto__: null,
		storeKey: storeKey,
		getKey: getKey
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(save);

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.setPrivateKey = void 0;
		exports.getPublicKey = getPublicKey;
		exports.generateNewPrivateKey = generateNewPrivateKey;
		exports.default = init;
		const save_1 = require$$0;
		let privateKey;
		let publicKey;
		async function hash(text) {
		    const res = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(text));
		    return [...new Uint8Array(res)]
		        .map((x) => x.toString(16).padStart(2, "0"))
		        .join("");
		}
		async function getPublicKey() {
		    if (publicKey) {
		        return publicKey;
		    }
		    if (!privateKey) {
		        return null;
		    }
		    publicKey = await hash(privateKey);
		    return publicKey;
		}
		const setPrivateKey = async (newKey) => {
		    (0, save_1.storeKey)("privateKey", newKey);
		    privateKey = newKey;
		    if (!privateKey) {
		        publicKey = null;
		    }
		    else {
		        await getPublicKey();
		    }
		    return privateKey;
		};
		exports.setPrivateKey = setPrivateKey;
		async function generateNewPrivateKey() {
		    const newPrivateKey = crypto.randomUUID();
		    return await (0, exports.setPrivateKey)(newPrivateKey);
		}
		async function init() {
		    return (0, exports.setPrivateKey)((0, save_1.getKey)("privateKey"));
		} 
	} (keys));

	var mu = {};

	Object.defineProperty(mu, "__esModule", { value: true });
	mu.checkFile = checkFile;
	mu.getDeckContent = getDeckContent;
	mu.setFile = setFile;
	mu.setThirdwebURI = setThirdwebURI;
	mu.saveFile = saveFile;
	const keys_1$1 = keys;
	const thirdWebClient_1$1 = thirdWebClient;
	const ROOT = "https://www.mariouniversalis.fr/brewing-disaster/";
	let thirdWebURI = "";
	let deckContent = "";
	async function checkFile(fileId) {
	    try {
	        const response = await fetch(`${ROOT}${fileId}`, {
	            method: "GET",
	        });
	        if (response.ok) {
	            thirdWebURI = await response.text();
	            if (thirdWebURI) {
	                try {
	                    deckContent = await (0, thirdWebClient_1$1.downloadFile)(thirdWebURI);
	                }
	                catch (e) {
	                    thirdWebURI = "";
	                    deckContent = "";
	                    return true;
	                }
	            }
	            return true;
	        }
	        return false;
	    }
	    catch (error) {
	        return false;
	    }
	}
	function getDeckContent() {
	    return deckContent;
	}
	async function setFile(fileId, content) {
	    try {
	        const response = await fetch(`${ROOT}${fileId}`, {
	            method: "PUT",
	            body: content,
	            headers: {
	                "Content-Type": "text/plain",
	            },
	        });
	        if (!response.ok) {
	            throw new Error("Error while updating file");
	        }
	    }
	    catch (error) {
	        throw error;
	    }
	}
	async function setThirdwebURI(uri, publicKey) {
	    thirdWebURI = uri;
	    await setFile(publicKey, uri);
	    return uri;
	}
	async function saveFile(fileContent) {
	    const newFileContent = fileContent.join("\n");
	    const newFileURI = await (0, thirdWebClient_1$1.uploadFile)(newFileContent);
	    deckContent = newFileContent;
	    if (thirdWebURI) {
	        try {
	            await (0, thirdWebClient_1$1.deleteFile)(thirdWebURI);
	        }
	        catch (e) { }
	    }
	    const publicKey = await (0, keys_1$1.getPublicKey)();
	    await setThirdwebURI(newFileURI, publicKey);
	}

	var ui$1 = {};

	const putridityValue = document.getElementById("putridityValue");
	const scene = document.getElementById("scene");
	const hand = document.getElementById("hand");
	const playerScene = document.getElementById("playerScene");
	const opponentScene = document.getElementById("opponentScene");
	const cauldronContent = document.getElementById("cauldronContent");
	const thrownItem = document.getElementById("thrownItem");
	const cardAwards = document.getElementById("cardAwards");
	const passiveAwards = document.getElementById("passiveAwards");
	const characterList$1 = document.getElementById("characterList");
	const opponentList = document.getElementById("opponentList");
	const wizardName = document.getElementById("wizardName");
	const nextWizardDesc = document.getElementById("nextWizardDesc");
	const nextWizardCards = document.getElementById("nextWizardCards");
	const nextWizardPutridity = document.getElementById("nextWizardPutridity");
	const ruleCardList = document.getElementById("ruleCardList");
	const playerDeck = document.getElementById("playerDeck");
	const battleResultsWon = document.getElementById("battleResultsWon");
	const soundsCheckbox = document.getElementById("soundsCheckbox");
	const gameWin = document.getElementById("gameWin");
	const floorCanvas = document.getElementById("floorCanvas");
	const floorCanvasCtx = floorCanvas?.getContext("2d");

	const codeToClassName = {
	  "{P}": "skull",
	  "{W}": "worm",
	  "{F}": "fly",
	  "{B}": "bat",
	  "{S}": "spider",
	  "{A}": "apple",
	  "{Y}": "berry",
	};

	function createCardNode(uniqCard, element = "div", poison, total) {
	  const { id, uniqId, hasActivePassive, status } = uniqCard;
	  const card = document.createElement(element);
	  card.className = "card";

	  if (uniqId) {
	    card.dataset.uniqId = uniqId;
	  }

	  if (total) {
	    card.dataset.total = total;
	  }

	  if (hasActivePassive) {
	    card.classList.add("withPassive");
	  }

	  card.classList.add(status);

	  const content = uniqCard.getDesc(poison);

	  card.innerHTML = `<div class="image sprite ${id}"></div><div class="name">${uniqCard.getName()}</div><div class="effect">${content.replace(
    new RegExp(Object.keys(codeToClassName).join("|"), "g"),
    (match) => `<span class="sprite ${codeToClassName[match]}"></span>`
  )}</div>`;

	  return card;
	}

	function drawSceneFloor() {
	  const groundWidth = 848;
	  const groundHeight = 92;

	  const tileSpacing = 2;

	  const tileWidth = 64;
	  const tileHeight = 16;
	  const cols = Math.floor(groundWidth / (tileWidth + tileSpacing)) + 1;
	  const rows = Math.floor(groundHeight / (tileHeight + tileSpacing)) + 1;

	  for (let row = 0; row < rows; row++) {
	    for (let col = 0; col < cols; col++) {
	      const x = col * (tileWidth + tileSpacing);
	      const y = row * (tileHeight + tileSpacing);

	      floorCanvasCtx.fillStyle = "#cbcab8";
	      floorCanvasCtx.fillRect(x, y + 2, tileWidth, tileHeight);

	      floorCanvasCtx.strokeStyle = "#8c8d7a";
	      floorCanvasCtx.lineWidth = tileSpacing;
	      floorCanvasCtx.strokeRect(x, y + 2, tileWidth, tileHeight);
	    }
	  }
	}

	function addSceneShelf(itemIndex, x, y) {
	  const itemName = ["fitPotion", "fatPotion", "books", "flower"][itemIndex];

	  const canBeReversed = itemName === "books";

	  const shelf = document.createElement("div");
	  shelf.className = `shelf sprite ${itemName} ${
    canBeReversed ? (isLucky(50) ? "reversed" : "") : ""
  }`;
	  shelf.style.left = `${x * 32}px`;
	  shelf.style.top = `${y * 48}px`;

	  scene.append(shelf);
	}

	function renderSceneBackground(background) {
	  for (let shelf of document.querySelectorAll(".shelf")) {
	    shelf.remove();
	  }

	  background.forEach((row, rowIndex) => {
	    row.forEach((item, columnIndex) => {
	      if (item === undefined) {
	        return;
	      }
	      addSceneShelf(item, columnIndex, rowIndex);
	    });
	  });
	}

	function generateSceneBackground() {
	  const getRow = () =>
	    new Array(24).fill(void 0).map(() => (isLucky(25) ? getRandom(3) : void 0));

	  const background = new Array(5).fill(void 0).map(getRow);

	  renderSceneBackground(background);
	}

	let isSceneLightActivated = false;

	function activateSceneLight() {
	  let i = 100;
	  let direction = 1;

	  isSceneLightActivated = true;

	  function updateLight() {
	    if (!isSceneLightActivated) {
	      return;
	    }

	    if (i <= 80 || i >= 100) {
	      direction *= -1;
	    }

	    i += direction;

	    scene.style.setProperty("--dark-amount", i + "%");

	    window.setTimeout(() => {
	      window.requestAnimationFrame(updateLight);
	    }, 132);
	  }

	  updateLight();
	}

	function desactivateSceneLight() {
	  isSceneLightActivated = false;
	}

	function updateCauldronPutridity(putridity) {
	  cauldronScene.dataset.putridity = putridity;
	  putridityValue.innerHTML = putridity;
	}

	function showWinSection(sectionName) {
	  gameWin.className = sectionName;
	}

	function setPlayerSprite(charId) {
	  playerScene.className = "sprite character " + charId;
	}

	function dropCauldron(hasWon, history) {
	  return new Promise((resolve) => {
	    cauldronContent.innerHTML = history.reduce(
	      (acc, uniqCard) =>
	        acc + `<div class="sprite ${uniqCard.id} ${uniqCard.status}"></div>`,
	      ""
	    );
	    cauldronContent.addEventListener("transitionend", resolve, { once: true });

	    cauldronContent.classList.add("shown", hasWon ? "won" : "lost");

	    cauldronScene.style.transform = `rotate(${hasWon ? 90 : -90}deg)`;
	  });
	}

	function initBattle({ putridity, opponentId }) {
	  drawSceneFloor();
	  activateSceneLight();
	  generateSceneBackground();
	  updateCauldronPutridity(putridity);

	  cauldronContent.classList.remove("shown", "won", "lost");

	  cauldronScene.style.removeProperty("transform");

	  opponentScene.className = "sprite character " + opponentId;

	  hand.innerHTML = "";
	}

	function drawCard(uniqCard) {
	  const cardNode = createCardNode(uniqCard, "button");

	  const playedCard = hand.querySelector('.card[data-played="1"]');

	  if (playedCard) {
	    hand.insertBefore(cardNode, playedCard);
	    playedCard.remove();
	  } else {
	    hand.append(cardNode);
	  }
	}

	function applyPoisonToHand(cardsInHand, poison) {
	  hand.innerHTML = "";

	  cardsInHand.forEach((uniqCard) => {
	    const cardNode = createCardNode(uniqCard, "button", poison);
	    hand.append(cardNode);
	  });
	}

	async function throwItem(user, card) {
	  const fromPlayer = user === "player";
	  const fromNode = fromPlayer ? playerScene : opponentScene;

	  const rect = fromNode.getBoundingClientRect();
	  const { left: sourceX, top: sourceY } = rect;
	  thrownItem.style.left = `${sourceX}px`;
	  thrownItem.style.top = `${sourceY}px`;
	  thrownItem.classList.add(card.id, card.status);

	  switch (card.size) {
	    case "mini":
	      thrownItem.style.transform = "scale(2)";
	      break;

	    case "maxi":
	      thrownItem.style.transform = "scale(4)";
	      break;

	    default:
	      thrownItem.style.removeProperty("transform");
	      break;
	  }

	  if (fromPlayer) {
	    thrownItem.classList.add("fromPlayer");
	  }

	  const animation = thrownItem.animate(
	    [{ offsetDistance: "0%" }, { offsetDistance: "100%" }],
	    {
	      duration: 700,
	      iterations: 1,
	      fill: "forwards",
	    }
	  );

	  await animation.finished;

	  animation.cancel();

	  thrownItem.style.removeProperty("left");
	  thrownItem.style.removeProperty("top");
	  thrownItem.classList.remove(card.id, "fromPlayer", card.status);
	}

	async function suggestCardAwards(packs, onPackClicked) {
	  battleResultsWon.dataset.type = "ingredients";

	  cardAwards.innerHTML = "";

	  const mainListFragment = document.createDocumentFragment();

	  packs.forEach((cards) => {
	    const packButton = document.createElement("button");
	    packButton.type = "button";
	    packButton.className = "option";

	    packButton.onclick = () => {
	      onPackClicked(cards);
	    };

	    const packNode = document.createElement("ul");

	    cards.forEach((card) => {
	      const cardItem = document.createElement("li");
	      const cardNode = createCardNode(card);
	      cardNode.classList.add("mini");
	      cardItem.append(cardNode);
	      packNode.append(cardItem);
	    });

	    packButton.append(packNode);
	    mainListFragment.append(packButton);
	  });

	  cardAwards.append(mainListFragment);
	}

	async function suggestPassiveAwards(passives, onPassiveClicked) {
	  battleResultsWon.dataset.type = "passives";

	  passiveAwards.innerHTML = "";

	  const mainListFragment = document.createDocumentFragment();

	  passives.forEach((passive) => {
	    const passiveButton = document.createElement("button");
	    passiveButton.type = "button";
	    passiveButton.className = "option";

	    passiveButton.onclick = () => {
	      onPassiveClicked(passive.id);
	    };

	    const passiveUl = document.createElement("ul");
	    const cardNode = createCardNode(passive, "li");
	    cardNode.classList.add("big");
	    passiveUl.append(cardNode);

	    passiveButton.append(passiveUl);
	    mainListFragment.append(passiveButton);
	  });

	  passiveAwards.append(mainListFragment);
	}

	function renderUnlockedCharacter(character) {
	  const cardNode = createCardNode({
	    id: character.id,
	    getName: () => character.name,
	    getDesc: () => `<q>${character.desc}</q>`,
	  });

	  unlockedCharacter.innerHTML = "";
	  unlockedCharacter.append(cardNode);
	}

	function renderCharacterList$1(characters) {
	  characterList$1.innerHTML = "";

	  characters.forEach((character) => {
	    const cardNode = createCardNode({
	      id: character.id,
	      getName: () => character.name,
	      getDesc: () =>
	        character.isLocked ? character.desc : `<q>${character.desc}</q>`,
	    });

	    let nodeToInsert;

	    if (character.isLocked) {
	      cardNode.classList.add("isLocked");
	      nodeToInsert = document.createElement("div");
	      nodeToInsert.append(cardNode);
	    } else {
	      nodeToInsert = document.createElement("a");
	      if (character.id === "custom") {
	        nodeToInsert.href =
	          "https://adrien-gueret.github.io/brewing_disaster/your_characters.html";

	        nodeToInsert.target = "_blank";
	        nodeToInsert.rel = "opener";
	        nodeToInsert.append(cardNode);
	      } else {
	        nodeToInsert.href = "#rules";
	        nodeToInsert.dataset.characterId = character.id;
	        nodeToInsert.append(cardNode);
	      }
	    }

	    characterList$1.append(nodeToInsert);
	  });
	}

	function renderCardsIntoList(cards, ul) {
	  ul.innerHTML = "";

	  const fragment = document.createDocumentFragment();

	  cards.forEach((card) => {
	    const cardNode = createCardNode(card, "li");
	    cardNode.classList.add("mini");
	    fragment.append(cardNode);
	  });

	  ul.append(fragment);
	}

	function renderPlayerDeck(cards) {
	  renderCardsIntoList(cards, ruleCardList);

	  const cardsToShowOnAwardsScreen = cards.reduce((acc, uniqCard) => {
	    if (!acc[uniqCard.id]) {
	      acc[uniqCard.id] = {
	        card: uniqCard,
	        total: 0,
	      };
	    }

	    acc[uniqCard.id].total++;

	    return acc;
	  }, {});

	  playerDeck.innerHTML = "";
	  const fragment = document.createDocumentFragment();

	  for (let { card, total } of Object.values(cardsToShowOnAwardsScreen)) {
	    const cardNode = createCardNode(card, "li", 0, total);
	    cardNode.classList.add("mini");
	    fragment.append(cardNode);
	  }

	  playerDeck.append(fragment);
	}

	function renderOpponentList(opponentIds, wins, nextOpponent) {
	  opponentList.innerHTML = "";
	  wizardName.innerHTML = `${nextOpponent.name}${
    wins > 3 ? " <span>(hard)</span>" : ""
  }`;
	  nextWizardDesc.innerHTML = nextOpponent.desc;
	  nextWizardPutridity.innerHTML = nextOpponent.startPutridity;

	  renderCardsIntoList(nextOpponent.deck.cards, nextWizardCards);

	  const fragment = document.createDocumentFragment();

	  opponentIds.forEach((id, index) => {
	    const isNext = index === wins;
	    const isPrevious = index < wins;
	    const container = document.createElement(isNext ? "a" : "div");

	    if (isNext) {
	      container.href = "#battleGame";
	    }

	    if (isPrevious) {
	      container.className = "prev";
	    }

	    container.innerHTML = `<div class="sprite ${isNext ? "character" : ""} ${
      isPrevious ? "ok" : id
    }"></div>`;

	    fragment.append(container);
	  });

	  opponentList.append(fragment);
	}

	function toggleSoundsCheckbox(isChecked) {
	  soundsCheckbox.checked = isChecked;
	}

	function onSoundsCheckboxChange(callback) {
	  soundsCheckbox.onchange = callback;
	}

	async function init$1({ onPlayCard }) {
	  hand.onclick = async (e) => {
	    const card = e.target;

	    if (!("uniqId" in card.dataset)) {
	      return;
	    }

	    document.body.inert = true;

	    const animation = card.animate(
	      [{ transform: "translateY(0)" }, { transform: "translateY(-500px)" }],
	      {
	        duration: 300,
	        iterations: 1,
	        fill: "forwards",
	      }
	    );

	    card.dataset.played = 1;

	    await animation.finished;

	    await onPlayCard(card);

	    document.body.inert = false;
	  };
	}

	var ui = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createCardNode: createCardNode,
		drawSceneFloor: drawSceneFloor,
		desactivateSceneLight: desactivateSceneLight,
		updateCauldronPutridity: updateCauldronPutridity,
		showWinSection: showWinSection,
		setPlayerSprite: setPlayerSprite,
		dropCauldron: dropCauldron,
		initBattle: initBattle,
		drawCard: drawCard,
		applyPoisonToHand: applyPoisonToHand,
		throwItem: throwItem,
		suggestCardAwards: suggestCardAwards,
		suggestPassiveAwards: suggestPassiveAwards,
		renderUnlockedCharacter: renderUnlockedCharacter,
		renderCharacterList: renderCharacterList$1,
		renderPlayerDeck: renderPlayerDeck,
		renderOpponentList: renderOpponentList,
		toggleSoundsCheckbox: toggleSoundsCheckbox,
		onSoundsCheckboxChange: onSoundsCheckboxChange,
		'default': init$1
	});

	var require$$1 = /*@__PURE__*/getAugmentedNamespace(ui);

	Object.defineProperty(ui$1, "__esModule", { value: true });
	ui$1.showPrivateKey = showPrivateKey;
	ui$1.showPrivateKeyError = showPrivateKeyError;
	ui$1.hidePrivateKeyError = hidePrivateKeyError;
	ui$1.renderCharacterList = renderCharacterList;
	ui$1.setCardsInputValue = setCardsInputValue;
	ui$1.setCharacterName = setCharacterName;
	ui$1.renderDeckIngredients = renderDeckIngredients;
	ui$1.default = init;
	const cards_1$1 = require$$1$1;
	const ui_1$1 = require$$1;
	const askPrivateKeyForm = document.getElementById("askPrivateKeyForm");
	const privateKeyInput = document.getElementById("privateKeyInput");
	const cancelButton = document.getElementById("cancelButton");
	const privateKeyShow = document.getElementById("privateKeyShow");
	const privateKeyError = document.getElementById("privateKeyError");
	const cardSelection = document.getElementById("cardSelection");
	const deckList = document.getElementById("deckList");
	const cardsInput = document.getElementById("cardsInput");
	const cardCount = document.getElementById("cardCount");
	const saveButton = document.getElementById("saveButton");
	const formCreate = document.getElementById("formCreate");
	const characterName = document.getElementById("characterName");
	const characterList = document.getElementById("characterList");
	function showPrivateKey(key) {
	    privateKeyShow.value = key;
	}
	function showPrivateKeyError() {
	    privateKeyError.style.display = "block";
	}
	function hidePrivateKeyError() {
	    privateKeyError.style.display = "none";
	}
	function renderCharacterList(characters) {
	    characterList.innerHTML = "";
	    characters.forEach((character) => {
	        const cardNode = (0, ui_1$1.createCardNode)({
	            id: character.id,
	            status: "normal",
	            getName: () => character.name,
	            getDesc: () => character.desc,
	        }, "div");
	        let nodeToInsert = cardNode;
	        if (character.href) {
	            nodeToInsert = document.createElement("a");
	            nodeToInsert.href = character.href;
	            nodeToInsert.append(cardNode);
	        }
	        characterList.append(nodeToInsert);
	    });
	}
	function ingredientsStringToIngredientArrayIds(value) {
	    return value
	        .split("_")
	        .filter(Boolean)
	        .flatMap((ingredientData) => {
	        const [ingredientId, total] = ingredientData.split("-");
	        return new Array(+total).fill(ingredientId);
	    });
	}
	function ingredientArrayIdsToIngredientsString(arr) {
	    const ingredientData = {};
	    arr.forEach((ingredientId) => {
	        if (!ingredientData[ingredientId]) {
	            ingredientData[ingredientId] = 0;
	        }
	        ingredientData[ingredientId]++;
	    });
	    const strings = [];
	    for (let [ingredientId, count] of Object.entries(ingredientData)) {
	        strings.push(`${ingredientId}-${count}`);
	    }
	    return strings.join("_");
	}
	function updateCardCount() {
	    const count = ingredientsStringToIngredientArrayIds(cardsInput.value).length;
	    cardCount.innerHTML = "" + count;
	    cardSelection.inert = count === 10;
	    saveButton.inert = count < 10;
	}
	function setCardsInputValue(value) {
	    cardsInput.value = value;
	    updateCardCount();
	    if (value.length === 0) {
	        deckList.innerHTML = "";
	    }
	    else {
	        const cards = ingredientsStringToIngredientArrayIds(value).map((id) => new cards_1$1.UniqCard(id));
	        renderDeckIngredients(cards);
	    }
	}
	function setCharacterName(newValue = "") {
	    characterName.value = newValue;
	}
	function renderDeckIngredients(ingredients) {
	    deckList.innerHTML = "";
	    const fragment = document.createDocumentFragment();
	    ingredients.forEach((ingredient) => {
	        const cardNode = (0, ui_1$1.createCardNode)(ingredient, "button");
	        cardNode.type = "button";
	        cardNode.classList.add("mini");
	        cardNode.onclick = () => {
	            const currentIngredients = ingredientsStringToIngredientArrayIds(cardsInput.value);
	            const index = currentIngredients.findIndex((id) => id === ingredient.id);
	            currentIngredients.splice(index, 1);
	            cardsInput.value =
	                ingredientArrayIdsToIngredientsString(currentIngredients);
	            updateCardCount();
	            cardNode.remove();
	        };
	        fragment.append(cardNode);
	    });
	    deckList.append(fragment);
	}
	function init({ allIngredients, onPrivateKeyEnter, onCancel, onIngredientAdded, onDeckSaved, }) {
	    const fragment = document.createDocumentFragment();
	    allIngredients.forEach((ingredient) => {
	        const cardNode = (0, ui_1$1.createCardNode)(ingredient, "button");
	        cardNode.type = "button";
	        cardNode.classList.add("mini");
	        cardNode.onclick = () => {
	            const currentIngredients = ingredientsStringToIngredientArrayIds(cardsInput.value);
	            currentIngredients.push(ingredient.id);
	            cardsInput.value =
	                ingredientArrayIdsToIngredientsString(currentIngredients);
	            onIngredientAdded(ingredientsStringToIngredientArrayIds(cardsInput.value));
	            updateCardCount();
	        };
	        fragment.append(cardNode);
	    });
	    cardSelection.append(fragment);
	    askPrivateKeyForm.onsubmit = (e) => {
	        e.preventDefault();
	        onPrivateKeyEnter(privateKeyInput.value);
	    };
	    cancelButton.onclick = onCancel;
	    formCreate.onsubmit = (e) => {
	        e.preventDefault();
	        if (ingredientsStringToIngredientArrayIds(cardsInput.value).length < 10) {
	            return;
	        }
	        onDeckSaved(characterName.value, cardsInput.value);
	    };
	}

	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(web3, "__esModule", { value: true });
	const sections_1 = __importStar(require$$0$1);
	const cards_1 = require$$1$1;
	const thirdWebClient_1 = __importDefault(thirdWebClient);
	const keys_1 = __importStar(keys);
	const mu_1 = mu;
	const ui_1 = __importStar(ui$1);
	const hasOpener = Boolean(window.opener);
	const rootURL = hasOpener
	    ? "https://js13kgames.com/games/brewing-disaster/index.html"
	    : window.location.origin;
	(async () => {
	    (0, thirdWebClient_1.default)("l1SCueVB2ZCvJm-c-x2JnWdCygpjiSq3MZa3QPCm2tfQokZe0pH8W-ntr_nDLXzkiz6Ak7NqshYAxW_7o7IrJw");
	    const privateKey = await (0, keys_1.default)();
	    async function checkPrivateKey(onCheckFail) {
	        const publicKey = await (0, keys_1.getPublicKey)();
	        const isOK = await (0, mu_1.checkFile)(publicKey);
	        if (isOK) {
	            (0, sections_1.goToSection)("list");
	        }
	        else {
	            (0, keys_1.setPrivateKey)("");
	            onCheckFail();
	        }
	    }
	    let editedName;
	    let editedCards;
	    const isEdit = () => Boolean(editedName) && Boolean(editedCards);
	    (0, ui_1.default)({
	        allIngredients: cards_1.allCardDataBase.map(({ id }) => new cards_1.UniqCard(id)),
	        async onPrivateKeyEnter(key) {
	            (0, ui_1.hidePrivateKeyError)();
	            await (0, keys_1.setPrivateKey)(key);
	            checkPrivateKey(() => (0, ui_1.showPrivateKeyError)());
	        },
	        onCancel() {
	            if (hasOpener) {
	                window.close();
	            }
	            else {
	                window.location.href = rootURL;
	            }
	        },
	        onIngredientAdded(newIngredientIds) {
	            (0, ui_1.renderDeckIngredients)(newIngredientIds.map((id) => new cards_1.UniqCard(id)));
	        },
	        async onDeckSaved(name, cardData) {
	            let fileContent = (0, mu_1.getDeckContent)().split("\n").filter(Boolean);
	            const newLine = `${name}|${cardData}`;
	            if (isEdit()) {
	                const editedLine = `${editedName}|${editedCards}`;
	                fileContent = fileContent.map((line) => {
	                    if (line !== editedLine) {
	                        return line;
	                    }
	                    return newLine;
	                });
	            }
	            else {
	                fileContent.push(newLine);
	            }
	            (0, sections_1.goToSection)("saving");
	            await (0, mu_1.saveFile)(fileContent);
	            (0, sections_1.goToSection)("list");
	        },
	    });
	    (0, sections_1.default)(({ nextSection, vars }) => {
	        switch (nextSection) {
	            case "newPrivateKey":
	                (0, keys_1.generateNewPrivateKey)().then(async (privateKey) => {
	                    const publicKey = await (0, keys_1.getPublicKey)();
	                    try {
	                        await (0, mu_1.setFile)(publicKey, "");
	                        (0, ui_1.showPrivateKey)(privateKey);
	                    }
	                    catch (e) {
	                        (0, keys_1.setPrivateKey)("");
	                        throw e;
	                    }
	                });
	                break;
	            case "list": {
	                const userDeckContent = (0, mu_1.getDeckContent)();
	                const customCharactersData = Boolean(userDeckContent)
	                    ? userDeckContent.split("\n")
	                    : [];
	                const characters = customCharactersData.map((characterData) => {
	                    const [name, cards] = characterData.split("|");
	                    const editLink = document.createElement("a");
	                    editLink.href = "#create";
	                    editLink.className = "inlineLink";
	                    editLink.dataset.name = name;
	                    editLink.dataset.cards = cards;
	                    editLink.innerHTML = "Edit";
	                    const playLink = document.createElement("button");
	                    playLink.type = "button";
	                    playLink.className = "inlineLink";
	                    playLink.dataset.cards = cards;
	                    playLink.dataset.action = "play";
	                    playLink.innerHTML = "Play";
	                    const deleteLink = document.createElement("button");
	                    deleteLink.type = "button";
	                    deleteLink.className = "inlineLink";
	                    deleteLink.dataset.name = name;
	                    deleteLink.dataset.cards = cards;
	                    deleteLink.dataset.action = "delete";
	                    deleteLink.innerHTML = "Delete";
	                    return {
	                        id: "totter",
	                        name: name.replaceAll("<", "&lt;").replaceAll(">", "&gt;"),
	                        desc: `${deleteLink.outerHTML} ${editLink.outerHTML} ${playLink.outerHTML}`,
	                    };
	                });
	                (0, ui_1.renderCharacterList)([
	                    {
	                        id: "create",
	                        name: "Create character",
	                        desc: "And choose its starter ingredients",
	                        href: "#create",
	                    },
	                    ...characters,
	                ]);
	                break;
	            }
	            case "create": {
	                editedName = vars.name || "";
	                editedCards = vars.cards || "";
	                (0, ui_1.setCardsInputValue)(editedCards);
	                (0, ui_1.setCharacterName)(editedName);
	                break;
	            }
	        }
	    });
	    document.body.addEventListener("click", async (e) => {
	        const clickedElement = e.target;
	        const { dataset } = clickedElement;
	        switch (dataset.action) {
	            case "play": {
	                if (hasOpener) {
	                    window.opener.history.pushState(null, null, `index.html?d=${dataset.cards}#rules`);
	                    window.opener.dispatchEvent(new HashChangeEvent("hashchange"));
	                    window.opener.focus();
	                    window.close();
	                }
	                else {
	                    window.location.href = `${rootURL}/index.html?d=${dataset.cards}#rules`;
	                }
	            }
	            case "delete": {
	                const cardToRemove = clickedElement.closest(".card");
	                document.body.inert = true;
	                cardToRemove.style.opacity = "0.5";
	                try {
	                    const lineToDelete = `${dataset.name}|${dataset.cards}`;
	                    const fileContent = (0, mu_1.getDeckContent)()
	                        .split("\n")
	                        .filter((line) => Boolean(line) && line !== lineToDelete);
	                    await (0, mu_1.saveFile)(fileContent);
	                    cardToRemove.remove();
	                }
	                finally {
	                    cardToRemove.style.opacity = "1";
	                    document.body.inert = false;
	                }
	            }
	        }
	    });
	    if (!privateKey) {
	        (0, sections_1.goToSection)("askPrivateKey");
	    }
	    else {
	        checkPrivateKey(() => (0, sections_1.goToSection)("askPrivateKey"));
	    }
	})();

	return web3;

})();
